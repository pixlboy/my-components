(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"), require("ReactDOM"));
	else if(typeof define === 'function' && define.amd)
		define(["React", "ReactDOM"], factory);
	else if(typeof exports === 'object')
		exports["JnprCL"] = factory(require("React"), require("ReactDOM"));
	else
		root["JnprCL"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_11__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonpJnprCL"];
/******/ 	window["webpackJsonpJnprCL"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				var _m = moreModules[moduleId];
/******/
/******/ 				// Check if module is deduplicated
/******/ 				switch(typeof _m) {
/******/ 				case "object":
/******/ 					// Module can be created from a template
/******/ 					modules[moduleId] = (function(_m) {
/******/ 						var args = _m.slice(1), templateId = _m[0];
/******/ 						return function (a,b,c) {
/******/ 							modules[templateId].apply(this, [a,b,c].concat(args));
/******/ 						};
/******/ 					}(_m));
/******/ 					break;
/******/ 				case "function":
/******/ 					// Normal module
/******/ 					modules[moduleId] = _m;
/******/ 					break;
/******/ 				default:
/******/ 					// Module is a copy of another module
/******/ 					modules[moduleId] = modules[_m];
/******/ 					break;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		0:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + ".chunk.js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/*!********************************!*\
  !*** ./public/src/vendors.jsx ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {'use strict';
	
	var _reactMdl = __webpack_require__(/*! react-mdl */ 10);
	
	__webpack_provided_window_dot_jQuery = __webpack_require__(/*! jquery */ 3);
	__webpack_require__(/*! jquery-ui/ui/core */ 19);
	__webpack_require__(/*! jquery-ui/ui/resizable */ 73);
	__webpack_require__(/*! jquery-ui/ui/tooltip */ 227);
	__webpack_require__(/*! jquery-ui/ui/datepicker */ 224);
	__webpack_require__(/*! jquery-ui/ui/sortable */ 226);
	__webpack_require__(/*! immutable */ 122);
	__webpack_require__(/*! perfect-scrollbar */ 27);
	__webpack_require__(/*! underscore */ 9);
	__webpack_require__(/*! flux */ 71);
	__webpack_require__(/*! swiper */ 132);
	__webpack_require__(/*! fixed-data-table-2 */ 23);
	__webpack_require__(/*! material-design-lite/material */ 230);
	__webpack_require__(/*! react-mdl */ 10);
	__webpack_require__(/*! dialog-polyfill */ 110);
	__webpack_require__(/*! dialog-polyfill/dialog-polyfill.css */ 395);
	//require('material-design-lite/material.css');
	
	
	__webpack_require__(/*! ./lib/evaporate */ 136);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 3)))

/***/ }),
/* 1 */
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/*!*******************************!*\
  !*** ./~/classnames/index.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	  Copyright (c) 2017 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames() {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg) && arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			classNames.default = classNames;
			module.exports = classNames;
		} else if ("function" === 'function' && _typeof(__webpack_require__(/*! !webpack amd options */ 32)) === 'object' && __webpack_require__(/*! !webpack amd options */ 32)) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	})();

/***/ }),
/* 3 */
/*!*********************************!*\
  !*** ./~/jquery/dist/jquery.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * jQuery JavaScript Library v2.2.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-05-20T17:23Z
	 */
	
	(function (global, factory) {
	
		if (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ? factory(global, true) : function (w) {
				if (!w.document) {
					throw new Error("jQuery requires a window with a document");
				}
				return factory(w);
			};
		} else {
			factory(global);
		}
	
		// Pass this if window is not defined yet
	})(typeof window !== "undefined" ? window : undefined, function (window, noGlobal) {
	
		// Support: Firefox 18+
		// Can't be in strict mode, several libs including ASP.NET trace
		// the stack via arguments.caller.callee and Firefox dies if
		// you try to trace through "use strict" call chains. (#13335)
		//"use strict";
		var arr = [];
	
		var document = window.document;
	
		var _slice = arr.slice;
	
		var concat = arr.concat;
	
		var push = arr.push;
	
		var indexOf = arr.indexOf;
	
		var class2type = {};
	
		var toString = class2type.toString;
	
		var hasOwn = class2type.hasOwnProperty;
	
		var support = {};
	
		var version = "2.2.4",
	
	
		// Define a local copy of jQuery
		jQuery = function jQuery(selector, context) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init(selector, context);
		},
	
	
		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
	
	
		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		    rdashAlpha = /-([\da-z])/gi,
	
	
		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function fcamelCase(all, letter) {
			return letter.toUpperCase();
		};
	
		jQuery.fn = jQuery.prototype = {
	
			// The current version of jQuery being used
			jquery: version,
	
			constructor: jQuery,
	
			// Start with an empty selector
			selector: "",
	
			// The default length of a jQuery object is 0
			length: 0,
	
			toArray: function toArray() {
				return _slice.call(this);
			},
	
			// Get the Nth element in the matched element set OR
			// Get the whole matched element set as a clean array
			get: function get(num) {
				return num != null ?
	
				// Return just the one element from the set
				num < 0 ? this[num + this.length] : this[num] :
	
				// Return all the elements in a clean array
				_slice.call(this);
			},
	
			// Take an array of elements and push it onto the stack
			// (returning the new matched element set)
			pushStack: function pushStack(elems) {
	
				// Build a new jQuery matched element set
				var ret = jQuery.merge(this.constructor(), elems);
	
				// Add the old object onto the stack (as a reference)
				ret.prevObject = this;
				ret.context = this.context;
	
				// Return the newly-formed element set
				return ret;
			},
	
			// Execute a callback for every element in the matched set.
			each: function each(callback) {
				return jQuery.each(this, callback);
			},
	
			map: function map(callback) {
				return this.pushStack(jQuery.map(this, function (elem, i) {
					return callback.call(elem, i, elem);
				}));
			},
	
			slice: function slice() {
				return this.pushStack(_slice.apply(this, arguments));
			},
	
			first: function first() {
				return this.eq(0);
			},
	
			last: function last() {
				return this.eq(-1);
			},
	
			eq: function eq(i) {
				var len = this.length,
				    j = +i + (i < 0 ? len : 0);
				return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
			},
	
			end: function end() {
				return this.prevObject || this.constructor();
			},
	
			// For internal use only.
			// Behaves like an Array's method, not like a jQuery method.
			push: push,
			sort: arr.sort,
			splice: arr.splice
		};
	
		jQuery.extend = jQuery.fn.extend = function () {
			var options,
			    name,
			    src,
			    copy,
			    copyIsArray,
			    clone,
			    target = arguments[0] || {},
			    i = 1,
			    length = arguments.length,
			    deep = false;
	
			// Handle a deep copy situation
			if (typeof target === "boolean") {
				deep = target;
	
				// Skip the boolean and the target
				target = arguments[i] || {};
				i++;
			}
	
			// Handle case when target is a string or something (possible in deep copy)
			if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !jQuery.isFunction(target)) {
				target = {};
			}
	
			// Extend jQuery itself if only one argument is passed
			if (i === length) {
				target = this;
				i--;
			}
	
			for (; i < length; i++) {
	
				// Only deal with non-null/undefined values
				if ((options = arguments[i]) != null) {
	
					// Extend the base object
					for (name in options) {
						src = target[name];
						copy = options[name];
	
						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}
	
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
	
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && jQuery.isArray(src) ? src : [];
							} else {
								clone = src && jQuery.isPlainObject(src) ? src : {};
							}
	
							// Never move original objects, clone them
							target[name] = jQuery.extend(deep, clone, copy);
	
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
	
			// Return the modified object
			return target;
		};
	
		jQuery.extend({
	
			// Unique for each copy of jQuery on the page
			expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
	
			// Assume jQuery is ready without the ready module
			isReady: true,
	
			error: function error(msg) {
				throw new Error(msg);
			},
	
			noop: function noop() {},
	
			isFunction: function isFunction(obj) {
				return jQuery.type(obj) === "function";
			},
	
			isArray: Array.isArray,
	
			isWindow: function isWindow(obj) {
				return obj != null && obj === obj.window;
			},
	
			isNumeric: function isNumeric(obj) {
	
				// parseFloat NaNs numeric-cast false positives (null|true|false|"")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				// adding 1 corrects loss of precision from parseFloat (#15100)
				var realStringObj = obj && obj.toString();
				return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
			},
	
			isPlainObject: function isPlainObject(obj) {
				var key;
	
				// Not plain objects:
				// - Any object or value whose internal [[Class]] property is not "[object Object]"
				// - DOM nodes
				// - window
				if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
					return false;
				}
	
				// Not own constructor property must be Object
				if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
					return false;
				}
	
				// Own properties are enumerated firstly, so to speed up,
				// if last one is own, then all properties are own
				for (key in obj) {}
	
				return key === undefined || hasOwn.call(obj, key);
			},
	
			isEmptyObject: function isEmptyObject(obj) {
				var name;
				for (name in obj) {
					return false;
				}
				return true;
			},
	
			type: function type(obj) {
				if (obj == null) {
					return obj + "";
				}
	
				// Support: Android<4.0, iOS<6 (functionish RegExp)
				return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
			},
	
			// Evaluates a script in a global context
			globalEval: function globalEval(code) {
				var script,
				    indirect = eval;
	
				code = jQuery.trim(code);
	
				if (code) {
	
					// If the code includes a valid, prologue position
					// strict mode pragma, execute code by injecting a
					// script tag into the document.
					if (code.indexOf("use strict") === 1) {
						script = document.createElement("script");
						script.text = code;
						document.head.appendChild(script).parentNode.removeChild(script);
					} else {
	
						// Otherwise, avoid the DOM node creation, insertion
						// and removal by using an indirect global eval
	
						indirect(code);
					}
				}
			},
	
			// Convert dashed to camelCase; used by the css and data modules
			// Support: IE9-11+
			// Microsoft forgot to hump their vendor prefix (#9572)
			camelCase: function camelCase(string) {
				return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
			},
	
			nodeName: function nodeName(elem, name) {
				return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
			},
	
			each: function each(obj, callback) {
				var length,
				    i = 0;
	
				if (isArrayLike(obj)) {
					length = obj.length;
					for (; i < length; i++) {
						if (callback.call(obj[i], i, obj[i]) === false) {
							break;
						}
					}
				} else {
					for (i in obj) {
						if (callback.call(obj[i], i, obj[i]) === false) {
							break;
						}
					}
				}
	
				return obj;
			},
	
			// Support: Android<4.1
			trim: function trim(text) {
				return text == null ? "" : (text + "").replace(rtrim, "");
			},
	
			// results is for internal usage only
			makeArray: function makeArray(arr, results) {
				var ret = results || [];
	
				if (arr != null) {
					if (isArrayLike(Object(arr))) {
						jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
					} else {
						push.call(ret, arr);
					}
				}
	
				return ret;
			},
	
			inArray: function inArray(elem, arr, i) {
				return arr == null ? -1 : indexOf.call(arr, elem, i);
			},
	
			merge: function merge(first, second) {
				var len = +second.length,
				    j = 0,
				    i = first.length;
	
				for (; j < len; j++) {
					first[i++] = second[j];
				}
	
				first.length = i;
	
				return first;
			},
	
			grep: function grep(elems, callback, invert) {
				var callbackInverse,
				    matches = [],
				    i = 0,
				    length = elems.length,
				    callbackExpect = !invert;
	
				// Go through the array, only saving the items
				// that pass the validator function
				for (; i < length; i++) {
					callbackInverse = !callback(elems[i], i);
					if (callbackInverse !== callbackExpect) {
						matches.push(elems[i]);
					}
				}
	
				return matches;
			},
	
			// arg is for internal usage only
			map: function map(elems, callback, arg) {
				var length,
				    value,
				    i = 0,
				    ret = [];
	
				// Go through the array, translating each of the items to their new values
				if (isArrayLike(elems)) {
					length = elems.length;
					for (; i < length; i++) {
						value = callback(elems[i], i, arg);
	
						if (value != null) {
							ret.push(value);
						}
					}
	
					// Go through every key on the object,
				} else {
					for (i in elems) {
						value = callback(elems[i], i, arg);
	
						if (value != null) {
							ret.push(value);
						}
					}
				}
	
				// Flatten any nested arrays
				return concat.apply([], ret);
			},
	
			// A global GUID counter for objects
			guid: 1,
	
			// Bind a function to a context, optionally partially applying any
			// arguments.
			proxy: function proxy(fn, context) {
				var tmp, args, proxy;
	
				if (typeof context === "string") {
					tmp = fn[context];
					context = fn;
					fn = tmp;
				}
	
				// Quick check to determine if target is callable, in the spec
				// this throws a TypeError, but we will just return undefined.
				if (!jQuery.isFunction(fn)) {
					return undefined;
				}
	
				// Simulated bind
				args = _slice.call(arguments, 2);
				proxy = function proxy() {
					return fn.apply(context || this, args.concat(_slice.call(arguments)));
				};
	
				// Set the guid of unique handler to the same of original handler, so it can be removed
				proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
				return proxy;
			},
	
			now: Date.now,
	
			// jQuery.support is not used in Core but other projects attach their
			// properties to it so it needs to exist.
			support: support
		});
	
		// JSHint would error on this code due to the Symbol not being defined in ES5.
		// Defining this global in .jshintrc would create a danger of using the global
		// unguarded in another place, it seems safer to just disable JSHint for these
		// three lines.
		/* jshint ignore: start */
		if (typeof Symbol === "function") {
			jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
		}
		/* jshint ignore: end */
	
		// Populate the class2type map
		jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
			class2type["[object " + name + "]"] = name.toLowerCase();
		});
	
		function isArrayLike(obj) {
	
			// Support: iOS 8.2 (not reproducible in simulator)
			// `in` check used to prevent JIT error (gh-2145)
			// hasOwn isn't used here due to false negatives
			// regarding Nodelist length in IE
			var length = !!obj && "length" in obj && obj.length,
			    type = jQuery.type(obj);
	
			if (type === "function" || jQuery.isWindow(obj)) {
				return false;
			}
	
			return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
		}
		var Sizzle =
		/*!
	  * Sizzle CSS Selector Engine v2.2.1
	  * http://sizzlejs.com/
	  *
	  * Copyright jQuery Foundation and other contributors
	  * Released under the MIT license
	  * http://jquery.org/license
	  *
	  * Date: 2015-10-17
	  */
		function (window) {
	
			var i,
			    support,
			    Expr,
			    getText,
			    isXML,
			    tokenize,
			    compile,
			    select,
			    outermostContext,
			    sortInput,
			    hasDuplicate,
	
	
			// Local document vars
			setDocument,
			    document,
			    docElem,
			    documentIsHTML,
			    rbuggyQSA,
			    rbuggyMatches,
			    matches,
			    contains,
	
	
			// Instance-specific data
			expando = "sizzle" + 1 * new Date(),
			    preferredDoc = window.document,
			    dirruns = 0,
			    done = 0,
			    classCache = createCache(),
			    tokenCache = createCache(),
			    compilerCache = createCache(),
			    sortOrder = function sortOrder(a, b) {
				if (a === b) {
					hasDuplicate = true;
				}
				return 0;
			},
	
	
			// General-purpose constants
			MAX_NEGATIVE = 1 << 31,
	
	
			// Instance methods
			hasOwn = {}.hasOwnProperty,
			    arr = [],
			    pop = arr.pop,
			    push_native = arr.push,
			    push = arr.push,
			    slice = arr.slice,
	
			// Use a stripped-down indexOf as it's faster than native
			// http://jsperf.com/thor-indexof-vs-for/5
			indexOf = function indexOf(list, elem) {
				var i = 0,
				    len = list.length;
				for (; i < len; i++) {
					if (list[i] === elem) {
						return i;
					}
				}
				return -1;
			},
			    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
	
			// Regular expressions
	
			// http://www.w3.org/TR/css3-selectors/#whitespace
			whitespace = "[\\x20\\t\\r\\n\\f]",
	
	
			// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
			identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
	
			// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
			attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
			    pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" + ")\\)|)",
	
	
			// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
			rwhitespace = new RegExp(whitespace + "+", "g"),
			    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
			    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
			    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
			    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
			    rpseudo = new RegExp(pseudos),
			    ridentifier = new RegExp("^" + identifier + "$"),
			    matchExpr = {
				"ID": new RegExp("^#(" + identifier + ")"),
				"CLASS": new RegExp("^\\.(" + identifier + ")"),
				"TAG": new RegExp("^(" + identifier + "|[*])"),
				"ATTR": new RegExp("^" + attributes),
				"PSEUDO": new RegExp("^" + pseudos),
				"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
				"bool": new RegExp("^(?:" + booleans + ")$", "i"),
				// For use in libraries implementing .is()
				// We use this for POS matching in `select`
				"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
			},
			    rinputs = /^(?:input|select|textarea|button)$/i,
			    rheader = /^h\d$/i,
			    rnative = /^[^{]+\{\s*\[native \w/,
	
	
			// Easily-parseable/retrievable ID or TAG or CLASS selectors
			rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
			    rsibling = /[+~]/,
			    rescape = /'|\\/g,
	
	
			// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
			runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
			    funescape = function funescape(_, escaped, escapedWhitespace) {
				var high = "0x" + escaped - 0x10000;
				// NaN means non-codepoint
				// Support: Firefox<24
				// Workaround erroneous numeric interpretation of +"0x"
				return high !== high || escapedWhitespace ? escaped : high < 0 ?
				// BMP codepoint
				String.fromCharCode(high + 0x10000) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
			},
	
	
			// Used for iframes
			// See setDocument()
			// Removing the function wrapper causes a "Permission Denied"
			// error in IE
			unloadHandler = function unloadHandler() {
				setDocument();
			};
	
			// Optimize for push.apply( _, NodeList )
			try {
				push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
				// Support: Android<4.0
				// Detect silently failing push.apply
				arr[preferredDoc.childNodes.length].nodeType;
			} catch (e) {
				push = { apply: arr.length ?
	
					// Leverage slice if possible
					function (target, els) {
						push_native.apply(target, slice.call(els));
					} :
	
					// Support: IE<9
					// Otherwise append directly
					function (target, els) {
						var j = target.length,
						    i = 0;
						// Can't trust NodeList.length
						while (target[j++] = els[i++]) {}
						target.length = j - 1;
					}
				};
			}
	
			function Sizzle(selector, context, results, seed) {
				var m,
				    i,
				    elem,
				    nid,
				    nidselect,
				    match,
				    groups,
				    newSelector,
				    newContext = context && context.ownerDocument,
	
	
				// nodeType defaults to 9, since context defaults to document
				nodeType = context ? context.nodeType : 9;
	
				results = results || [];
	
				// Return early from calls with invalid selector or context
				if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
	
					return results;
				}
	
				// Try to shortcut find operations (as opposed to filters) in HTML documents
				if (!seed) {
	
					if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
						setDocument(context);
					}
					context = context || document;
	
					if (documentIsHTML) {
	
						// If the selector is sufficiently simple, try using a "get*By*" DOM method
						// (excepting DocumentFragment context, where the methods don't exist)
						if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
	
							// ID selector
							if (m = match[1]) {
	
								// Document context
								if (nodeType === 9) {
									if (elem = context.getElementById(m)) {
	
										// Support: IE, Opera, Webkit
										// TODO: identify versions
										// getElementById can match elements by name instead of ID
										if (elem.id === m) {
											results.push(elem);
											return results;
										}
									} else {
										return results;
									}
	
									// Element context
								} else {
	
									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
	
										results.push(elem);
										return results;
									}
								}
	
								// Type selector
							} else if (match[2]) {
								push.apply(results, context.getElementsByTagName(selector));
								return results;
	
								// Class selector
							} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
	
								push.apply(results, context.getElementsByClassName(m));
								return results;
							}
						}
	
						// Take advantage of querySelectorAll
						if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
	
							if (nodeType !== 1) {
								newContext = context;
								newSelector = selector;
	
								// qSA looks outside Element context, which is not what we want
								// Thanks to Andrew Dupont for this workaround technique
								// Support: IE <=8
								// Exclude object elements
							} else if (context.nodeName.toLowerCase() !== "object") {
	
								// Capture the context ID, setting it first if necessary
								if (nid = context.getAttribute("id")) {
									nid = nid.replace(rescape, "\\$&");
								} else {
									context.setAttribute("id", nid = expando);
								}
	
								// Prefix every selector in the list
								groups = tokenize(selector);
								i = groups.length;
								nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
								while (i--) {
									groups[i] = nidselect + " " + toSelector(groups[i]);
								}
								newSelector = groups.join(",");
	
								// Expand context for sibling selectors
								newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
							}
	
							if (newSelector) {
								try {
									push.apply(results, newContext.querySelectorAll(newSelector));
									return results;
								} catch (qsaError) {} finally {
									if (nid === expando) {
										context.removeAttribute("id");
									}
								}
							}
						}
					}
				}
	
				// All others
				return select(selector.replace(rtrim, "$1"), context, results, seed);
			}
	
			/**
	   * Create key-value caches of limited size
	   * @returns {function(string, object)} Returns the Object data after storing it on itself with
	   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	   *	deleting the oldest entry
	   */
			function createCache() {
				var keys = [];
	
				function cache(key, value) {
					// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
					if (keys.push(key + " ") > Expr.cacheLength) {
						// Only keep the most recent entries
						delete cache[keys.shift()];
					}
					return cache[key + " "] = value;
				}
				return cache;
			}
	
			/**
	   * Mark a function for special use by Sizzle
	   * @param {Function} fn The function to mark
	   */
			function markFunction(fn) {
				fn[expando] = true;
				return fn;
			}
	
			/**
	   * Support testing using an element
	   * @param {Function} fn Passed the created div and expects a boolean result
	   */
			function assert(fn) {
				var div = document.createElement("div");
	
				try {
					return !!fn(div);
				} catch (e) {
					return false;
				} finally {
					// Remove from its parent by default
					if (div.parentNode) {
						div.parentNode.removeChild(div);
					}
					// release memory in IE
					div = null;
				}
			}
	
			/**
	   * Adds the same handler for all of the specified attrs
	   * @param {String} attrs Pipe-separated list of attributes
	   * @param {Function} handler The method that will be applied
	   */
			function addHandle(attrs, handler) {
				var arr = attrs.split("|"),
				    i = arr.length;
	
				while (i--) {
					Expr.attrHandle[arr[i]] = handler;
				}
			}
	
			/**
	   * Checks document order of two siblings
	   * @param {Element} a
	   * @param {Element} b
	   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	   */
			function siblingCheck(a, b) {
				var cur = b && a,
				    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
	
				// Use IE sourceIndex if available on both nodes
				if (diff) {
					return diff;
				}
	
				// Check if b follows a
				if (cur) {
					while (cur = cur.nextSibling) {
						if (cur === b) {
							return -1;
						}
					}
				}
	
				return a ? 1 : -1;
			}
	
			/**
	   * Returns a function to use in pseudos for input types
	   * @param {String} type
	   */
			function createInputPseudo(type) {
				return function (elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === type;
				};
			}
	
			/**
	   * Returns a function to use in pseudos for buttons
	   * @param {String} type
	   */
			function createButtonPseudo(type) {
				return function (elem) {
					var name = elem.nodeName.toLowerCase();
					return (name === "input" || name === "button") && elem.type === type;
				};
			}
	
			/**
	   * Returns a function to use in pseudos for positionals
	   * @param {Function} fn
	   */
			function createPositionalPseudo(fn) {
				return markFunction(function (argument) {
					argument = +argument;
					return markFunction(function (seed, matches) {
						var j,
						    matchIndexes = fn([], seed.length, argument),
						    i = matchIndexes.length;
	
						// Match elements found at the specified indexes
						while (i--) {
							if (seed[j = matchIndexes[i]]) {
								seed[j] = !(matches[j] = seed[j]);
							}
						}
					});
				});
			}
	
			/**
	   * Checks a node for validity as a Sizzle context
	   * @param {Element|Object=} context
	   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	   */
			function testContext(context) {
				return context && typeof context.getElementsByTagName !== "undefined" && context;
			}
	
			// Expose support vars for convenience
			support = Sizzle.support = {};
	
			/**
	   * Detects XML nodes
	   * @param {Element|Object} elem An element or a document
	   * @returns {Boolean} True iff elem is a non-HTML XML node
	   */
			isXML = Sizzle.isXML = function (elem) {
				// documentElement is verified for cases where it doesn't yet exist
				// (such as loading iframes in IE - #4833)
				var documentElement = elem && (elem.ownerDocument || elem).documentElement;
				return documentElement ? documentElement.nodeName !== "HTML" : false;
			};
	
			/**
	   * Sets document-related variables once based on the current document
	   * @param {Element|Object} [doc] An element or document object to use to set the document
	   * @returns {Object} Returns the current document
	   */
			setDocument = Sizzle.setDocument = function (node) {
				var hasCompare,
				    parent,
				    doc = node ? node.ownerDocument || node : preferredDoc;
	
				// Return early if doc is invalid or already selected
				if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
					return document;
				}
	
				// Update global variables
				document = doc;
				docElem = document.documentElement;
				documentIsHTML = !isXML(document);
	
				// Support: IE 9-11, Edge
				// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
				if ((parent = document.defaultView) && parent.top !== parent) {
					// Support: IE 11
					if (parent.addEventListener) {
						parent.addEventListener("unload", unloadHandler, false);
	
						// Support: IE 9 - 10 only
					} else if (parent.attachEvent) {
						parent.attachEvent("onunload", unloadHandler);
					}
				}
	
				/* Attributes
	   ---------------------------------------------------------------------- */
	
				// Support: IE<8
				// Verify that getAttribute really returns attributes and not properties
				// (excepting IE8 booleans)
				support.attributes = assert(function (div) {
					div.className = "i";
					return !div.getAttribute("className");
				});
	
				/* getElement(s)By*
	   ---------------------------------------------------------------------- */
	
				// Check if getElementsByTagName("*") returns only elements
				support.getElementsByTagName = assert(function (div) {
					div.appendChild(document.createComment(""));
					return !div.getElementsByTagName("*").length;
				});
	
				// Support: IE<9
				support.getElementsByClassName = rnative.test(document.getElementsByClassName);
	
				// Support: IE<10
				// Check if getElementById returns elements by name
				// The broken getElementById methods don't pick up programatically-set names,
				// so use a roundabout getElementsByName test
				support.getById = assert(function (div) {
					docElem.appendChild(div).id = expando;
					return !document.getElementsByName || !document.getElementsByName(expando).length;
				});
	
				// ID find and filter
				if (support.getById) {
					Expr.find["ID"] = function (id, context) {
						if (typeof context.getElementById !== "undefined" && documentIsHTML) {
							var m = context.getElementById(id);
							return m ? [m] : [];
						}
					};
					Expr.filter["ID"] = function (id) {
						var attrId = id.replace(runescape, funescape);
						return function (elem) {
							return elem.getAttribute("id") === attrId;
						};
					};
				} else {
					// Support: IE6/7
					// getElementById is not reliable as a find shortcut
					delete Expr.find["ID"];
	
					Expr.filter["ID"] = function (id) {
						var attrId = id.replace(runescape, funescape);
						return function (elem) {
							var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
							return node && node.value === attrId;
						};
					};
				}
	
				// Tag
				Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
					if (typeof context.getElementsByTagName !== "undefined") {
						return context.getElementsByTagName(tag);
	
						// DocumentFragment nodes don't have gEBTN
					} else if (support.qsa) {
						return context.querySelectorAll(tag);
					}
				} : function (tag, context) {
					var elem,
					    tmp = [],
					    i = 0,
	
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName(tag);
	
					// Filter out possible comments
					if (tag === "*") {
						while (elem = results[i++]) {
							if (elem.nodeType === 1) {
								tmp.push(elem);
							}
						}
	
						return tmp;
					}
					return results;
				};
	
				// Class
				Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
					if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
						return context.getElementsByClassName(className);
					}
				};
	
				/* QSA/matchesSelector
	   ---------------------------------------------------------------------- */
	
				// QSA and matchesSelector support
	
				// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
				rbuggyMatches = [];
	
				// qSa(:focus) reports false when true (Chrome 21)
				// We allow this because of a bug in IE8/9 that throws an error
				// whenever `document.activeElement` is accessed on an iframe
				// So, we allow :focus to pass through QSA all the time to avoid the IE error
				// See http://bugs.jquery.com/ticket/13378
				rbuggyQSA = [];
	
				if (support.qsa = rnative.test(document.querySelectorAll)) {
					// Build QSA regex
					// Regex strategy adopted from Diego Perini
					assert(function (div) {
						// Select is set to empty string on purpose
						// This is to test IE's treatment of not explicitly
						// setting a boolean content attribute,
						// since its presence should be enough
						// http://bugs.jquery.com/ticket/12359
						docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
	
						// Support: IE8, Opera 11-12.16
						// Nothing should be selected when empty strings follow ^= or $= or *=
						// The test attribute must be unknown in Opera but "safe" for WinRT
						// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
						if (div.querySelectorAll("[msallowcapture^='']").length) {
							rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
						}
	
						// Support: IE8
						// Boolean attributes and "value" are not treated correctly
						if (!div.querySelectorAll("[selected]").length) {
							rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
						}
	
						// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
						if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
							rbuggyQSA.push("~=");
						}
	
						// Webkit/Opera - :checked should return selected option elements
						// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
						// IE8 throws error here and will not see later tests
						if (!div.querySelectorAll(":checked").length) {
							rbuggyQSA.push(":checked");
						}
	
						// Support: Safari 8+, iOS 8+
						// https://bugs.webkit.org/show_bug.cgi?id=136851
						// In-page `selector#id sibing-combinator selector` fails
						if (!div.querySelectorAll("a#" + expando + "+*").length) {
							rbuggyQSA.push(".#.+[+~]");
						}
					});
	
					assert(function (div) {
						// Support: Windows 8 Native Apps
						// The type and name attributes are restricted during .innerHTML assignment
						var input = document.createElement("input");
						input.setAttribute("type", "hidden");
						div.appendChild(input).setAttribute("name", "D");
	
						// Support: IE8
						// Enforce case-sensitivity of name attribute
						if (div.querySelectorAll("[name=d]").length) {
							rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
						}
	
						// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
						// IE8 throws error here and will not see later tests
						if (!div.querySelectorAll(":enabled").length) {
							rbuggyQSA.push(":enabled", ":disabled");
						}
	
						// Opera 10-11 does not throw on post-comma invalid pseudos
						div.querySelectorAll("*,:x");
						rbuggyQSA.push(",.*:");
					});
				}
	
				if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
	
					assert(function (div) {
						// Check to see if it's possible to do matchesSelector
						// on a disconnected node (IE 9)
						support.disconnectedMatch = matches.call(div, "div");
	
						// This should fail with an exception
						// Gecko does not error, returns false instead
						matches.call(div, "[s!='']:x");
						rbuggyMatches.push("!=", pseudos);
					});
				}
	
				rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
				rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
	
				/* Contains
	   ---------------------------------------------------------------------- */
				hasCompare = rnative.test(docElem.compareDocumentPosition);
	
				// Element contains another
				// Purposefully self-exclusive
				// As in, an element does not contain itself
				contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
					var adown = a.nodeType === 9 ? a.documentElement : a,
					    bup = b && b.parentNode;
					return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
				} : function (a, b) {
					if (b) {
						while (b = b.parentNode) {
							if (b === a) {
								return true;
							}
						}
					}
					return false;
				};
	
				/* Sorting
	   ---------------------------------------------------------------------- */
	
				// Document order sorting
				sortOrder = hasCompare ? function (a, b) {
	
					// Flag for duplicate removal
					if (a === b) {
						hasDuplicate = true;
						return 0;
					}
	
					// Sort on method existence if only one input has compareDocumentPosition
					var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
					if (compare) {
						return compare;
					}
	
					// Calculate position if both inputs belong to the same document
					compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :
	
					// Otherwise we know they are disconnected
					1;
	
					// Disconnected nodes
					if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
	
						// Choose the first element that is related to our preferred document
						if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
							return -1;
						}
						if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
							return 1;
						}
	
						// Maintain original order
						return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
					}
	
					return compare & 4 ? -1 : 1;
				} : function (a, b) {
					// Exit early if the nodes are identical
					if (a === b) {
						hasDuplicate = true;
						return 0;
					}
	
					var cur,
					    i = 0,
					    aup = a.parentNode,
					    bup = b.parentNode,
					    ap = [a],
					    bp = [b];
	
					// Parentless nodes are either documents or disconnected
					if (!aup || !bup) {
						return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
	
						// If the nodes are siblings, we can do a quick check
					} else if (aup === bup) {
						return siblingCheck(a, b);
					}
	
					// Otherwise we need full lists of their ancestors for comparison
					cur = a;
					while (cur = cur.parentNode) {
						ap.unshift(cur);
					}
					cur = b;
					while (cur = cur.parentNode) {
						bp.unshift(cur);
					}
	
					// Walk down the tree looking for a discrepancy
					while (ap[i] === bp[i]) {
						i++;
					}
	
					return i ?
					// Do a sibling check if the nodes have a common ancestor
					siblingCheck(ap[i], bp[i]) :
	
					// Otherwise nodes in our document sort first
					ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
				};
	
				return document;
			};
	
			Sizzle.matches = function (expr, elements) {
				return Sizzle(expr, null, null, elements);
			};
	
			Sizzle.matchesSelector = function (elem, expr) {
				// Set document vars if needed
				if ((elem.ownerDocument || elem) !== document) {
					setDocument(elem);
				}
	
				// Make sure that attribute selectors are quoted
				expr = expr.replace(rattributeQuotes, "='$1']");
	
				if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
	
					try {
						var ret = matches.call(elem, expr);
	
						// IE 9's matchesSelector returns false on disconnected nodes
						if (ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11) {
							return ret;
						}
					} catch (e) {}
				}
	
				return Sizzle(expr, document, null, [elem]).length > 0;
			};
	
			Sizzle.contains = function (context, elem) {
				// Set document vars if needed
				if ((context.ownerDocument || context) !== document) {
					setDocument(context);
				}
				return contains(context, elem);
			};
	
			Sizzle.attr = function (elem, name) {
				// Set document vars if needed
				if ((elem.ownerDocument || elem) !== document) {
					setDocument(elem);
				}
	
				var fn = Expr.attrHandle[name.toLowerCase()],
	
				// Don't get fooled by Object.prototype properties (jQuery #13807)
				val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
	
				return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
			};
	
			Sizzle.error = function (msg) {
				throw new Error("Syntax error, unrecognized expression: " + msg);
			};
	
			/**
	   * Document sorting and removing duplicates
	   * @param {ArrayLike} results
	   */
			Sizzle.uniqueSort = function (results) {
				var elem,
				    duplicates = [],
				    j = 0,
				    i = 0;
	
				// Unless we *know* we can detect duplicates, assume their presence
				hasDuplicate = !support.detectDuplicates;
				sortInput = !support.sortStable && results.slice(0);
				results.sort(sortOrder);
	
				if (hasDuplicate) {
					while (elem = results[i++]) {
						if (elem === results[i]) {
							j = duplicates.push(i);
						}
					}
					while (j--) {
						results.splice(duplicates[j], 1);
					}
				}
	
				// Clear input after sorting to release objects
				// See https://github.com/jquery/sizzle/pull/225
				sortInput = null;
	
				return results;
			};
	
			/**
	   * Utility function for retrieving the text value of an array of DOM nodes
	   * @param {Array|Element} elem
	   */
			getText = Sizzle.getText = function (elem) {
				var node,
				    ret = "",
				    i = 0,
				    nodeType = elem.nodeType;
	
				if (!nodeType) {
					// If no nodeType, this is expected to be an array
					while (node = elem[i++]) {
						// Do not traverse comment nodes
						ret += getText(node);
					}
				} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
					// Use textContent for elements
					// innerText usage removed for consistency of new lines (jQuery #11153)
					if (typeof elem.textContent === "string") {
						return elem.textContent;
					} else {
						// Traverse its children
						for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
							ret += getText(elem);
						}
					}
				} else if (nodeType === 3 || nodeType === 4) {
					return elem.nodeValue;
				}
				// Do not include comment or processing instruction nodes
	
				return ret;
			};
	
			Expr = Sizzle.selectors = {
	
				// Can be adjusted by the user
				cacheLength: 50,
	
				createPseudo: markFunction,
	
				match: matchExpr,
	
				attrHandle: {},
	
				find: {},
	
				relative: {
					">": { dir: "parentNode", first: true },
					" ": { dir: "parentNode" },
					"+": { dir: "previousSibling", first: true },
					"~": { dir: "previousSibling" }
				},
	
				preFilter: {
					"ATTR": function ATTR(match) {
						match[1] = match[1].replace(runescape, funescape);
	
						// Move the given value to match[3] whether quoted or unquoted
						match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
	
						if (match[2] === "~=") {
							match[3] = " " + match[3] + " ";
						}
	
						return match.slice(0, 4);
					},
	
					"CHILD": function CHILD(match) {
						/* matches from matchExpr["CHILD"]
	     	1 type (only|nth|...)
	     	2 what (child|of-type)
	     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
	     	4 xn-component of xn+y argument ([+-]?\d*n|)
	     	5 sign of xn-component
	     	6 x of xn-component
	     	7 sign of y-component
	     	8 y of y-component
	     */
						match[1] = match[1].toLowerCase();
	
						if (match[1].slice(0, 3) === "nth") {
							// nth-* requires argument
							if (!match[3]) {
								Sizzle.error(match[0]);
							}
	
							// numeric x and y parameters for Expr.filter.CHILD
							// remember that false/true cast respectively to 0/1
							match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
							match[5] = +(match[7] + match[8] || match[3] === "odd");
	
							// other types prohibit arguments
						} else if (match[3]) {
							Sizzle.error(match[0]);
						}
	
						return match;
					},
	
					"PSEUDO": function PSEUDO(match) {
						var excess,
						    unquoted = !match[6] && match[2];
	
						if (matchExpr["CHILD"].test(match[0])) {
							return null;
						}
	
						// Accept quoted arguments as-is
						if (match[3]) {
							match[2] = match[4] || match[5] || "";
	
							// Strip excess characters from unquoted arguments
						} else if (unquoted && rpseudo.test(unquoted) && (
						// Get excess from tokenize (recursively)
						excess = tokenize(unquoted, true)) && (
						// advance to the next closing parenthesis
						excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
	
							// excess is a negative index
							match[0] = match[0].slice(0, excess);
							match[2] = unquoted.slice(0, excess);
						}
	
						// Return only captures needed by the pseudo filter method (type and argument)
						return match.slice(0, 3);
					}
				},
	
				filter: {
	
					"TAG": function TAG(nodeNameSelector) {
						var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
						return nodeNameSelector === "*" ? function () {
							return true;
						} : function (elem) {
							return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
						};
					},
	
					"CLASS": function CLASS(className) {
						var pattern = classCache[className + " "];
	
						return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
							return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
						});
					},
	
					"ATTR": function ATTR(name, operator, check) {
						return function (elem) {
							var result = Sizzle.attr(elem, name);
	
							if (result == null) {
								return operator === "!=";
							}
							if (!operator) {
								return true;
							}
	
							result += "";
	
							return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
						};
					},
	
					"CHILD": function CHILD(type, what, argument, first, last) {
						var simple = type.slice(0, 3) !== "nth",
						    forward = type.slice(-4) !== "last",
						    ofType = what === "of-type";
	
						return first === 1 && last === 0 ?
	
						// Shortcut for :nth-*(n)
						function (elem) {
							return !!elem.parentNode;
						} : function (elem, context, xml) {
							var cache,
							    uniqueCache,
							    outerCache,
							    node,
							    nodeIndex,
							    start,
							    dir = simple !== forward ? "nextSibling" : "previousSibling",
							    parent = elem.parentNode,
							    name = ofType && elem.nodeName.toLowerCase(),
							    useCache = !xml && !ofType,
							    diff = false;
	
							if (parent) {
	
								// :(first|last|only)-(child|of-type)
								if (simple) {
									while (dir) {
										node = elem;
										while (node = node[dir]) {
											if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
	
												return false;
											}
										}
										// Reverse direction for :only-* (if we haven't yet done so)
										start = dir = type === "only" && !start && "nextSibling";
									}
									return true;
								}
	
								start = [forward ? parent.firstChild : parent.lastChild];
	
								// non-xml :nth-child(...) stores cache data on `parent`
								if (forward && useCache) {
	
									// Seek `elem` from a previously-cached index
	
									// ...in a gzip-friendly way
									node = parent;
									outerCache = node[expando] || (node[expando] = {});
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	
									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex && cache[2];
									node = nodeIndex && parent.childNodes[nodeIndex];
	
									while (node = ++nodeIndex && node && node[dir] || (
	
									// Fallback to seeking `elem` from the start
									diff = nodeIndex = 0) || start.pop()) {
	
										// When found, cache indexes on `parent` and break
										if (node.nodeType === 1 && ++diff && node === elem) {
											uniqueCache[type] = [dirruns, nodeIndex, diff];
											break;
										}
									}
								} else {
									// Use previously-cached element index if available
									if (useCache) {
										// ...in a gzip-friendly way
										node = elem;
										outerCache = node[expando] || (node[expando] = {});
	
										// Support: IE <9 only
										// Defend against cloned attroperties (jQuery gh-1709)
										uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	
										cache = uniqueCache[type] || [];
										nodeIndex = cache[0] === dirruns && cache[1];
										diff = nodeIndex;
									}
	
									// xml :nth-child(...)
									// or :nth-last-child(...) or :nth(-last)?-of-type(...)
									if (diff === false) {
										// Use the same loop as above to seek `elem` from the start
										while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
	
											if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
	
												// Cache the index of each encountered element
												if (useCache) {
													outerCache = node[expando] || (node[expando] = {});
	
													// Support: IE <9 only
													// Defend against cloned attroperties (jQuery gh-1709)
													uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
	
													uniqueCache[type] = [dirruns, diff];
												}
	
												if (node === elem) {
													break;
												}
											}
										}
									}
								}
	
								// Incorporate the offset, then check against cycle size
								diff -= last;
								return diff === first || diff % first === 0 && diff / first >= 0;
							}
						};
					},
	
					"PSEUDO": function PSEUDO(pseudo, argument) {
						// pseudo-class names are case-insensitive
						// http://www.w3.org/TR/selectors/#pseudo-classes
						// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
						// Remember that setFilters inherits from pseudos
						var args,
						    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
	
						// The user may use createPseudo to indicate that
						// arguments are needed to create the filter function
						// just as Sizzle does
						if (fn[expando]) {
							return fn(argument);
						}
	
						// But maintain support for old signatures
						if (fn.length > 1) {
							args = [pseudo, pseudo, "", argument];
							return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
								var idx,
								    matched = fn(seed, argument),
								    i = matched.length;
								while (i--) {
									idx = indexOf(seed, matched[i]);
									seed[idx] = !(matches[idx] = matched[i]);
								}
							}) : function (elem) {
								return fn(elem, 0, args);
							};
						}
	
						return fn;
					}
				},
	
				pseudos: {
					// Potentially complex pseudos
					"not": markFunction(function (selector) {
						// Trim the selector passed to compile
						// to avoid treating leading and trailing
						// spaces as combinators
						var input = [],
						    results = [],
						    matcher = compile(selector.replace(rtrim, "$1"));
	
						return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
							var elem,
							    unmatched = matcher(seed, null, xml, []),
							    i = seed.length;
	
							// Match elements unmatched by `matcher`
							while (i--) {
								if (elem = unmatched[i]) {
									seed[i] = !(matches[i] = elem);
								}
							}
						}) : function (elem, context, xml) {
							input[0] = elem;
							matcher(input, null, xml, results);
							// Don't keep the element (issue #299)
							input[0] = null;
							return !results.pop();
						};
					}),
	
					"has": markFunction(function (selector) {
						return function (elem) {
							return Sizzle(selector, elem).length > 0;
						};
					}),
	
					"contains": markFunction(function (text) {
						text = text.replace(runescape, funescape);
						return function (elem) {
							return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
						};
					}),
	
					// "Whether an element is represented by a :lang() selector
					// is based solely on the element's language value
					// being equal to the identifier C,
					// or beginning with the identifier C immediately followed by "-".
					// The matching of C against the element's language value is performed case-insensitively.
					// The identifier C does not have to be a valid language name."
					// http://www.w3.org/TR/selectors/#lang-pseudo
					"lang": markFunction(function (lang) {
						// lang value must be a valid identifier
						if (!ridentifier.test(lang || "")) {
							Sizzle.error("unsupported lang: " + lang);
						}
						lang = lang.replace(runescape, funescape).toLowerCase();
						return function (elem) {
							var elemLang;
							do {
								if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
	
									elemLang = elemLang.toLowerCase();
									return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
								}
							} while ((elem = elem.parentNode) && elem.nodeType === 1);
							return false;
						};
					}),
	
					// Miscellaneous
					"target": function target(elem) {
						var hash = window.location && window.location.hash;
						return hash && hash.slice(1) === elem.id;
					},
	
					"root": function root(elem) {
						return elem === docElem;
					},
	
					"focus": function focus(elem) {
						return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
					},
	
					// Boolean properties
					"enabled": function enabled(elem) {
						return elem.disabled === false;
					},
	
					"disabled": function disabled(elem) {
						return elem.disabled === true;
					},
	
					"checked": function checked(elem) {
						// In CSS3, :checked should return both checked and selected elements
						// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
						var nodeName = elem.nodeName.toLowerCase();
						return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
					},
	
					"selected": function selected(elem) {
						// Accessing this property makes selected-by-default
						// options in Safari work properly
						if (elem.parentNode) {
							elem.parentNode.selectedIndex;
						}
	
						return elem.selected === true;
					},
	
					// Contents
					"empty": function empty(elem) {
						// http://www.w3.org/TR/selectors/#empty-pseudo
						// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
						//   but not by others (comment: 8; processing instruction: 7; etc.)
						// nodeType < 6 works because attributes (2) do not appear as children
						for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
							if (elem.nodeType < 6) {
								return false;
							}
						}
						return true;
					},
	
					"parent": function parent(elem) {
						return !Expr.pseudos["empty"](elem);
					},
	
					// Element/input types
					"header": function header(elem) {
						return rheader.test(elem.nodeName);
					},
	
					"input": function input(elem) {
						return rinputs.test(elem.nodeName);
					},
	
					"button": function button(elem) {
						var name = elem.nodeName.toLowerCase();
						return name === "input" && elem.type === "button" || name === "button";
					},
	
					"text": function text(elem) {
						var attr;
						return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (
	
						// Support: IE<8
						// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
						(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
					},
	
					// Position-in-collection
					"first": createPositionalPseudo(function () {
						return [0];
					}),
	
					"last": createPositionalPseudo(function (matchIndexes, length) {
						return [length - 1];
					}),
	
					"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
						return [argument < 0 ? argument + length : argument];
					}),
	
					"even": createPositionalPseudo(function (matchIndexes, length) {
						var i = 0;
						for (; i < length; i += 2) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					}),
	
					"odd": createPositionalPseudo(function (matchIndexes, length) {
						var i = 1;
						for (; i < length; i += 2) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					}),
	
					"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
						var i = argument < 0 ? argument + length : argument;
						for (; --i >= 0;) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					}),
	
					"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
						var i = argument < 0 ? argument + length : argument;
						for (; ++i < length;) {
							matchIndexes.push(i);
						}
						return matchIndexes;
					})
				}
			};
	
			Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
			// Add button/input type pseudos
			for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
				Expr.pseudos[i] = createInputPseudo(i);
			}
			for (i in { submit: true, reset: true }) {
				Expr.pseudos[i] = createButtonPseudo(i);
			}
	
			// Easy API for creating new setFilters
			function setFilters() {}
			setFilters.prototype = Expr.filters = Expr.pseudos;
			Expr.setFilters = new setFilters();
	
			tokenize = Sizzle.tokenize = function (selector, parseOnly) {
				var matched,
				    match,
				    tokens,
				    type,
				    soFar,
				    groups,
				    preFilters,
				    cached = tokenCache[selector + " "];
	
				if (cached) {
					return parseOnly ? 0 : cached.slice(0);
				}
	
				soFar = selector;
				groups = [];
				preFilters = Expr.preFilter;
	
				while (soFar) {
	
					// Comma and first run
					if (!matched || (match = rcomma.exec(soFar))) {
						if (match) {
							// Don't consume trailing commas as valid
							soFar = soFar.slice(match[0].length) || soFar;
						}
						groups.push(tokens = []);
					}
	
					matched = false;
	
					// Combinators
					if (match = rcombinators.exec(soFar)) {
						matched = match.shift();
						tokens.push({
							value: matched,
							// Cast descendant combinators to space
							type: match[0].replace(rtrim, " ")
						});
						soFar = soFar.slice(matched.length);
					}
	
					// Filters
					for (type in Expr.filter) {
						if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
							matched = match.shift();
							tokens.push({
								value: matched,
								type: type,
								matches: match
							});
							soFar = soFar.slice(matched.length);
						}
					}
	
					if (!matched) {
						break;
					}
				}
	
				// Return the length of the invalid excess
				// if we're just parsing
				// Otherwise, throw an error or return tokens
				return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
				// Cache the tokens
				tokenCache(selector, groups).slice(0);
			};
	
			function toSelector(tokens) {
				var i = 0,
				    len = tokens.length,
				    selector = "";
				for (; i < len; i++) {
					selector += tokens[i].value;
				}
				return selector;
			}
	
			function addCombinator(matcher, combinator, base) {
				var dir = combinator.dir,
				    checkNonElements = base && dir === "parentNode",
				    doneName = done++;
	
				return combinator.first ?
				// Check against closest ancestor/preceding element
				function (elem, context, xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							return matcher(elem, context, xml);
						}
					}
				} :
	
				// Check against all ancestor/preceding elements
				function (elem, context, xml) {
					var oldCache,
					    uniqueCache,
					    outerCache,
					    newCache = [dirruns, doneName];
	
					// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
					if (xml) {
						while (elem = elem[dir]) {
							if (elem.nodeType === 1 || checkNonElements) {
								if (matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					} else {
						while (elem = elem[dir]) {
							if (elem.nodeType === 1 || checkNonElements) {
								outerCache = elem[expando] || (elem[expando] = {});
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
	
								if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
	
									// Assign to newCache so results back-propagate to previous elements
									return newCache[2] = oldCache[2];
								} else {
									// Reuse newcache so results back-propagate to previous elements
									uniqueCache[dir] = newCache;
	
									// A match means we're done; a fail means we have to keep checking
									if (newCache[2] = matcher(elem, context, xml)) {
										return true;
									}
								}
							}
						}
					}
				};
			}
	
			function elementMatcher(matchers) {
				return matchers.length > 1 ? function (elem, context, xml) {
					var i = matchers.length;
					while (i--) {
						if (!matchers[i](elem, context, xml)) {
							return false;
						}
					}
					return true;
				} : matchers[0];
			}
	
			function multipleContexts(selector, contexts, results) {
				var i = 0,
				    len = contexts.length;
				for (; i < len; i++) {
					Sizzle(selector, contexts[i], results);
				}
				return results;
			}
	
			function condense(unmatched, map, filter, context, xml) {
				var elem,
				    newUnmatched = [],
				    i = 0,
				    len = unmatched.length,
				    mapped = map != null;
	
				for (; i < len; i++) {
					if (elem = unmatched[i]) {
						if (!filter || filter(elem, context, xml)) {
							newUnmatched.push(elem);
							if (mapped) {
								map.push(i);
							}
						}
					}
				}
	
				return newUnmatched;
			}
	
			function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
				if (postFilter && !postFilter[expando]) {
					postFilter = setMatcher(postFilter);
				}
				if (postFinder && !postFinder[expando]) {
					postFinder = setMatcher(postFinder, postSelector);
				}
				return markFunction(function (seed, results, context, xml) {
					var temp,
					    i,
					    elem,
					    preMap = [],
					    postMap = [],
					    preexisting = results.length,
	
	
					// Get initial elements from seed or context
					elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
	
	
					// Prefilter to get matcher input, preserving a map for seed-results synchronization
					matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
					    matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || (seed ? preFilter : preexisting || postFilter) ?
	
					// ...intermediate processing is necessary
					[] :
	
					// ...otherwise use results directly
					results : matcherIn;
	
					// Find primary matches
					if (matcher) {
						matcher(matcherIn, matcherOut, context, xml);
					}
	
					// Apply postFilter
					if (postFilter) {
						temp = condense(matcherOut, postMap);
						postFilter(temp, [], context, xml);
	
						// Un-match failing elements by moving them back to matcherIn
						i = temp.length;
						while (i--) {
							if (elem = temp[i]) {
								matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
							}
						}
					}
	
					if (seed) {
						if (postFinder || preFilter) {
							if (postFinder) {
								// Get the final matcherOut by condensing this intermediate into postFinder contexts
								temp = [];
								i = matcherOut.length;
								while (i--) {
									if (elem = matcherOut[i]) {
										// Restore matcherIn since elem is not yet a final match
										temp.push(matcherIn[i] = elem);
									}
								}
								postFinder(null, matcherOut = [], temp, xml);
							}
	
							// Move matched elements from seed to results to keep them synchronized
							i = matcherOut.length;
							while (i--) {
								if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
	
									seed[temp] = !(results[temp] = elem);
								}
							}
						}
	
						// Add elements to results, through postFinder if defined
					} else {
						matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
						if (postFinder) {
							postFinder(null, results, matcherOut, xml);
						} else {
							push.apply(results, matcherOut);
						}
					}
				});
			}
	
			function matcherFromTokens(tokens) {
				var checkContext,
				    matcher,
				    j,
				    len = tokens.length,
				    leadingRelative = Expr.relative[tokens[0].type],
				    implicitRelative = leadingRelative || Expr.relative[" "],
				    i = leadingRelative ? 1 : 0,
	
	
				// The foundational matcher ensures that elements are reachable from top-level context(s)
				matchContext = addCombinator(function (elem) {
					return elem === checkContext;
				}, implicitRelative, true),
				    matchAnyContext = addCombinator(function (elem) {
					return indexOf(checkContext, elem) > -1;
				}, implicitRelative, true),
				    matchers = [function (elem, context, xml) {
					var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
					// Avoid hanging onto element (issue #299)
					checkContext = null;
					return ret;
				}];
	
				for (; i < len; i++) {
					if (matcher = Expr.relative[tokens[i].type]) {
						matchers = [addCombinator(elementMatcher(matchers), matcher)];
					} else {
						matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
	
						// Return special upon seeing a positional matcher
						if (matcher[expando]) {
							// Find the next relative operator (if any) for proper handling
							j = ++i;
							for (; j < len; j++) {
								if (Expr.relative[tokens[j].type]) {
									break;
								}
							}
							return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
						}
						matchers.push(matcher);
					}
				}
	
				return elementMatcher(matchers);
			}
	
			function matcherFromGroupMatchers(elementMatchers, setMatchers) {
				var bySet = setMatchers.length > 0,
				    byElement = elementMatchers.length > 0,
				    superMatcher = function superMatcher(seed, context, xml, results, outermost) {
					var elem,
					    j,
					    matcher,
					    matchedCount = 0,
					    i = "0",
					    unmatched = seed && [],
					    setMatched = [],
					    contextBackup = outermostContext,
	
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]("*", outermost),
	
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
					    len = elems.length;
	
					if (outermost) {
						outermostContext = context === document || context || outermost;
					}
	
					// Add elements passing elementMatchers directly to results
					// Support: IE<9, Safari
					// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
					for (; i !== len && (elem = elems[i]) != null; i++) {
						if (byElement && elem) {
							j = 0;
							if (!context && elem.ownerDocument !== document) {
								setDocument(elem);
								xml = !documentIsHTML;
							}
							while (matcher = elementMatchers[j++]) {
								if (matcher(elem, context || document, xml)) {
									results.push(elem);
									break;
								}
							}
							if (outermost) {
								dirruns = dirrunsUnique;
							}
						}
	
						// Track unmatched elements for set filters
						if (bySet) {
							// They will have gone through all possible matchers
							if (elem = !matcher && elem) {
								matchedCount--;
							}
	
							// Lengthen the array for every element, matched or not
							if (seed) {
								unmatched.push(elem);
							}
						}
					}
	
					// `i` is now the count of elements visited above, and adding it to `matchedCount`
					// makes the latter nonnegative.
					matchedCount += i;
	
					// Apply set filters to unmatched elements
					// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
					// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
					// no element matchers and no seed.
					// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
					// case, which will result in a "00" `matchedCount` that differs from `i` but is also
					// numerically zero.
					if (bySet && i !== matchedCount) {
						j = 0;
						while (matcher = setMatchers[j++]) {
							matcher(unmatched, setMatched, context, xml);
						}
	
						if (seed) {
							// Reintegrate element matches to eliminate the need for sorting
							if (matchedCount > 0) {
								while (i--) {
									if (!(unmatched[i] || setMatched[i])) {
										setMatched[i] = pop.call(results);
									}
								}
							}
	
							// Discard index placeholder values to get only actual matches
							setMatched = condense(setMatched);
						}
	
						// Add matches to results
						push.apply(results, setMatched);
	
						// Seedless set matches succeeding multiple successful matchers stipulate sorting
						if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
	
							Sizzle.uniqueSort(results);
						}
					}
	
					// Override manipulation of globals by nested matchers
					if (outermost) {
						dirruns = dirrunsUnique;
						outermostContext = contextBackup;
					}
	
					return unmatched;
				};
	
				return bySet ? markFunction(superMatcher) : superMatcher;
			}
	
			compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
				var i,
				    setMatchers = [],
				    elementMatchers = [],
				    cached = compilerCache[selector + " "];
	
				if (!cached) {
					// Generate a function of recursive functions that can be used to check each element
					if (!match) {
						match = tokenize(selector);
					}
					i = match.length;
					while (i--) {
						cached = matcherFromTokens(match[i]);
						if (cached[expando]) {
							setMatchers.push(cached);
						} else {
							elementMatchers.push(cached);
						}
					}
	
					// Cache the compiled function
					cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
	
					// Save selector and tokenization
					cached.selector = selector;
				}
				return cached;
			};
	
			/**
	   * A low-level selection function that works with Sizzle's compiled
	   *  selector functions
	   * @param {String|Function} selector A selector or a pre-compiled
	   *  selector function built with Sizzle.compile
	   * @param {Element} context
	   * @param {Array} [results]
	   * @param {Array} [seed] A set of elements to match against
	   */
			select = Sizzle.select = function (selector, context, results, seed) {
				var i,
				    tokens,
				    token,
				    type,
				    find,
				    compiled = typeof selector === "function" && selector,
				    match = !seed && tokenize(selector = compiled.selector || selector);
	
				results = results || [];
	
				// Try to minimize operations if there is only one selector in the list and no seed
				// (the latter of which guarantees us context)
				if (match.length === 1) {
	
					// Reduce context if the leading compound selector is an ID
					tokens = match[0] = match[0].slice(0);
					if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
	
						context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
						if (!context) {
							return results;
	
							// Precompiled matchers will still verify ancestry, so step up a level
						} else if (compiled) {
							context = context.parentNode;
						}
	
						selector = selector.slice(tokens.shift().value.length);
					}
	
					// Fetch a seed set for right-to-left matching
					i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
					while (i--) {
						token = tokens[i];
	
						// Abort if we hit a combinator
						if (Expr.relative[type = token.type]) {
							break;
						}
						if (find = Expr.find[type]) {
							// Search, expanding context for leading sibling combinators
							if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
	
								// If seed is empty or no tokens remain, we can return early
								tokens.splice(i, 1);
								selector = seed.length && toSelector(tokens);
								if (!selector) {
									push.apply(results, seed);
									return results;
								}
	
								break;
							}
						}
					}
				}
	
				// Compile and execute a filtering function if one is not provided
				// Provide `match` to avoid retokenization if we modified the selector above
				(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
				return results;
			};
	
			// One-time assignments
	
			// Sort stability
			support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
	
			// Support: Chrome 14-35+
			// Always assume duplicates if they aren't passed to the comparison function
			support.detectDuplicates = !!hasDuplicate;
	
			// Initialize against the default document
			setDocument();
	
			// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
			// Detached nodes confoundingly follow *each other*
			support.sortDetached = assert(function (div1) {
				// Should return 1, but returns 4 (following)
				return div1.compareDocumentPosition(document.createElement("div")) & 1;
			});
	
			// Support: IE<8
			// Prevent attribute/property "interpolation"
			// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
			if (!assert(function (div) {
				div.innerHTML = "<a href='#'></a>";
				return div.firstChild.getAttribute("href") === "#";
			})) {
				addHandle("type|href|height|width", function (elem, name, isXML) {
					if (!isXML) {
						return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
					}
				});
			}
	
			// Support: IE<9
			// Use defaultValue in place of getAttribute("value")
			if (!support.attributes || !assert(function (div) {
				div.innerHTML = "<input/>";
				div.firstChild.setAttribute("value", "");
				return div.firstChild.getAttribute("value") === "";
			})) {
				addHandle("value", function (elem, name, isXML) {
					if (!isXML && elem.nodeName.toLowerCase() === "input") {
						return elem.defaultValue;
					}
				});
			}
	
			// Support: IE<9
			// Use getAttributeNode to fetch booleans when getAttribute lies
			if (!assert(function (div) {
				return div.getAttribute("disabled") == null;
			})) {
				addHandle(booleans, function (elem, name, isXML) {
					var val;
					if (!isXML) {
						return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
					}
				});
			}
	
			return Sizzle;
		}(window);
	
		jQuery.find = Sizzle;
		jQuery.expr = Sizzle.selectors;
		jQuery.expr[":"] = jQuery.expr.pseudos;
		jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
		jQuery.text = Sizzle.getText;
		jQuery.isXMLDoc = Sizzle.isXML;
		jQuery.contains = Sizzle.contains;
	
		var dir = function dir(elem, _dir, until) {
			var matched = [],
			    truncate = until !== undefined;
	
			while ((elem = elem[_dir]) && elem.nodeType !== 9) {
				if (elem.nodeType === 1) {
					if (truncate && jQuery(elem).is(until)) {
						break;
					}
					matched.push(elem);
				}
			}
			return matched;
		};
	
		var _siblings = function _siblings(n, elem) {
			var matched = [];
	
			for (; n; n = n.nextSibling) {
				if (n.nodeType === 1 && n !== elem) {
					matched.push(n);
				}
			}
	
			return matched;
		};
	
		var rneedsContext = jQuery.expr.match.needsContext;
	
		var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
	
		var risSimple = /^.[^:#\[\.,]*$/;
	
		// Implement the identical functionality for filter and not
		function winnow(elements, qualifier, not) {
			if (jQuery.isFunction(qualifier)) {
				return jQuery.grep(elements, function (elem, i) {
					/* jshint -W018 */
					return !!qualifier.call(elem, i, elem) !== not;
				});
			}
	
			if (qualifier.nodeType) {
				return jQuery.grep(elements, function (elem) {
					return elem === qualifier !== not;
				});
			}
	
			if (typeof qualifier === "string") {
				if (risSimple.test(qualifier)) {
					return jQuery.filter(qualifier, elements, not);
				}
	
				qualifier = jQuery.filter(qualifier, elements);
			}
	
			return jQuery.grep(elements, function (elem) {
				return indexOf.call(qualifier, elem) > -1 !== not;
			});
		}
	
		jQuery.filter = function (expr, elems, not) {
			var elem = elems[0];
	
			if (not) {
				expr = ":not(" + expr + ")";
			}
	
			return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
				return elem.nodeType === 1;
			}));
		};
	
		jQuery.fn.extend({
			find: function find(selector) {
				var i,
				    len = this.length,
				    ret = [],
				    self = this;
	
				if (typeof selector !== "string") {
					return this.pushStack(jQuery(selector).filter(function () {
						for (i = 0; i < len; i++) {
							if (jQuery.contains(self[i], this)) {
								return true;
							}
						}
					}));
				}
	
				for (i = 0; i < len; i++) {
					jQuery.find(selector, self[i], ret);
				}
	
				// Needed because $( selector, context ) becomes $( context ).find( selector )
				ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
				ret.selector = this.selector ? this.selector + " " + selector : selector;
				return ret;
			},
			filter: function filter(selector) {
				return this.pushStack(winnow(this, selector || [], false));
			},
			not: function not(selector) {
				return this.pushStack(winnow(this, selector || [], true));
			},
			is: function is(selector) {
				return !!winnow(this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
			}
		});
	
		// Initialize a jQuery object
	
	
		// A central reference to the root jQuery(document)
		var rootjQuery,
	
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
		    init = jQuery.fn.init = function (selector, context, root) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if (!selector) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if (typeof selector === "string") {
				if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [null, selector, null];
				} else {
					match = rquickExpr.exec(selector);
				}
	
				// Match html or make sure no context is specified for #id
				if (match && (match[1] || !context)) {
	
					// HANDLE: $(html) -> $(array)
					if (match[1]) {
						context = context instanceof jQuery ? context[0] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
	
						// HANDLE: $(html, props)
						if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
							for (match in context) {
	
								// Properties of context are called as methods if possible
								if (jQuery.isFunction(this[match])) {
									this[match](context[match]);
	
									// ...and otherwise set as attributes
								} else {
									this.attr(match, context[match]);
								}
							}
						}
	
						return this;
	
						// HANDLE: $(#id)
					} else {
						elem = document.getElementById(match[2]);
	
						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if (elem && elem.parentNode) {
	
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}
	
						this.context = document;
						this.selector = selector;
						return this;
					}
	
					// HANDLE: $(expr, $(...))
				} else if (!context || context.jquery) {
					return (context || root).find(selector);
	
					// HANDLE: $(expr, context)
					// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor(context).find(selector);
				}
	
				// HANDLE: $(DOMElement)
			} else if (selector.nodeType) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;
	
				// HANDLE: $(function)
				// Shortcut for document ready
			} else if (jQuery.isFunction(selector)) {
				return root.ready !== undefined ? root.ready(selector) :
	
				// Execute immediately if ready is not present
				selector(jQuery);
			}
	
			if (selector.selector !== undefined) {
				this.selector = selector.selector;
				this.context = selector.context;
			}
	
			return jQuery.makeArray(selector, this);
		};
	
		// Give the init function the jQuery prototype for later instantiation
		init.prototype = jQuery.fn;
	
		// Initialize central reference
		rootjQuery = jQuery(document);
	
		var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
		jQuery.fn.extend({
			has: function has(target) {
				var targets = jQuery(target, this),
				    l = targets.length;
	
				return this.filter(function () {
					var i = 0;
					for (; i < l; i++) {
						if (jQuery.contains(this, targets[i])) {
							return true;
						}
					}
				});
			},
	
			closest: function closest(selectors, context) {
				var cur,
				    i = 0,
				    l = this.length,
				    matched = [],
				    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
	
				for (; i < l; i++) {
					for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
	
						// Always skip document fragments
						if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :
	
						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
	
							matched.push(cur);
							break;
						}
					}
				}
	
				return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
			},
	
			// Determine the position of an element within the set
			index: function index(elem) {
	
				// No argument, return index in parent
				if (!elem) {
					return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
				}
	
				// Index in selector
				if (typeof elem === "string") {
					return indexOf.call(jQuery(elem), this[0]);
				}
	
				// Locate the position of the desired element
				return indexOf.call(this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[0] : elem);
			},
	
			add: function add(selector, context) {
				return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
			},
	
			addBack: function addBack(selector) {
				return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
			}
		});
	
		function sibling(cur, dir) {
			while ((cur = cur[dir]) && cur.nodeType !== 1) {}
			return cur;
		}
	
		jQuery.each({
			parent: function parent(elem) {
				var parent = elem.parentNode;
				return parent && parent.nodeType !== 11 ? parent : null;
			},
			parents: function parents(elem) {
				return dir(elem, "parentNode");
			},
			parentsUntil: function parentsUntil(elem, i, until) {
				return dir(elem, "parentNode", until);
			},
			next: function next(elem) {
				return sibling(elem, "nextSibling");
			},
			prev: function prev(elem) {
				return sibling(elem, "previousSibling");
			},
			nextAll: function nextAll(elem) {
				return dir(elem, "nextSibling");
			},
			prevAll: function prevAll(elem) {
				return dir(elem, "previousSibling");
			},
			nextUntil: function nextUntil(elem, i, until) {
				return dir(elem, "nextSibling", until);
			},
			prevUntil: function prevUntil(elem, i, until) {
				return dir(elem, "previousSibling", until);
			},
			siblings: function siblings(elem) {
				return _siblings((elem.parentNode || {}).firstChild, elem);
			},
			children: function children(elem) {
				return _siblings(elem.firstChild);
			},
			contents: function contents(elem) {
				return elem.contentDocument || jQuery.merge([], elem.childNodes);
			}
		}, function (name, fn) {
			jQuery.fn[name] = function (until, selector) {
				var matched = jQuery.map(this, fn, until);
	
				if (name.slice(-5) !== "Until") {
					selector = until;
				}
	
				if (selector && typeof selector === "string") {
					matched = jQuery.filter(selector, matched);
				}
	
				if (this.length > 1) {
	
					// Remove duplicates
					if (!guaranteedUnique[name]) {
						jQuery.uniqueSort(matched);
					}
	
					// Reverse order for parents* and prev-derivatives
					if (rparentsprev.test(name)) {
						matched.reverse();
					}
				}
	
				return this.pushStack(matched);
			};
		});
		var rnotwhite = /\S+/g;
	
		// Convert String-formatted options into Object-formatted ones
		function createOptions(options) {
			var object = {};
			jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
				object[flag] = true;
			});
			return object;
		}
	
		/*
	  * Create a callback list using the following parameters:
	  *
	  *	options: an optional list of space-separated options that will change how
	  *			the callback list behaves or a more traditional option object
	  *
	  * By default a callback list will act like an event callback list and can be
	  * "fired" multiple times.
	  *
	  * Possible options:
	  *
	  *	once:			will ensure the callback list can only be fired once (like a Deferred)
	  *
	  *	memory:			will keep track of previous values and will call any callback added
	  *					after the list has been fired right away with the latest "memorized"
	  *					values (like a Deferred)
	  *
	  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	  *
	  *	stopOnFalse:	interrupt callings when a callback returns false
	  *
	  */
		jQuery.Callbacks = function (options) {
	
			// Convert options from String-formatted to Object-formatted if needed
			// (we check in cache first)
			options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
	
			var // Flag to know if list is currently firing
			firing,
	
	
			// Last fire value for non-forgettable lists
			memory,
	
	
			// Flag to know if list was already fired
			_fired,
	
	
			// Flag to prevent firing
			_locked,
	
	
			// Actual callback list
			list = [],
	
	
			// Queue of execution data for repeatable lists
			queue = [],
	
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
	
			// Fire callbacks
			fire = function fire() {
	
				// Enforce single-firing
				_locked = options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				_fired = firing = true;
				for (; queue.length; firingIndex = -1) {
					memory = queue.shift();
					while (++firingIndex < list.length) {
	
						// Run callback and check for early termination
						if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if (!options.memory) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if (_locked) {
	
					// Keep an empty list if we have data for future add calls
					if (memory) {
						list = [];
	
						// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function add() {
					if (list) {
	
						// If we have memory from a past run, we should fire after adding
						if (memory && !firing) {
							firingIndex = list.length - 1;
							queue.push(memory);
						}
	
						(function add(args) {
							jQuery.each(args, function (_, arg) {
								if (jQuery.isFunction(arg)) {
									if (!options.unique || !self.has(arg)) {
										list.push(arg);
									}
								} else if (arg && arg.length && jQuery.type(arg) !== "string") {
	
									// Inspect recursively
									add(arg);
								}
							});
						})(arguments);
	
						if (memory && !firing) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function remove() {
					jQuery.each(arguments, function (_, arg) {
						var index;
						while ((index = jQuery.inArray(arg, list, index)) > -1) {
							list.splice(index, 1);
	
							// Handle firing indexes
							if (index <= firingIndex) {
								firingIndex--;
							}
						}
					});
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function has(fn) {
					return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function empty() {
					if (list) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function disable() {
					_locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function disabled() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function lock() {
					_locked = queue = [];
					if (!memory) {
						list = memory = "";
					}
					return this;
				},
				locked: function locked() {
					return !!_locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function fireWith(context, args) {
					if (!_locked) {
						args = args || [];
						args = [context, args.slice ? args.slice() : args];
						queue.push(args);
						if (!firing) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function fire() {
					self.fireWith(this, arguments);
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function fired() {
					return !!_fired;
				}
			};
	
			return self;
		};
	
		jQuery.extend({
	
			Deferred: function Deferred(func) {
				var tuples = [
	
				// action, add listener, listener list, final state
				["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
				    _state = "pending",
				    _promise = {
					state: function state() {
						return _state;
					},
					always: function always() {
						deferred.done(arguments).fail(arguments);
						return this;
					},
					then: function then() /* fnDone, fnFail, fnProgress */{
						var fns = arguments;
						return jQuery.Deferred(function (newDefer) {
							jQuery.each(tuples, function (i, tuple) {
								var fn = jQuery.isFunction(fns[i]) && fns[i];
	
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[tuple[1]](function () {
									var returned = fn && fn.apply(this, arguments);
									if (returned && jQuery.isFunction(returned.promise)) {
										returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
									} else {
										newDefer[tuple[0] + "With"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);
									}
								});
							});
							fns = null;
						}).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function promise(obj) {
						return obj != null ? jQuery.extend(obj, _promise) : _promise;
					}
				},
				    deferred = {};
	
				// Keep pipe for back-compat
				_promise.pipe = _promise.then;
	
				// Add list-specific methods
				jQuery.each(tuples, function (i, tuple) {
					var list = tuple[2],
					    stateString = tuple[3];
	
					// promise[ done | fail | progress ] = list.add
					_promise[tuple[1]] = list.add;
	
					// Handle state
					if (stateString) {
						list.add(function () {
	
							// state = [ resolved | rejected ]
							_state = stateString;
	
							// [ reject_list | resolve_list ].disable; progress_list.lock
						}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
					}
	
					// deferred[ resolve | reject | notify ]
					deferred[tuple[0]] = function () {
						deferred[tuple[0] + "With"](this === deferred ? _promise : this, arguments);
						return this;
					};
					deferred[tuple[0] + "With"] = list.fireWith;
				});
	
				// Make the deferred a promise
				_promise.promise(deferred);
	
				// Call given func if any
				if (func) {
					func.call(deferred, deferred);
				}
	
				// All done!
				return deferred;
			},
	
			// Deferred helper
			when: function when(subordinate /* , ..., subordinateN */) {
				var i = 0,
				    resolveValues = _slice.call(arguments),
				    length = resolveValues.length,
	
	
				// the count of uncompleted subordinates
				remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
	
	
				// the master Deferred.
				// If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
	
	
				// Update function for both resolve and progress values
				updateFunc = function updateFunc(i, contexts, values) {
					return function (value) {
						contexts[i] = this;
						values[i] = arguments.length > 1 ? _slice.call(arguments) : value;
						if (values === progressValues) {
							deferred.notifyWith(contexts, values);
						} else if (! --remaining) {
							deferred.resolveWith(contexts, values);
						}
					};
				},
				    progressValues,
				    progressContexts,
				    resolveContexts;
	
				// Add listeners to Deferred subordinates; treat others as resolved
				if (length > 1) {
					progressValues = new Array(length);
					progressContexts = new Array(length);
					resolveContexts = new Array(length);
					for (; i < length; i++) {
						if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
							resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
						} else {
							--remaining;
						}
					}
				}
	
				// If we're not waiting on anything, resolve the master
				if (!remaining) {
					deferred.resolveWith(resolveContexts, resolveValues);
				}
	
				return deferred.promise();
			}
		});
	
		// The deferred used on DOM ready
		var readyList;
	
		jQuery.fn.ready = function (fn) {
	
			// Add the callback
			jQuery.ready.promise().done(fn);
	
			return this;
		};
	
		jQuery.extend({
	
			// Is the DOM ready to be used? Set to true once it occurs.
			isReady: false,
	
			// A counter to track how many items to wait for before
			// the ready event fires. See #6781
			readyWait: 1,
	
			// Hold (or release) the ready event
			holdReady: function holdReady(hold) {
				if (hold) {
					jQuery.readyWait++;
				} else {
					jQuery.ready(true);
				}
			},
	
			// Handle when the DOM is ready
			ready: function ready(wait) {
	
				// Abort if there are pending holds or we're already ready
				if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
					return;
				}
	
				// Remember that the DOM is ready
				jQuery.isReady = true;
	
				// If a normal DOM Ready event fired, decrement, and wait if need be
				if (wait !== true && --jQuery.readyWait > 0) {
					return;
				}
	
				// If there are functions bound, to execute
				readyList.resolveWith(document, [jQuery]);
	
				// Trigger any bound ready events
				if (jQuery.fn.triggerHandler) {
					jQuery(document).triggerHandler("ready");
					jQuery(document).off("ready");
				}
			}
		});
	
		/**
	  * The ready event handler and self cleanup method
	  */
		function completed() {
			document.removeEventListener("DOMContentLoaded", completed);
			window.removeEventListener("load", completed);
			jQuery.ready();
		}
	
		jQuery.ready.promise = function (obj) {
			if (!readyList) {
	
				readyList = jQuery.Deferred();
	
				// Catch cases where $(document).ready() is called
				// after the browser event has already occurred.
				// Support: IE9-10 only
				// Older IE sometimes signals "interactive" too soon
				if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
	
					// Handle it asynchronously to allow scripts the opportunity to delay ready
					window.setTimeout(jQuery.ready);
				} else {
	
					// Use the handy event callback
					document.addEventListener("DOMContentLoaded", completed);
	
					// A fallback to window.onload, that will always work
					window.addEventListener("load", completed);
				}
			}
			return readyList.promise(obj);
		};
	
		// Kick off the DOM ready check even if the user does not
		jQuery.ready.promise();
	
		// Multifunctional method to get and set values of a collection
		// The value/s can optionally be executed if it's a function
		var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
			var i = 0,
			    len = elems.length,
			    bulk = key == null;
	
			// Sets many values
			if (jQuery.type(key) === "object") {
				chainable = true;
				for (i in key) {
					access(elems, fn, i, key[i], true, emptyGet, raw);
				}
	
				// Sets one value
			} else if (value !== undefined) {
				chainable = true;
	
				if (!jQuery.isFunction(value)) {
					raw = true;
				}
	
				if (bulk) {
	
					// Bulk operations run against the entire set
					if (raw) {
						fn.call(elems, value);
						fn = null;
	
						// ...except when executing function values
					} else {
						bulk = fn;
						fn = function fn(elem, key, value) {
							return bulk.call(jQuery(elem), value);
						};
					}
				}
	
				if (fn) {
					for (; i < len; i++) {
						fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
					}
				}
			}
	
			return chainable ? elems :
	
			// Gets
			bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
		};
		var acceptData = function acceptData(owner) {
	
			// Accepts only:
			//  - Node
			//    - Node.ELEMENT_NODE
			//    - Node.DOCUMENT_NODE
			//  - Object
			//    - Any
			/* jshint -W018 */
			return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
		};
	
		function Data() {
			this.expando = jQuery.expando + Data.uid++;
		}
	
		Data.uid = 1;
	
		Data.prototype = {
	
			register: function register(owner, initial) {
				var value = initial || {};
	
				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if (owner.nodeType) {
					owner[this.expando] = value;
	
					// Otherwise secure it in a non-enumerable, non-writable property
					// configurability must be true to allow the property to be
					// deleted with the delete operator
				} else {
					Object.defineProperty(owner, this.expando, {
						value: value,
						writable: true,
						configurable: true
					});
				}
				return owner[this.expando];
			},
			cache: function cache(owner) {
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (!acceptData(owner)) {
					return {};
				}
	
				// Check if the owner object already has a cache
				var value = owner[this.expando];
	
				// If not, create one
				if (!value) {
					value = {};
	
					// We can accept data for non-element nodes in modern browsers,
					// but we should not, see #8335.
					// Always return an empty object.
					if (acceptData(owner)) {
	
						// If it is a node unlikely to be stringify-ed or looped over
						// use plain assignment
						if (owner.nodeType) {
							owner[this.expando] = value;
	
							// Otherwise secure it in a non-enumerable property
							// configurable must be true to allow the property to be
							// deleted when data is removed
						} else {
							Object.defineProperty(owner, this.expando, {
								value: value,
								configurable: true
							});
						}
					}
				}
	
				return value;
			},
			set: function set(owner, data, value) {
				var prop,
				    cache = this.cache(owner);
	
				// Handle: [ owner, key, value ] args
				if (typeof data === "string") {
					cache[data] = value;
	
					// Handle: [ owner, { properties } ] args
				} else {
	
					// Copy the properties one-by-one to the cache object
					for (prop in data) {
						cache[prop] = data[prop];
					}
				}
				return cache;
			},
			get: function get(owner, key) {
				return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
			},
			access: function access(owner, key, value) {
				var stored;
	
				// In cases where either:
				//
				//   1. No key was specified
				//   2. A string key was specified, but no value provided
				//
				// Take the "read" path and allow the get method to determine
				// which value to return, respectively either:
				//
				//   1. The entire cache object
				//   2. The data stored at the key
				//
				if (key === undefined || key && typeof key === "string" && value === undefined) {
	
					stored = this.get(owner, key);
	
					return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
				}
	
				// When the key is not a string, or both a key and value
				// are specified, set or extend (existing objects) with either:
				//
				//   1. An object of properties
				//   2. A key and value
				//
				this.set(owner, key, value);
	
				// Since the "set" path can have two possible entry points
				// return the expected data based on which path was taken[*]
				return value !== undefined ? value : key;
			},
			remove: function remove(owner, key) {
				var i,
				    name,
				    camel,
				    cache = owner[this.expando];
	
				if (cache === undefined) {
					return;
				}
	
				if (key === undefined) {
					this.register(owner);
				} else {
	
					// Support array or space separated string of keys
					if (jQuery.isArray(key)) {
	
						// If "name" is an array of keys...
						// When data is initially created, via ("key", "val") signature,
						// keys will be converted to camelCase.
						// Since there is no way to tell _how_ a key was added, remove
						// both plain key and camelCase key. #12786
						// This will only penalize the array argument path.
						name = key.concat(key.map(jQuery.camelCase));
					} else {
						camel = jQuery.camelCase(key);
	
						// Try the string as a key before any manipulation
						if (key in cache) {
							name = [key, camel];
						} else {
	
							// If a key with the spaces exists, use it.
							// Otherwise, create an array by matching non-whitespace
							name = camel;
							name = name in cache ? [name] : name.match(rnotwhite) || [];
						}
					}
	
					i = name.length;
	
					while (i--) {
						delete cache[name[i]];
					}
				}
	
				// Remove the expando if there's no more data
				if (key === undefined || jQuery.isEmptyObject(cache)) {
	
					// Support: Chrome <= 35-45+
					// Webkit & Blink performance suffers when deleting properties
					// from DOM nodes, so set to undefined instead
					// https://code.google.com/p/chromium/issues/detail?id=378607
					if (owner.nodeType) {
						owner[this.expando] = undefined;
					} else {
						delete owner[this.expando];
					}
				}
			},
			hasData: function hasData(owner) {
				var cache = owner[this.expando];
				return cache !== undefined && !jQuery.isEmptyObject(cache);
			}
		};
		var dataPriv = new Data();
	
		var dataUser = new Data();
	
		//	Implementation Summary
		//
		//	1. Enforce API surface and semantic compatibility with 1.9.x branch
		//	2. Improve the module's maintainability by reducing the storage
		//		paths to a single mechanism.
		//	3. Use the same single mechanism to support "private" and "user" data.
		//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
		//	5. Avoid exposing implementation details on user objects (eg. expando properties)
		//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
		var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		    rmultiDash = /[A-Z]/g;
	
		function dataAttr(elem, key, data) {
			var name;
	
			// If nothing was found internally, try to fetch any
			// data from the HTML5 data-* attribute
			if (data === undefined && elem.nodeType === 1) {
				name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
				data = elem.getAttribute(name);
	
				if (typeof data === "string") {
					try {
						data = data === "true" ? true : data === "false" ? false : data === "null" ? null :
	
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
					} catch (e) {}
	
					// Make sure we set the data so it isn't changed later
					dataUser.set(elem, key, data);
				} else {
					data = undefined;
				}
			}
			return data;
		}
	
		jQuery.extend({
			hasData: function hasData(elem) {
				return dataUser.hasData(elem) || dataPriv.hasData(elem);
			},
	
			data: function data(elem, name, _data) {
				return dataUser.access(elem, name, _data);
			},
	
			removeData: function removeData(elem, name) {
				dataUser.remove(elem, name);
			},
	
			// TODO: Now that all calls to _data and _removeData have been replaced
			// with direct calls to dataPriv methods, these can be deprecated.
			_data: function _data(elem, name, data) {
				return dataPriv.access(elem, name, data);
			},
	
			_removeData: function _removeData(elem, name) {
				dataPriv.remove(elem, name);
			}
		});
	
		jQuery.fn.extend({
			data: function data(key, value) {
				var i,
				    name,
				    data,
				    elem = this[0],
				    attrs = elem && elem.attributes;
	
				// Gets all values
				if (key === undefined) {
					if (this.length) {
						data = dataUser.get(elem);
	
						if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
							i = attrs.length;
							while (i--) {
	
								// Support: IE11+
								// The attrs elements can be null (#14894)
								if (attrs[i]) {
									name = attrs[i].name;
									if (name.indexOf("data-") === 0) {
										name = jQuery.camelCase(name.slice(5));
										dataAttr(elem, name, data[name]);
									}
								}
							}
							dataPriv.set(elem, "hasDataAttrs", true);
						}
					}
	
					return data;
				}
	
				// Sets multiple values
				if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
					return this.each(function () {
						dataUser.set(this, key);
					});
				}
	
				return access(this, function (value) {
					var data, camelKey;
	
					// The calling jQuery object (element matches) is not empty
					// (and therefore has an element appears at this[ 0 ]) and the
					// `value` parameter was not undefined. An empty jQuery object
					// will result in `undefined` for elem = this[ 0 ] which will
					// throw an exception if an attempt to read a data cache is made.
					if (elem && value === undefined) {
	
						// Attempt to get data from the cache
						// with the key as-is
						data = dataUser.get(elem, key) ||
	
						// Try to find dashed key if it exists (gh-2779)
						// This is for 2.2.x only
						dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
	
						if (data !== undefined) {
							return data;
						}
	
						camelKey = jQuery.camelCase(key);
	
						// Attempt to get data from the cache
						// with the key camelized
						data = dataUser.get(elem, camelKey);
						if (data !== undefined) {
							return data;
						}
	
						// Attempt to "discover" the data in
						// HTML5 custom data-* attrs
						data = dataAttr(elem, camelKey, undefined);
						if (data !== undefined) {
							return data;
						}
	
						// We tried really hard, but the data doesn't exist.
						return;
					}
	
					// Set the data...
					camelKey = jQuery.camelCase(key);
					this.each(function () {
	
						// First, attempt to store a copy or reference of any
						// data that might've been store with a camelCased key.
						var data = dataUser.get(this, camelKey);
	
						// For HTML5 data-* attribute interop, we have to
						// store property names with dashes in a camelCase form.
						// This might not apply to all properties...*
						dataUser.set(this, camelKey, value);
	
						// *... In the case of properties that might _actually_
						// have dashes, we need to also store a copy of that
						// unchanged property.
						if (key.indexOf("-") > -1 && data !== undefined) {
							dataUser.set(this, key, value);
						}
					});
				}, null, value, arguments.length > 1, null, true);
			},
	
			removeData: function removeData(key) {
				return this.each(function () {
					dataUser.remove(this, key);
				});
			}
		});
	
		jQuery.extend({
			queue: function queue(elem, type, data) {
				var queue;
	
				if (elem) {
					type = (type || "fx") + "queue";
					queue = dataPriv.get(elem, type);
	
					// Speed up dequeue by getting out quickly if this is just a lookup
					if (data) {
						if (!queue || jQuery.isArray(data)) {
							queue = dataPriv.access(elem, type, jQuery.makeArray(data));
						} else {
							queue.push(data);
						}
					}
					return queue || [];
				}
			},
	
			dequeue: function dequeue(elem, type) {
				type = type || "fx";
	
				var queue = jQuery.queue(elem, type),
				    startLength = queue.length,
				    fn = queue.shift(),
				    hooks = jQuery._queueHooks(elem, type),
				    next = function next() {
					jQuery.dequeue(elem, type);
				};
	
				// If the fx queue is dequeued, always remove the progress sentinel
				if (fn === "inprogress") {
					fn = queue.shift();
					startLength--;
				}
	
				if (fn) {
	
					// Add a progress sentinel to prevent the fx queue from being
					// automatically dequeued
					if (type === "fx") {
						queue.unshift("inprogress");
					}
	
					// Clear up the last queue stop function
					delete hooks.stop;
					fn.call(elem, next, hooks);
				}
	
				if (!startLength && hooks) {
					hooks.empty.fire();
				}
			},
	
			// Not public - generate a queueHooks object, or return the current one
			_queueHooks: function _queueHooks(elem, type) {
				var key = type + "queueHooks";
				return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
					empty: jQuery.Callbacks("once memory").add(function () {
						dataPriv.remove(elem, [type + "queue", key]);
					})
				});
			}
		});
	
		jQuery.fn.extend({
			queue: function queue(type, data) {
				var setter = 2;
	
				if (typeof type !== "string") {
					data = type;
					type = "fx";
					setter--;
				}
	
				if (arguments.length < setter) {
					return jQuery.queue(this[0], type);
				}
	
				return data === undefined ? this : this.each(function () {
					var queue = jQuery.queue(this, type, data);
	
					// Ensure a hooks for this queue
					jQuery._queueHooks(this, type);
	
					if (type === "fx" && queue[0] !== "inprogress") {
						jQuery.dequeue(this, type);
					}
				});
			},
			dequeue: function dequeue(type) {
				return this.each(function () {
					jQuery.dequeue(this, type);
				});
			},
			clearQueue: function clearQueue(type) {
				return this.queue(type || "fx", []);
			},
	
			// Get a promise resolved when queues of a certain type
			// are emptied (fx is the type by default)
			promise: function promise(type, obj) {
				var tmp,
				    count = 1,
				    defer = jQuery.Deferred(),
				    elements = this,
				    i = this.length,
				    resolve = function resolve() {
					if (! --count) {
						defer.resolveWith(elements, [elements]);
					}
				};
	
				if (typeof type !== "string") {
					obj = type;
					type = undefined;
				}
				type = type || "fx";
	
				while (i--) {
					tmp = dataPriv.get(elements[i], type + "queueHooks");
					if (tmp && tmp.empty) {
						count++;
						tmp.empty.add(resolve);
					}
				}
				resolve();
				return defer.promise(obj);
			}
		});
		var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
	
		var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
	
		var cssExpand = ["Top", "Right", "Bottom", "Left"];
	
		var isHidden = function isHidden(elem, el) {
	
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
		};
	
		function adjustCSS(elem, prop, valueParts, tween) {
			var adjusted,
			    scale = 1,
			    maxIterations = 20,
			    currentValue = tween ? function () {
				return tween.cur();
			} : function () {
				return jQuery.css(elem, prop, "");
			},
			    initial = currentValue(),
			    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
	
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
	
			if (initialInUnit && initialInUnit[3] !== unit) {
	
				// Trust units reported by jQuery.css
				unit = unit || initialInUnit[3];
	
				// Make sure we update the tween properties later on
				valueParts = valueParts || [];
	
				// Iteratively approximate from a nonzero starting point
				initialInUnit = +initial || 1;
	
				do {
	
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";
	
					// Adjust and apply
					initialInUnit = initialInUnit / scale;
					jQuery.style(elem, prop, initialInUnit + unit);
	
					// Update scale, tolerating zero or NaN from tween.cur()
					// Break the loop if scale is unchanged or perfect, or if we've just had enough.
				} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
			}
	
			if (valueParts) {
				initialInUnit = +initialInUnit || +initial || 0;
	
				// Apply relative offset (+=/-=) if specified
				adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
				if (tween) {
					tween.unit = unit;
					tween.start = initialInUnit;
					tween.end = adjusted;
				}
			}
			return adjusted;
		}
		var rcheckableType = /^(?:checkbox|radio)$/i;
	
		var rtagName = /<([\w:-]+)/;
	
		var rscriptType = /^$|\/(?:java|ecma)script/i;
	
		// We have to close these tags to support XHTML (#13200)
		var wrapMap = {
	
			// Support: IE9
			option: [1, "<select multiple='multiple'>", "</select>"],
	
			// XHTML parsers do not magically insert elements in the
			// same way that tag soup parsers do. So we cannot shorten
			// this by omitting <tbody> or other required elements.
			thead: [1, "<table>", "</table>"],
			col: [2, "<table><colgroup>", "</colgroup></table>"],
			tr: [2, "<table><tbody>", "</tbody></table>"],
			td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	
			_default: [0, "", ""]
		};
	
		// Support: IE9
		wrapMap.optgroup = wrapMap.option;
	
		wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
		wrapMap.th = wrapMap.td;
	
		function getAll(context, tag) {
	
			// Support: IE9-11+
			// Use typeof to avoid zero-argument method invocation on host objects (#15151)
			var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
	
			return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
		}
	
		// Mark scripts as having already been evaluated
		function setGlobalEval(elems, refElements) {
			var i = 0,
			    l = elems.length;
	
			for (; i < l; i++) {
				dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
			}
		}
	
		var rhtml = /<|&#?\w+;/;
	
		function buildFragment(elems, context, scripts, selection, ignored) {
			var elem,
			    tmp,
			    tag,
			    wrap,
			    contains,
			    j,
			    fragment = context.createDocumentFragment(),
			    nodes = [],
			    i = 0,
			    l = elems.length;
	
			for (; i < l; i++) {
				elem = elems[i];
	
				if (elem || elem === 0) {
	
					// Add nodes directly
					if (jQuery.type(elem) === "object") {
	
						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
	
						// Convert non-html into a text node
					} else if (!rhtml.test(elem)) {
						nodes.push(context.createTextNode(elem));
	
						// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild(context.createElement("div"));
	
						// Deserialize a standard representation
						tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
						wrap = wrapMap[tag] || wrapMap._default;
						tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
	
						// Descend through wrappers to the right content
						j = wrap[0];
						while (j--) {
							tmp = tmp.lastChild;
						}
	
						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge(nodes, tmp.childNodes);
	
						// Remember the top-level container
						tmp = fragment.firstChild;
	
						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}
	
			// Remove wrapper from fragment
			fragment.textContent = "";
	
			i = 0;
			while (elem = nodes[i++]) {
	
				// Skip elements already in the context collection (trac-4087)
				if (selection && jQuery.inArray(elem, selection) > -1) {
					if (ignored) {
						ignored.push(elem);
					}
					continue;
				}
	
				contains = jQuery.contains(elem.ownerDocument, elem);
	
				// Append to fragment
				tmp = getAll(fragment.appendChild(elem), "script");
	
				// Preserve script evaluation history
				if (contains) {
					setGlobalEval(tmp);
				}
	
				// Capture executables
				if (scripts) {
					j = 0;
					while (elem = tmp[j++]) {
						if (rscriptType.test(elem.type || "")) {
							scripts.push(elem);
						}
					}
				}
			}
	
			return fragment;
		}
	
		(function () {
			var fragment = document.createDocumentFragment(),
			    div = fragment.appendChild(document.createElement("div")),
			    input = document.createElement("input");
	
			// Support: Android 4.0-4.3, Safari<=5.1
			// Check state lost if the name is set (#11217)
			// Support: Windows Web Apps (WWA)
			// `name` and `type` must use .setAttribute for WWA (#14901)
			input.setAttribute("type", "radio");
			input.setAttribute("checked", "checked");
			input.setAttribute("name", "t");
	
			div.appendChild(input);
	
			// Support: Safari<=5.1, Android<4.2
			// Older WebKit doesn't clone checked state correctly in fragments
			support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
	
			// Support: IE<=11+
			// Make sure textarea (and checkbox) defaultValue is properly cloned
			div.innerHTML = "<textarea>x</textarea>";
			support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
		})();
	
		var rkeyEvent = /^key/,
		    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
		function returnTrue() {
			return true;
		}
	
		function returnFalse() {
			return false;
		}
	
		// Support: IE9
		// See #13393 for more info
		function safeActiveElement() {
			try {
				return document.activeElement;
			} catch (err) {}
		}
	
		function _on(elem, types, selector, data, fn, one) {
			var origFn, type;
	
			// Types can be a map of types/handlers
			if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
	
				// ( types-Object, selector, data )
				if (typeof selector !== "string") {
	
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for (type in types) {
					_on(elem, type, selector, data, types[type], one);
				}
				return elem;
			}
	
			if (data == null && fn == null) {
	
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if (fn == null) {
				if (typeof selector === "string") {
	
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
	
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if (fn === false) {
				fn = returnFalse;
			} else if (!fn) {
				return elem;
			}
	
			if (one === 1) {
				origFn = fn;
				fn = function fn(event) {
	
					// Can use an empty set, since event contains the info
					jQuery().off(event);
					return origFn.apply(this, arguments);
				};
	
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
			}
			return elem.each(function () {
				jQuery.event.add(this, types, fn, data, selector);
			});
		}
	
		/*
	  * Helper functions for managing events -- not part of the public interface.
	  * Props to Dean Edwards' addEvent library for many of the ideas.
	  */
		jQuery.event = {
	
			global: {},
	
			add: function add(elem, types, handler, data, selector) {
	
				var handleObjIn,
				    eventHandle,
				    tmp,
				    events,
				    t,
				    handleObj,
				    special,
				    handlers,
				    type,
				    namespaces,
				    origType,
				    elemData = dataPriv.get(elem);
	
				// Don't attach events to noData or text/comment nodes (but allow plain objects)
				if (!elemData) {
					return;
				}
	
				// Caller can pass in an object of custom data in lieu of the handler
				if (handler.handler) {
					handleObjIn = handler;
					handler = handleObjIn.handler;
					selector = handleObjIn.selector;
				}
	
				// Make sure that the handler has a unique ID, used to find/remove it later
				if (!handler.guid) {
					handler.guid = jQuery.guid++;
				}
	
				// Init the element's event structure and main handler, if this is the first
				if (!(events = elemData.events)) {
					events = elemData.events = {};
				}
				if (!(eventHandle = elemData.handle)) {
					eventHandle = elemData.handle = function (e) {
	
						// Discard the second event of a jQuery.event.trigger() and
						// when an event is called after a page has unloaded
						return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
					};
				}
	
				// Handle multiple events separated by a space
				types = (types || "").match(rnotwhite) || [""];
				t = types.length;
				while (t--) {
					tmp = rtypenamespace.exec(types[t]) || [];
					type = origType = tmp[1];
					namespaces = (tmp[2] || "").split(".").sort();
	
					// There *must* be a type, no attaching namespace-only handlers
					if (!type) {
						continue;
					}
	
					// If event changes its type, use the special event handlers for the changed type
					special = jQuery.event.special[type] || {};
	
					// If selector defined, determine special event api type, otherwise given type
					type = (selector ? special.delegateType : special.bindType) || type;
	
					// Update special based on newly reset type
					special = jQuery.event.special[type] || {};
	
					// handleObj is passed to all event handlers
					handleObj = jQuery.extend({
						type: type,
						origType: origType,
						data: data,
						handler: handler,
						guid: handler.guid,
						selector: selector,
						needsContext: selector && jQuery.expr.match.needsContext.test(selector),
						namespace: namespaces.join(".")
					}, handleObjIn);
	
					// Init the event handler queue if we're the first
					if (!(handlers = events[type])) {
						handlers = events[type] = [];
						handlers.delegateCount = 0;
	
						// Only use addEventListener if the special events handler returns false
						if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
	
							if (elem.addEventListener) {
								elem.addEventListener(type, eventHandle);
							}
						}
					}
	
					if (special.add) {
						special.add.call(elem, handleObj);
	
						if (!handleObj.handler.guid) {
							handleObj.handler.guid = handler.guid;
						}
					}
	
					// Add to the element's handler list, delegates in front
					if (selector) {
						handlers.splice(handlers.delegateCount++, 0, handleObj);
					} else {
						handlers.push(handleObj);
					}
	
					// Keep track of which events have ever been used, for event optimization
					jQuery.event.global[type] = true;
				}
			},
	
			// Detach an event or set of events from an element
			remove: function remove(elem, types, handler, selector, mappedTypes) {
	
				var j,
				    origCount,
				    tmp,
				    events,
				    t,
				    handleObj,
				    special,
				    handlers,
				    type,
				    namespaces,
				    origType,
				    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
	
				if (!elemData || !(events = elemData.events)) {
					return;
				}
	
				// Once for each type.namespace in types; type may be omitted
				types = (types || "").match(rnotwhite) || [""];
				t = types.length;
				while (t--) {
					tmp = rtypenamespace.exec(types[t]) || [];
					type = origType = tmp[1];
					namespaces = (tmp[2] || "").split(".").sort();
	
					// Unbind all events (on this namespace, if provided) for the element
					if (!type) {
						for (type in events) {
							jQuery.event.remove(elem, type + types[t], handler, selector, true);
						}
						continue;
					}
	
					special = jQuery.event.special[type] || {};
					type = (selector ? special.delegateType : special.bindType) || type;
					handlers = events[type] || [];
					tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
	
					// Remove matching events
					origCount = j = handlers.length;
					while (j--) {
						handleObj = handlers[j];
	
						if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
							handlers.splice(j, 1);
	
							if (handleObj.selector) {
								handlers.delegateCount--;
							}
							if (special.remove) {
								special.remove.call(elem, handleObj);
							}
						}
					}
	
					// Remove generic event handler if we removed something and no more handlers exist
					// (avoids potential for endless recursion during removal of special event handlers)
					if (origCount && !handlers.length) {
						if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
	
							jQuery.removeEvent(elem, type, elemData.handle);
						}
	
						delete events[type];
					}
				}
	
				// Remove data and the expando if it's no longer used
				if (jQuery.isEmptyObject(events)) {
					dataPriv.remove(elem, "handle events");
				}
			},
	
			dispatch: function dispatch(event) {
	
				// Make a writable jQuery.Event from the native event object
				event = jQuery.event.fix(event);
	
				var i,
				    j,
				    ret,
				    matched,
				    handleObj,
				    handlerQueue = [],
				    args = _slice.call(arguments),
				    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
				    special = jQuery.event.special[event.type] || {};
	
				// Use the fix-ed jQuery.Event rather than the (read-only) native event
				args[0] = event;
				event.delegateTarget = this;
	
				// Call the preDispatch hook for the mapped type, and let it bail if desired
				if (special.preDispatch && special.preDispatch.call(this, event) === false) {
					return;
				}
	
				// Determine handlers
				handlerQueue = jQuery.event.handlers.call(this, event, handlers);
	
				// Run delegates first; they may want to stop propagation beneath us
				i = 0;
				while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
					event.currentTarget = matched.elem;
	
					j = 0;
					while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
	
						// Triggered event must either 1) have no namespace, or 2) have namespace(s)
						// a subset or equal to those in the bound event (both can have no namespace).
						if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
	
							event.handleObj = handleObj;
							event.data = handleObj.data;
	
							ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
	
							if (ret !== undefined) {
								if ((event.result = ret) === false) {
									event.preventDefault();
									event.stopPropagation();
								}
							}
						}
					}
				}
	
				// Call the postDispatch hook for the mapped type
				if (special.postDispatch) {
					special.postDispatch.call(this, event);
				}
	
				return event.result;
			},
	
			handlers: function handlers(event, _handlers) {
				var i,
				    matches,
				    sel,
				    handleObj,
				    handlerQueue = [],
				    delegateCount = _handlers.delegateCount,
				    cur = event.target;
	
				// Support (at least): Chrome, IE9
				// Find delegate handlers
				// Black-hole SVG <use> instance trees (#13180)
				//
				// Support: Firefox<=42+
				// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
				if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
	
					for (; cur !== this; cur = cur.parentNode || this) {
	
						// Don't check non-elements (#13208)
						// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
						if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
							matches = [];
							for (i = 0; i < delegateCount; i++) {
								handleObj = _handlers[i];
	
								// Don't conflict with Object.prototype properties (#13203)
								sel = handleObj.selector + " ";
	
								if (matches[sel] === undefined) {
									matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
								}
								if (matches[sel]) {
									matches.push(handleObj);
								}
							}
							if (matches.length) {
								handlerQueue.push({ elem: cur, handlers: matches });
							}
						}
					}
				}
	
				// Add the remaining (directly-bound) handlers
				if (delegateCount < _handlers.length) {
					handlerQueue.push({ elem: this, handlers: _handlers.slice(delegateCount) });
				}
	
				return handlerQueue;
			},
	
			// Includes some event props shared by KeyEvent and MouseEvent
			props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
	
			fixHooks: {},
	
			keyHooks: {
				props: "char charCode key keyCode".split(" "),
				filter: function filter(event, original) {
	
					// Add which for key events
					if (event.which == null) {
						event.which = original.charCode != null ? original.charCode : original.keyCode;
					}
	
					return event;
				}
			},
	
			mouseHooks: {
				props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
				filter: function filter(event, original) {
					var eventDoc,
					    doc,
					    body,
					    button = original.button;
	
					// Calculate pageX/Y if missing and clientX/Y available
					if (event.pageX == null && original.clientX != null) {
						eventDoc = event.target.ownerDocument || document;
						doc = eventDoc.documentElement;
						body = eventDoc.body;
	
						event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
						event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
					}
	
					// Add which for click: 1 === left; 2 === middle; 3 === right
					// Note: button is not normalized, so don't use it
					if (!event.which && button !== undefined) {
						event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
					}
	
					return event;
				}
			},
	
			fix: function fix(event) {
				if (event[jQuery.expando]) {
					return event;
				}
	
				// Create a writable copy of the event object and normalize some properties
				var i,
				    prop,
				    copy,
				    type = event.type,
				    originalEvent = event,
				    fixHook = this.fixHooks[type];
	
				if (!fixHook) {
					this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
				}
				copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
	
				event = new jQuery.Event(originalEvent);
	
				i = copy.length;
				while (i--) {
					prop = copy[i];
					event[prop] = originalEvent[prop];
				}
	
				// Support: Cordova 2.5 (WebKit) (#13255)
				// All events should have a target; Cordova deviceready doesn't
				if (!event.target) {
					event.target = document;
				}
	
				// Support: Safari 6.0+, Chrome<28
				// Target should not be a text node (#504, #13143)
				if (event.target.nodeType === 3) {
					event.target = event.target.parentNode;
				}
	
				return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
			},
	
			special: {
				load: {
	
					// Prevent triggered image.load events from bubbling to window.load
					noBubble: true
				},
				focus: {
	
					// Fire native event if possible so blur/focus sequence is correct
					trigger: function trigger() {
						if (this !== safeActiveElement() && this.focus) {
							this.focus();
							return false;
						}
					},
					delegateType: "focusin"
				},
				blur: {
					trigger: function trigger() {
						if (this === safeActiveElement() && this.blur) {
							this.blur();
							return false;
						}
					},
					delegateType: "focusout"
				},
				click: {
	
					// For checkbox, fire native event so checked state will be right
					trigger: function trigger() {
						if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
							this.click();
							return false;
						}
					},
	
					// For cross-browser consistency, don't fire native .click() on links
					_default: function _default(event) {
						return jQuery.nodeName(event.target, "a");
					}
				},
	
				beforeunload: {
					postDispatch: function postDispatch(event) {
	
						// Support: Firefox 20+
						// Firefox doesn't alert if the returnValue field is not set.
						if (event.result !== undefined && event.originalEvent) {
							event.originalEvent.returnValue = event.result;
						}
					}
				}
			}
		};
	
		jQuery.removeEvent = function (elem, type, handle) {
	
			// This "if" is needed for plain objects
			if (elem.removeEventListener) {
				elem.removeEventListener(type, handle);
			}
		};
	
		jQuery.Event = function (src, props) {
	
			// Allow instantiation without the 'new' keyword
			if (!(this instanceof jQuery.Event)) {
				return new jQuery.Event(src, props);
			}
	
			// Event object
			if (src && src.type) {
				this.originalEvent = src;
				this.type = src.type;
	
				// Events bubbling up the document may have been marked as prevented
				// by a handler lower down the tree; reflect the correct value.
				this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&
	
				// Support: Android<4.0
				src.returnValue === false ? returnTrue : returnFalse;
	
				// Event type
			} else {
				this.type = src;
			}
	
			// Put explicitly provided properties onto the event object
			if (props) {
				jQuery.extend(this, props);
			}
	
			// Create a timestamp if incoming event doesn't have one
			this.timeStamp = src && src.timeStamp || jQuery.now();
	
			// Mark it as fixed
			this[jQuery.expando] = true;
		};
	
		// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
		// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
		jQuery.Event.prototype = {
			constructor: jQuery.Event,
			isDefaultPrevented: returnFalse,
			isPropagationStopped: returnFalse,
			isImmediatePropagationStopped: returnFalse,
			isSimulated: false,
	
			preventDefault: function preventDefault() {
				var e = this.originalEvent;
	
				this.isDefaultPrevented = returnTrue;
	
				if (e && !this.isSimulated) {
					e.preventDefault();
				}
			},
			stopPropagation: function stopPropagation() {
				var e = this.originalEvent;
	
				this.isPropagationStopped = returnTrue;
	
				if (e && !this.isSimulated) {
					e.stopPropagation();
				}
			},
			stopImmediatePropagation: function stopImmediatePropagation() {
				var e = this.originalEvent;
	
				this.isImmediatePropagationStopped = returnTrue;
	
				if (e && !this.isSimulated) {
					e.stopImmediatePropagation();
				}
	
				this.stopPropagation();
			}
		};
	
		// Create mouseenter/leave events using mouseover/out and event-time checks
		// so that event delegation works in jQuery.
		// Do the same for pointerenter/pointerleave and pointerover/pointerout
		//
		// Support: Safari 7 only
		// Safari sends mouseenter too often; see:
		// https://code.google.com/p/chromium/issues/detail?id=470258
		// for the description of the bug (it existed in older Chrome versions as well).
		jQuery.each({
			mouseenter: "mouseover",
			mouseleave: "mouseout",
			pointerenter: "pointerover",
			pointerleave: "pointerout"
		}, function (orig, fix) {
			jQuery.event.special[orig] = {
				delegateType: fix,
				bindType: fix,
	
				handle: function handle(event) {
					var ret,
					    target = this,
					    related = event.relatedTarget,
					    handleObj = event.handleObj;
	
					// For mouseenter/leave call the handler if related is outside the target.
					// NB: No relatedTarget if the mouse left/entered the browser window
					if (!related || related !== target && !jQuery.contains(target, related)) {
						event.type = handleObj.origType;
						ret = handleObj.handler.apply(this, arguments);
						event.type = fix;
					}
					return ret;
				}
			};
		});
	
		jQuery.fn.extend({
			on: function on(types, selector, data, fn) {
				return _on(this, types, selector, data, fn);
			},
			one: function one(types, selector, data, fn) {
				return _on(this, types, selector, data, fn, 1);
			},
			off: function off(types, selector, fn) {
				var handleObj, type;
				if (types && types.preventDefault && types.handleObj) {
	
					// ( event )  dispatched jQuery.Event
					handleObj = types.handleObj;
					jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
					return this;
				}
				if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
	
					// ( types-object [, selector] )
					for (type in types) {
						this.off(type, selector, types[type]);
					}
					return this;
				}
				if (selector === false || typeof selector === "function") {
	
					// ( types [, fn] )
					fn = selector;
					selector = undefined;
				}
				if (fn === false) {
					fn = returnFalse;
				}
				return this.each(function () {
					jQuery.event.remove(this, types, fn, selector);
				});
			}
		});
	
		var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
	
	
		// Support: IE 10-11, Edge 10240+
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		    rscriptTypeMasked = /^true\/(.*)/,
		    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
		// Manipulating tables requires a tbody
		function manipulationTarget(elem, content) {
			return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
		}
	
		// Replace/restore the type attribute of script elements for safe DOM manipulation
		function disableScript(elem) {
			elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
			return elem;
		}
		function restoreScript(elem) {
			var match = rscriptTypeMasked.exec(elem.type);
	
			if (match) {
				elem.type = match[1];
			} else {
				elem.removeAttribute("type");
			}
	
			return elem;
		}
	
		function cloneCopyEvent(src, dest) {
			var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
	
			if (dest.nodeType !== 1) {
				return;
			}
	
			// 1. Copy private data: events, handlers, etc.
			if (dataPriv.hasData(src)) {
				pdataOld = dataPriv.access(src);
				pdataCur = dataPriv.set(dest, pdataOld);
				events = pdataOld.events;
	
				if (events) {
					delete pdataCur.handle;
					pdataCur.events = {};
	
					for (type in events) {
						for (i = 0, l = events[type].length; i < l; i++) {
							jQuery.event.add(dest, type, events[type][i]);
						}
					}
				}
			}
	
			// 2. Copy user data
			if (dataUser.hasData(src)) {
				udataOld = dataUser.access(src);
				udataCur = jQuery.extend({}, udataOld);
	
				dataUser.set(dest, udataCur);
			}
		}
	
		// Fix IE bugs, see support tests
		function fixInput(src, dest) {
			var nodeName = dest.nodeName.toLowerCase();
	
			// Fails to persist the checked state of a cloned checkbox or radio button.
			if (nodeName === "input" && rcheckableType.test(src.type)) {
				dest.checked = src.checked;
	
				// Fails to return the selected option to the default selected state when cloning options
			} else if (nodeName === "input" || nodeName === "textarea") {
				dest.defaultValue = src.defaultValue;
			}
		}
	
		function domManip(collection, args, callback, ignored) {
	
			// Flatten any nested arrays
			args = concat.apply([], args);
	
			var fragment,
			    first,
			    scripts,
			    hasScripts,
			    node,
			    doc,
			    i = 0,
			    l = collection.length,
			    iNoClone = l - 1,
			    value = args[0],
			    isFunction = jQuery.isFunction(value);
	
			// We can't cloneNode fragments that contain checked, in WebKit
			if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
				return collection.each(function (index) {
					var self = collection.eq(index);
					if (isFunction) {
						args[0] = value.call(this, index, self.html());
					}
					domManip(self, args, callback, ignored);
				});
			}
	
			if (l) {
				fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
				first = fragment.firstChild;
	
				if (fragment.childNodes.length === 1) {
					fragment = first;
				}
	
				// Require either new content or an interest in ignored elements to invoke the callback
				if (first || ignored) {
					scripts = jQuery.map(getAll(fragment, "script"), disableScript);
					hasScripts = scripts.length;
	
					// Use the original fragment for the last item
					// instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for (; i < l; i++) {
						node = fragment;
	
						if (i !== iNoClone) {
							node = jQuery.clone(node, true, true);
	
							// Keep references to cloned scripts for later restoration
							if (hasScripts) {
	
								// Support: Android<4.1, PhantomJS<2
								// push.apply(_, arraylike) throws on ancient WebKit
								jQuery.merge(scripts, getAll(node, "script"));
							}
						}
	
						callback.call(collection[i], node, i);
					}
	
					if (hasScripts) {
						doc = scripts[scripts.length - 1].ownerDocument;
	
						// Reenable scripts
						jQuery.map(scripts, restoreScript);
	
						// Evaluate executable scripts on first document insertion
						for (i = 0; i < hasScripts; i++) {
							node = scripts[i];
							if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
	
								if (node.src) {
	
									// Optional AJAX dependency, but won't run scripts if not present
									if (jQuery._evalUrl) {
										jQuery._evalUrl(node.src);
									}
								} else {
									jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
								}
							}
						}
					}
				}
			}
	
			return collection;
		}
	
		function _remove(elem, selector, keepData) {
			var node,
			    nodes = selector ? jQuery.filter(selector, elem) : elem,
			    i = 0;
	
			for (; (node = nodes[i]) != null; i++) {
				if (!keepData && node.nodeType === 1) {
					jQuery.cleanData(getAll(node));
				}
	
				if (node.parentNode) {
					if (keepData && jQuery.contains(node.ownerDocument, node)) {
						setGlobalEval(getAll(node, "script"));
					}
					node.parentNode.removeChild(node);
				}
			}
	
			return elem;
		}
	
		jQuery.extend({
			htmlPrefilter: function htmlPrefilter(html) {
				return html.replace(rxhtmlTag, "<$1></$2>");
			},
	
			clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
				var i,
				    l,
				    srcElements,
				    destElements,
				    clone = elem.cloneNode(true),
				    inPage = jQuery.contains(elem.ownerDocument, elem);
	
				// Fix IE cloning issues
				if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
	
					// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
					destElements = getAll(clone);
					srcElements = getAll(elem);
	
					for (i = 0, l = srcElements.length; i < l; i++) {
						fixInput(srcElements[i], destElements[i]);
					}
				}
	
				// Copy the events from the original to the clone
				if (dataAndEvents) {
					if (deepDataAndEvents) {
						srcElements = srcElements || getAll(elem);
						destElements = destElements || getAll(clone);
	
						for (i = 0, l = srcElements.length; i < l; i++) {
							cloneCopyEvent(srcElements[i], destElements[i]);
						}
					} else {
						cloneCopyEvent(elem, clone);
					}
				}
	
				// Preserve script evaluation history
				destElements = getAll(clone, "script");
				if (destElements.length > 0) {
					setGlobalEval(destElements, !inPage && getAll(elem, "script"));
				}
	
				// Return the cloned set
				return clone;
			},
	
			cleanData: function cleanData(elems) {
				var data,
				    elem,
				    type,
				    special = jQuery.event.special,
				    i = 0;
	
				for (; (elem = elems[i]) !== undefined; i++) {
					if (acceptData(elem)) {
						if (data = elem[dataPriv.expando]) {
							if (data.events) {
								for (type in data.events) {
									if (special[type]) {
										jQuery.event.remove(elem, type);
	
										// This is a shortcut to avoid jQuery.event.remove's overhead
									} else {
										jQuery.removeEvent(elem, type, data.handle);
									}
								}
							}
	
							// Support: Chrome <= 35-45+
							// Assign undefined instead of using delete, see Data#remove
							elem[dataPriv.expando] = undefined;
						}
						if (elem[dataUser.expando]) {
	
							// Support: Chrome <= 35-45+
							// Assign undefined instead of using delete, see Data#remove
							elem[dataUser.expando] = undefined;
						}
					}
				}
			}
		});
	
		jQuery.fn.extend({
	
			// Keep domManip exposed until 3.0 (gh-2225)
			domManip: domManip,
	
			detach: function detach(selector) {
				return _remove(this, selector, true);
			},
	
			remove: function remove(selector) {
				return _remove(this, selector);
			},
	
			text: function text(value) {
				return access(this, function (value) {
					return value === undefined ? jQuery.text(this) : this.empty().each(function () {
						if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
							this.textContent = value;
						}
					});
				}, null, value, arguments.length);
			},
	
			append: function append() {
				return domManip(this, arguments, function (elem) {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						var target = manipulationTarget(this, elem);
						target.appendChild(elem);
					}
				});
			},
	
			prepend: function prepend() {
				return domManip(this, arguments, function (elem) {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						var target = manipulationTarget(this, elem);
						target.insertBefore(elem, target.firstChild);
					}
				});
			},
	
			before: function before() {
				return domManip(this, arguments, function (elem) {
					if (this.parentNode) {
						this.parentNode.insertBefore(elem, this);
					}
				});
			},
	
			after: function after() {
				return domManip(this, arguments, function (elem) {
					if (this.parentNode) {
						this.parentNode.insertBefore(elem, this.nextSibling);
					}
				});
			},
	
			empty: function empty() {
				var elem,
				    i = 0;
	
				for (; (elem = this[i]) != null; i++) {
					if (elem.nodeType === 1) {
	
						// Prevent memory leaks
						jQuery.cleanData(getAll(elem, false));
	
						// Remove any remaining nodes
						elem.textContent = "";
					}
				}
	
				return this;
			},
	
			clone: function clone(dataAndEvents, deepDataAndEvents) {
				dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
				deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
				return this.map(function () {
					return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
				});
			},
	
			html: function html(value) {
				return access(this, function (value) {
					var elem = this[0] || {},
					    i = 0,
					    l = this.length;
	
					if (value === undefined && elem.nodeType === 1) {
						return elem.innerHTML;
					}
	
					// See if we can take a shortcut and just use innerHTML
					if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
	
						value = jQuery.htmlPrefilter(value);
	
						try {
							for (; i < l; i++) {
								elem = this[i] || {};
	
								// Remove element nodes and prevent memory leaks
								if (elem.nodeType === 1) {
									jQuery.cleanData(getAll(elem, false));
									elem.innerHTML = value;
								}
							}
	
							elem = 0;
	
							// If using innerHTML throws an exception, use the fallback method
						} catch (e) {}
					}
	
					if (elem) {
						this.empty().append(value);
					}
				}, null, value, arguments.length);
			},
	
			replaceWith: function replaceWith() {
				var ignored = [];
	
				// Make the changes, replacing each non-ignored context element with the new content
				return domManip(this, arguments, function (elem) {
					var parent = this.parentNode;
	
					if (jQuery.inArray(this, ignored) < 0) {
						jQuery.cleanData(getAll(this));
						if (parent) {
							parent.replaceChild(elem, this);
						}
					}
	
					// Force callback invocation
				}, ignored);
			}
		});
	
		jQuery.each({
			appendTo: "append",
			prependTo: "prepend",
			insertBefore: "before",
			insertAfter: "after",
			replaceAll: "replaceWith"
		}, function (name, original) {
			jQuery.fn[name] = function (selector) {
				var elems,
				    ret = [],
				    insert = jQuery(selector),
				    last = insert.length - 1,
				    i = 0;
	
				for (; i <= last; i++) {
					elems = i === last ? this : this.clone(true);
					jQuery(insert[i])[original](elems);
	
					// Support: QtWebKit
					// .get() because push.apply(_, arraylike) throws
					push.apply(ret, elems.get());
				}
	
				return this.pushStack(ret);
			};
		});
	
		var iframe,
		    elemdisplay = {
	
			// Support: Firefox
			// We have to pre-define these values for FF (#10227)
			HTML: "block",
			BODY: "block"
		};
	
		/**
	  * Retrieve the actual display of a element
	  * @param {String} name nodeName of the element
	  * @param {Object} doc Document object
	  */
	
		// Called only from within defaultDisplay
		function actualDisplay(name, doc) {
			var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
			    display = jQuery.css(elem[0], "display");
	
			// We don't have any data stored on the element,
			// so use "detach" method as fast way to get rid of the element
			elem.detach();
	
			return display;
		}
	
		/**
	  * Try to determine the default display value of an element
	  * @param {String} nodeName
	  */
		function defaultDisplay(nodeName) {
			var doc = document,
			    display = elemdisplay[nodeName];
	
			if (!display) {
				display = actualDisplay(nodeName, doc);
	
				// If the simple way fails, read from inside an iframe
				if (display === "none" || !display) {
	
					// Use the already-created iframe if possible
					iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
	
					// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
					doc = iframe[0].contentDocument;
	
					// Support: IE
					doc.write();
					doc.close();
	
					display = actualDisplay(nodeName, doc);
					iframe.detach();
				}
	
				// Store the correct default display
				elemdisplay[nodeName] = display;
			}
	
			return display;
		}
		var rmargin = /^margin/;
	
		var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
	
		var getStyles = function getStyles(elem) {
	
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if (!view || !view.opener) {
				view = window;
			}
	
			return view.getComputedStyle(elem);
		};
	
		var swap = function swap(elem, options, callback, args) {
			var ret,
			    name,
			    old = {};
	
			// Remember the old values, and insert the new ones
			for (name in options) {
				old[name] = elem.style[name];
				elem.style[name] = options[name];
			}
	
			ret = callback.apply(elem, args || []);
	
			// Revert the old values
			for (name in options) {
				elem.style[name] = old[name];
			}
	
			return ret;
		};
	
		var documentElement = document.documentElement;
	
		(function () {
			var pixelPositionVal,
			    boxSizingReliableVal,
			    pixelMarginRightVal,
			    reliableMarginLeftVal,
			    container = document.createElement("div"),
			    div = document.createElement("div");
	
			// Finish early in limited (non-browser) environments
			if (!div.style) {
				return;
			}
	
			// Support: IE9-11+
			// Style of cloned element affects source element cloned (#8908)
			div.style.backgroundClip = "content-box";
			div.cloneNode(true).style.backgroundClip = "";
			support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
			container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
			container.appendChild(div);
	
			// Executing both pixelPosition & boxSizingReliable tests require only one layout
			// so they're executed at the same time to save the second computation.
			function computeStyleTests() {
				div.style.cssText =
	
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
				div.innerHTML = "";
				documentElement.appendChild(container);
	
				var divStyle = window.getComputedStyle(div);
				pixelPositionVal = divStyle.top !== "1%";
				reliableMarginLeftVal = divStyle.marginLeft === "2px";
				boxSizingReliableVal = divStyle.width === "4px";
	
				// Support: Android 4.0 - 4.3 only
				// Some styles come back with percentage values, even though they shouldn't
				div.style.marginRight = "50%";
				pixelMarginRightVal = divStyle.marginRight === "4px";
	
				documentElement.removeChild(container);
			}
	
			jQuery.extend(support, {
				pixelPosition: function pixelPosition() {
	
					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computeStyleTests();
					return pixelPositionVal;
				},
				boxSizingReliable: function boxSizingReliable() {
					if (boxSizingReliableVal == null) {
						computeStyleTests();
					}
					return boxSizingReliableVal;
				},
				pixelMarginRight: function pixelMarginRight() {
	
					// Support: Android 4.0-4.3
					// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
					// since that compresses better and they're computed together anyway.
					if (boxSizingReliableVal == null) {
						computeStyleTests();
					}
					return pixelMarginRightVal;
				},
				reliableMarginLeft: function reliableMarginLeft() {
	
					// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
					if (boxSizingReliableVal == null) {
						computeStyleTests();
					}
					return reliableMarginLeftVal;
				},
				reliableMarginRight: function reliableMarginRight() {
	
					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
					    marginDiv = div.appendChild(document.createElement("div"));
	
					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
	
					// Support: Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					documentElement.appendChild(container);
	
					ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
	
					documentElement.removeChild(container);
					div.removeChild(marginDiv);
	
					return ret;
				}
			});
		})();
	
		function curCSS(elem, name, computed) {
			var width,
			    minWidth,
			    maxWidth,
			    ret,
			    style = elem.style;
	
			computed = computed || getStyles(elem);
			ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
	
			// Support: Opera 12.1x only
			// Fall back to style even without computed
			// computed is undefined for elems on document fragments
			if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
				ret = jQuery.style(elem, name);
			}
	
			// Support: IE9
			// getPropertyValue is only needed for .css('filter') (#12537)
			if (computed) {
	
				// A tribute to the "awesome hack by Dean Edwards"
				// Android Browser returns percentage for some values,
				// but width seems to be reliably pixels.
				// This is against the CSSOM draft spec:
				// http://dev.w3.org/csswg/cssom/#resolved-values
				if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
	
					// Remember the original values
					width = style.width;
					minWidth = style.minWidth;
					maxWidth = style.maxWidth;
	
					// Put in the new values to get a computed value out
					style.minWidth = style.maxWidth = style.width = ret;
					ret = computed.width;
	
					// Revert the changed values
					style.width = width;
					style.minWidth = minWidth;
					style.maxWidth = maxWidth;
				}
			}
	
			return ret !== undefined ?
	
			// Support: IE9-11+
			// IE returns zIndex value as an integer.
			ret + "" : ret;
		}
	
		function addGetHookIf(conditionFn, hookFn) {
	
			// Define the hook, we'll check on the first run if it's really needed.
			return {
				get: function get() {
					if (conditionFn()) {
	
						// Hook not needed (or it's not possible to use it due
						// to missing dependency), remove it.
						delete this.get;
						return;
					}
	
					// Hook needed; redefine it so that the support test is not executed again.
					return (this.get = hookFn).apply(this, arguments);
				}
			};
		}
	
		var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		    cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},
		    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
		    emptyStyle = document.createElement("div").style;
	
		// Return a css property mapped to a potentially vendor prefixed property
		function vendorPropName(name) {
	
			// Shortcut for names that are not vendor prefixed
			if (name in emptyStyle) {
				return name;
			}
	
			// Check for vendor prefixed names
			var capName = name[0].toUpperCase() + name.slice(1),
			    i = cssPrefixes.length;
	
			while (i--) {
				name = cssPrefixes[i] + capName;
				if (name in emptyStyle) {
					return name;
				}
			}
		}
	
		function setPositiveNumber(elem, value, subtract) {
	
			// Any relative (+/-) values have already been
			// normalized at this point
			var matches = rcssNum.exec(value);
			return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
		}
	
		function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
			var i = extra === (isBorderBox ? "border" : "content") ?
	
			// If we already have the right measurement, avoid augmentation
			4 :
	
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,
			    val = 0;
	
			for (; i < 4; i += 2) {
	
				// Both box models exclude margin, so add it if we want it
				if (extra === "margin") {
					val += jQuery.css(elem, extra + cssExpand[i], true, styles);
				}
	
				if (isBorderBox) {
	
					// border-box includes padding, so remove it if we want content
					if (extra === "content") {
						val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
					}
	
					// At this point, extra isn't border nor margin, so remove border
					if (extra !== "margin") {
						val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
					}
				} else {
	
					// At this point, extra isn't content, so add padding
					val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
	
					// At this point, extra isn't content nor padding, so add border
					if (extra !== "padding") {
						val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
					}
				}
			}
	
			return val;
		}
	
		function getWidthOrHeight(elem, name, extra) {
	
			// Start with offset property, which is equivalent to the border-box value
			var valueIsBorderBox = true,
			    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			    styles = getStyles(elem),
			    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
	
			// Some non-html elements return undefined for offsetWidth, so check for null/undefined
			// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
			// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
			if (val <= 0 || val == null) {
	
				// Fall back to computed then uncomputed css if necessary
				val = curCSS(elem, name, styles);
				if (val < 0 || val == null) {
					val = elem.style[name];
				}
	
				// Computed unit is not pixels. Stop here and return.
				if (rnumnonpx.test(val)) {
					return val;
				}
	
				// Check for style in case a browser which returns unreliable values
				// for getComputedStyle silently falls back to the reliable elem.style
				valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
	
				// Normalize "", auto, and prepare for extra
				val = parseFloat(val) || 0;
			}
	
			// Use the active box-sizing model to add/subtract irrelevant styles
			return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
		}
	
		function showHide(elements, show) {
			var display,
			    elem,
			    hidden,
			    values = [],
			    index = 0,
			    length = elements.length;
	
			for (; index < length; index++) {
				elem = elements[index];
				if (!elem.style) {
					continue;
				}
	
				values[index] = dataPriv.get(elem, "olddisplay");
				display = elem.style.display;
				if (show) {
	
					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if (!values[index] && display === "none") {
						elem.style.display = "";
					}
	
					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if (elem.style.display === "" && isHidden(elem)) {
						values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
					}
				} else {
					hidden = isHidden(elem);
	
					if (display !== "none" || !hidden) {
						dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
					}
				}
			}
	
			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for (index = 0; index < length; index++) {
				elem = elements[index];
				if (!elem.style) {
					continue;
				}
				if (!show || elem.style.display === "none" || elem.style.display === "") {
					elem.style.display = show ? values[index] || "" : "none";
				}
			}
	
			return elements;
		}
	
		jQuery.extend({
	
			// Add in style property hooks for overriding the default
			// behavior of getting and setting a style property
			cssHooks: {
				opacity: {
					get: function get(elem, computed) {
						if (computed) {
	
							// We should always get a number back from opacity
							var ret = curCSS(elem, "opacity");
							return ret === "" ? "1" : ret;
						}
					}
				}
			},
	
			// Don't automatically add "px" to these possibly-unitless properties
			cssNumber: {
				"animationIterationCount": true,
				"columnCount": true,
				"fillOpacity": true,
				"flexGrow": true,
				"flexShrink": true,
				"fontWeight": true,
				"lineHeight": true,
				"opacity": true,
				"order": true,
				"orphans": true,
				"widows": true,
				"zIndex": true,
				"zoom": true
			},
	
			// Add in properties whose names you wish to fix before
			// setting or getting the value
			cssProps: {
				"float": "cssFloat"
			},
	
			// Get and set the style property on a DOM Node
			style: function style(elem, name, value, extra) {
	
				// Don't set styles on text and comment nodes
				if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
					return;
				}
	
				// Make sure that we're working with the right name
				var ret,
				    type,
				    hooks,
				    origName = jQuery.camelCase(name),
				    style = elem.style;
	
				name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
	
				// Gets hook for the prefixed version, then unprefixed version
				hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
	
				// Check if we're setting a value
				if (value !== undefined) {
					type = typeof value === "undefined" ? "undefined" : _typeof(value);
	
					// Convert "+=" or "-=" to relative numbers (#7345)
					if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
						value = adjustCSS(elem, name, ret);
	
						// Fixes bug #9237
						type = "number";
					}
	
					// Make sure that null and NaN values aren't set (#7116)
					if (value == null || value !== value) {
						return;
					}
	
					// If a number was passed in, add the unit (except for certain CSS properties)
					if (type === "number") {
						value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
					}
	
					// Support: IE9-11+
					// background-* props affect original clone's values
					if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
						style[name] = "inherit";
					}
	
					// If a hook was provided, use that value, otherwise just set the specified value
					if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
	
						style[name] = value;
					}
				} else {
	
					// If a hook was provided get the non-computed value from there
					if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
	
						return ret;
					}
	
					// Otherwise just get the value from the style object
					return style[name];
				}
			},
	
			css: function css(elem, name, extra, styles) {
				var val,
				    num,
				    hooks,
				    origName = jQuery.camelCase(name);
	
				// Make sure that we're working with the right name
				name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
	
				// Try prefixed name followed by the unprefixed name
				hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
	
				// If a hook was provided get the computed value from there
				if (hooks && "get" in hooks) {
					val = hooks.get(elem, true, extra);
				}
	
				// Otherwise, if a way to get the computed value exists, use that
				if (val === undefined) {
					val = curCSS(elem, name, styles);
				}
	
				// Convert "normal" to computed value
				if (val === "normal" && name in cssNormalTransform) {
					val = cssNormalTransform[name];
				}
	
				// Make numeric if forced or a qualifier was provided and val looks numeric
				if (extra === "" || extra) {
					num = parseFloat(val);
					return extra === true || isFinite(num) ? num || 0 : val;
				}
				return val;
			}
		});
	
		jQuery.each(["height", "width"], function (i, name) {
			jQuery.cssHooks[name] = {
				get: function get(elem, computed, extra) {
					if (computed) {
	
						// Certain elements can have dimension info if we invisibly show them
						// but it must have a current display style that would benefit
						return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
							return getWidthOrHeight(elem, name, extra);
						}) : getWidthOrHeight(elem, name, extra);
					}
				},
	
				set: function set(elem, value, extra) {
					var matches,
					    styles = extra && getStyles(elem),
					    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
	
					// Convert to pixels if value adjustment is needed
					if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
	
						elem.style[name] = value;
						value = jQuery.css(elem, name);
					}
	
					return setPositiveNumber(elem, value, subtract);
				}
			};
		});
	
		jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
			if (computed) {
				return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
					return elem.getBoundingClientRect().left;
				})) + "px";
			}
		});
	
		// Support: Android 2.3
		jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
			if (computed) {
				return swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
			}
		});
	
		// These hooks are used by animate to expand properties
		jQuery.each({
			margin: "",
			padding: "",
			border: "Width"
		}, function (prefix, suffix) {
			jQuery.cssHooks[prefix + suffix] = {
				expand: function expand(value) {
					var i = 0,
					    expanded = {},
	
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [value];
	
					for (; i < 4; i++) {
						expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
					}
	
					return expanded;
				}
			};
	
			if (!rmargin.test(prefix)) {
				jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
			}
		});
	
		jQuery.fn.extend({
			css: function css(name, value) {
				return access(this, function (elem, name, value) {
					var styles,
					    len,
					    map = {},
					    i = 0;
	
					if (jQuery.isArray(name)) {
						styles = getStyles(elem);
						len = name.length;
	
						for (; i < len; i++) {
							map[name[i]] = jQuery.css(elem, name[i], false, styles);
						}
	
						return map;
					}
	
					return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
				}, name, value, arguments.length > 1);
			},
			show: function show() {
				return showHide(this, true);
			},
			hide: function hide() {
				return showHide(this);
			},
			toggle: function toggle(state) {
				if (typeof state === "boolean") {
					return state ? this.show() : this.hide();
				}
	
				return this.each(function () {
					if (isHidden(this)) {
						jQuery(this).show();
					} else {
						jQuery(this).hide();
					}
				});
			}
		});
	
		function Tween(elem, options, prop, end, easing) {
			return new Tween.prototype.init(elem, options, prop, end, easing);
		}
		jQuery.Tween = Tween;
	
		Tween.prototype = {
			constructor: Tween,
			init: function init(elem, options, prop, end, easing, unit) {
				this.elem = elem;
				this.prop = prop;
				this.easing = easing || jQuery.easing._default;
				this.options = options;
				this.start = this.now = this.cur();
				this.end = end;
				this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
			},
			cur: function cur() {
				var hooks = Tween.propHooks[this.prop];
	
				return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
			},
			run: function run(percent) {
				var eased,
				    hooks = Tween.propHooks[this.prop];
	
				if (this.options.duration) {
					this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
				} else {
					this.pos = eased = percent;
				}
				this.now = (this.end - this.start) * eased + this.start;
	
				if (this.options.step) {
					this.options.step.call(this.elem, this.now, this);
				}
	
				if (hooks && hooks.set) {
					hooks.set(this);
				} else {
					Tween.propHooks._default.set(this);
				}
				return this;
			}
		};
	
		Tween.prototype.init.prototype = Tween.prototype;
	
		Tween.propHooks = {
			_default: {
				get: function get(tween) {
					var result;
	
					// Use a property on the element directly when it is not a DOM element,
					// or when there is no matching style property that exists.
					if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
						return tween.elem[tween.prop];
					}
	
					// Passing an empty string as a 3rd parameter to .css will automatically
					// attempt a parseFloat and fallback to a string if the parse fails.
					// Simple values such as "10px" are parsed to Float;
					// complex values such as "rotate(1rad)" are returned as-is.
					result = jQuery.css(tween.elem, tween.prop, "");
	
					// Empty strings, null, undefined and "auto" are converted to 0.
					return !result || result === "auto" ? 0 : result;
				},
				set: function set(tween) {
	
					// Use step hook for back compat.
					// Use cssHook if its there.
					// Use .style if available and use plain properties where available.
					if (jQuery.fx.step[tween.prop]) {
						jQuery.fx.step[tween.prop](tween);
					} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
						jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
					} else {
						tween.elem[tween.prop] = tween.now;
					}
				}
			}
		};
	
		// Support: IE9
		// Panic based approach to setting things on disconnected nodes
		Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
			set: function set(tween) {
				if (tween.elem.nodeType && tween.elem.parentNode) {
					tween.elem[tween.prop] = tween.now;
				}
			}
		};
	
		jQuery.easing = {
			linear: function linear(p) {
				return p;
			},
			swing: function swing(p) {
				return 0.5 - Math.cos(p * Math.PI) / 2;
			},
			_default: "swing"
		};
	
		jQuery.fx = Tween.prototype.init;
	
		// Back Compat <1.8 extension point
		jQuery.fx.step = {};
	
		var fxNow,
		    timerId,
		    rfxtypes = /^(?:toggle|show|hide)$/,
		    rrun = /queueHooks$/;
	
		// Animations created synchronously will run synchronously
		function createFxNow() {
			window.setTimeout(function () {
				fxNow = undefined;
			});
			return fxNow = jQuery.now();
		}
	
		// Generate parameters to create a standard animation
		function genFx(type, includeWidth) {
			var which,
			    i = 0,
			    attrs = { height: type };
	
			// If we include width, step value is 1 to do all cssExpand values,
			// otherwise step value is 2 to skip over Left and Right
			includeWidth = includeWidth ? 1 : 0;
			for (; i < 4; i += 2 - includeWidth) {
				which = cssExpand[i];
				attrs["margin" + which] = attrs["padding" + which] = type;
			}
	
			if (includeWidth) {
				attrs.opacity = attrs.width = type;
			}
	
			return attrs;
		}
	
		function createTween(value, prop, animation) {
			var tween,
			    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
			    index = 0,
			    length = collection.length;
			for (; index < length; index++) {
				if (tween = collection[index].call(animation, prop, value)) {
	
					// We're done with this property
					return tween;
				}
			}
		}
	
		function defaultPrefilter(elem, props, opts) {
			/* jshint validthis: true */
			var prop,
			    value,
			    toggle,
			    tween,
			    hooks,
			    oldfire,
			    display,
			    checkDisplay,
			    anim = this,
			    orig = {},
			    style = elem.style,
			    hidden = elem.nodeType && isHidden(elem),
			    dataShow = dataPriv.get(elem, "fxshow");
	
			// Handle queue: false promises
			if (!opts.queue) {
				hooks = jQuery._queueHooks(elem, "fx");
				if (hooks.unqueued == null) {
					hooks.unqueued = 0;
					oldfire = hooks.empty.fire;
					hooks.empty.fire = function () {
						if (!hooks.unqueued) {
							oldfire();
						}
					};
				}
				hooks.unqueued++;
	
				anim.always(function () {
	
					// Ensure the complete handler is called before this completes
					anim.always(function () {
						hooks.unqueued--;
						if (!jQuery.queue(elem, "fx").length) {
							hooks.empty.fire();
						}
					});
				});
			}
	
			// Height/width overflow pass
			if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
	
				// Make sure that nothing sneaks out
				// Record all 3 overflow attributes because IE9-10 do not
				// change the overflow attribute when overflowX and
				// overflowY are set to the same value
				opts.overflow = [style.overflow, style.overflowX, style.overflowY];
	
				// Set display property to inline-block for height/width
				// animations on inline elements that are having width/height animated
				display = jQuery.css(elem, "display");
	
				// Test default display if display is currently "none"
				checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
	
				if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
					style.display = "inline-block";
				}
			}
	
			if (opts.overflow) {
				style.overflow = "hidden";
				anim.always(function () {
					style.overflow = opts.overflow[0];
					style.overflowX = opts.overflow[1];
					style.overflowY = opts.overflow[2];
				});
			}
	
			// show/hide pass
			for (prop in props) {
				value = props[prop];
				if (rfxtypes.exec(value)) {
					delete props[prop];
					toggle = toggle || value === "toggle";
					if (value === (hidden ? "hide" : "show")) {
	
						// If there is dataShow left over from a stopped hide or show
						// and we are going to proceed with show, we should pretend to be hidden
						if (value === "show" && dataShow && dataShow[prop] !== undefined) {
							hidden = true;
						} else {
							continue;
						}
					}
					orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
	
					// Any non-fx value stops us from restoring the original display value
				} else {
					display = undefined;
				}
			}
	
			if (!jQuery.isEmptyObject(orig)) {
				if (dataShow) {
					if ("hidden" in dataShow) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access(elem, "fxshow", {});
				}
	
				// Store state if its toggle - enables .stop().toggle() to "reverse"
				if (toggle) {
					dataShow.hidden = !hidden;
				}
				if (hidden) {
					jQuery(elem).show();
				} else {
					anim.done(function () {
						jQuery(elem).hide();
					});
				}
				anim.done(function () {
					var prop;
	
					dataPriv.remove(elem, "fxshow");
					for (prop in orig) {
						jQuery.style(elem, prop, orig[prop]);
					}
				});
				for (prop in orig) {
					tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
	
					if (!(prop in dataShow)) {
						dataShow[prop] = tween.start;
						if (hidden) {
							tween.end = tween.start;
							tween.start = prop === "width" || prop === "height" ? 1 : 0;
						}
					}
				}
	
				// If this is a noop like .hide().hide(), restore an overwritten display value
			} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
				style.display = display;
			}
		}
	
		function propFilter(props, specialEasing) {
			var index, name, easing, value, hooks;
	
			// camelCase, specialEasing and expand cssHook pass
			for (index in props) {
				name = jQuery.camelCase(index);
				easing = specialEasing[name];
				value = props[index];
				if (jQuery.isArray(value)) {
					easing = value[1];
					value = props[index] = value[0];
				}
	
				if (index !== name) {
					props[name] = value;
					delete props[index];
				}
	
				hooks = jQuery.cssHooks[name];
				if (hooks && "expand" in hooks) {
					value = hooks.expand(value);
					delete props[name];
	
					// Not quite $.extend, this won't overwrite existing keys.
					// Reusing 'index' because we have the correct "name"
					for (index in value) {
						if (!(index in props)) {
							props[index] = value[index];
							specialEasing[index] = easing;
						}
					}
				} else {
					specialEasing[name] = easing;
				}
			}
		}
	
		function Animation(elem, properties, options) {
			var result,
			    stopped,
			    index = 0,
			    length = Animation.prefilters.length,
			    deferred = jQuery.Deferred().always(function () {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			}),
			    tick = function tick() {
				if (stopped) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
				    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
	
	
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				    percent = 1 - temp,
				    index = 0,
				    length = animation.tweens.length;
	
				for (; index < length; index++) {
					animation.tweens[index].run(percent);
				}
	
				deferred.notifyWith(elem, [animation, percent, remaining]);
	
				if (percent < 1 && length) {
					return remaining;
				} else {
					deferred.resolveWith(elem, [animation]);
					return false;
				}
			},
			    animation = deferred.promise({
				elem: elem,
				props: jQuery.extend({}, properties),
				opts: jQuery.extend(true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function createTween(prop, end) {
					var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
					animation.tweens.push(tween);
					return tween;
				},
				stop: function stop(gotoEnd) {
					var index = 0,
	
	
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
					if (stopped) {
						return this;
					}
					stopped = true;
					for (; index < length; index++) {
						animation.tweens[index].run(1);
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if (gotoEnd) {
						deferred.notifyWith(elem, [animation, 1, 0]);
						deferred.resolveWith(elem, [animation, gotoEnd]);
					} else {
						deferred.rejectWith(elem, [animation, gotoEnd]);
					}
					return this;
				}
			}),
			    props = animation.props;
	
			propFilter(props, animation.opts.specialEasing);
	
			for (; index < length; index++) {
				result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
				if (result) {
					if (jQuery.isFunction(result.stop)) {
						jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
					}
					return result;
				}
			}
	
			jQuery.map(props, createTween, animation);
	
			if (jQuery.isFunction(animation.opts.start)) {
				animation.opts.start.call(elem, animation);
			}
	
			jQuery.fx.timer(jQuery.extend(tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			}));
	
			// attach callbacks from options
			return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
		}
	
		jQuery.Animation = jQuery.extend(Animation, {
			tweeners: {
				"*": [function (prop, value) {
					var tween = this.createTween(prop, value);
					adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
					return tween;
				}]
			},
	
			tweener: function tweener(props, callback) {
				if (jQuery.isFunction(props)) {
					callback = props;
					props = ["*"];
				} else {
					props = props.match(rnotwhite);
				}
	
				var prop,
				    index = 0,
				    length = props.length;
	
				for (; index < length; index++) {
					prop = props[index];
					Animation.tweeners[prop] = Animation.tweeners[prop] || [];
					Animation.tweeners[prop].unshift(callback);
				}
			},
	
			prefilters: [defaultPrefilter],
	
			prefilter: function prefilter(callback, prepend) {
				if (prepend) {
					Animation.prefilters.unshift(callback);
				} else {
					Animation.prefilters.push(callback);
				}
			}
		});
	
		jQuery.speed = function (speed, easing, fn) {
			var opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
				complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
				duration: speed,
				easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
			};
	
			opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
	
			// Normalize opt.queue - true/undefined/null -> "fx"
			if (opt.queue == null || opt.queue === true) {
				opt.queue = "fx";
			}
	
			// Queueing
			opt.old = opt.complete;
	
			opt.complete = function () {
				if (jQuery.isFunction(opt.old)) {
					opt.old.call(this);
				}
	
				if (opt.queue) {
					jQuery.dequeue(this, opt.queue);
				}
			};
	
			return opt;
		};
	
		jQuery.fn.extend({
			fadeTo: function fadeTo(speed, to, easing, callback) {
	
				// Show any hidden elements after setting opacity to 0
				return this.filter(isHidden).css("opacity", 0).show()
	
				// Animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback);
			},
			animate: function animate(prop, speed, easing, callback) {
				var empty = jQuery.isEmptyObject(prop),
				    optall = jQuery.speed(speed, easing, callback),
				    doAnimation = function doAnimation() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation(this, jQuery.extend({}, prop), optall);
	
					// Empty animations, or finishing resolves immediately
					if (empty || dataPriv.get(this, "finish")) {
						anim.stop(true);
					}
				};
				doAnimation.finish = doAnimation;
	
				return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
			},
			stop: function stop(type, clearQueue, gotoEnd) {
				var stopQueue = function stopQueue(hooks) {
					var stop = hooks.stop;
					delete hooks.stop;
					stop(gotoEnd);
				};
	
				if (typeof type !== "string") {
					gotoEnd = clearQueue;
					clearQueue = type;
					type = undefined;
				}
				if (clearQueue && type !== false) {
					this.queue(type || "fx", []);
				}
	
				return this.each(function () {
					var dequeue = true,
					    index = type != null && type + "queueHooks",
					    timers = jQuery.timers,
					    data = dataPriv.get(this);
	
					if (index) {
						if (data[index] && data[index].stop) {
							stopQueue(data[index]);
						}
					} else {
						for (index in data) {
							if (data[index] && data[index].stop && rrun.test(index)) {
								stopQueue(data[index]);
							}
						}
					}
	
					for (index = timers.length; index--;) {
						if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
	
							timers[index].anim.stop(gotoEnd);
							dequeue = false;
							timers.splice(index, 1);
						}
					}
	
					// Start the next in the queue if the last step wasn't forced.
					// Timers currently will call their complete callbacks, which
					// will dequeue but only if they were gotoEnd.
					if (dequeue || !gotoEnd) {
						jQuery.dequeue(this, type);
					}
				});
			},
			finish: function finish(type) {
				if (type !== false) {
					type = type || "fx";
				}
				return this.each(function () {
					var index,
					    data = dataPriv.get(this),
					    queue = data[type + "queue"],
					    hooks = data[type + "queueHooks"],
					    timers = jQuery.timers,
					    length = queue ? queue.length : 0;
	
					// Enable finishing flag on private data
					data.finish = true;
	
					// Empty the queue first
					jQuery.queue(this, type, []);
	
					if (hooks && hooks.stop) {
						hooks.stop.call(this, true);
					}
	
					// Look for any active animations, and finish them
					for (index = timers.length; index--;) {
						if (timers[index].elem === this && timers[index].queue === type) {
							timers[index].anim.stop(true);
							timers.splice(index, 1);
						}
					}
	
					// Look for any animations in the old queue and finish them
					for (index = 0; index < length; index++) {
						if (queue[index] && queue[index].finish) {
							queue[index].finish.call(this);
						}
					}
	
					// Turn off finishing flag
					delete data.finish;
				});
			}
		});
	
		jQuery.each(["toggle", "show", "hide"], function (i, name) {
			var cssFn = jQuery.fn[name];
			jQuery.fn[name] = function (speed, easing, callback) {
				return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
			};
		});
	
		// Generate shortcuts for custom animations
		jQuery.each({
			slideDown: genFx("show"),
			slideUp: genFx("hide"),
			slideToggle: genFx("toggle"),
			fadeIn: { opacity: "show" },
			fadeOut: { opacity: "hide" },
			fadeToggle: { opacity: "toggle" }
		}, function (name, props) {
			jQuery.fn[name] = function (speed, easing, callback) {
				return this.animate(props, speed, easing, callback);
			};
		});
	
		jQuery.timers = [];
		jQuery.fx.tick = function () {
			var timer,
			    i = 0,
			    timers = jQuery.timers;
	
			fxNow = jQuery.now();
	
			for (; i < timers.length; i++) {
				timer = timers[i];
	
				// Checks the timer has not already been removed
				if (!timer() && timers[i] === timer) {
					timers.splice(i--, 1);
				}
			}
	
			if (!timers.length) {
				jQuery.fx.stop();
			}
			fxNow = undefined;
		};
	
		jQuery.fx.timer = function (timer) {
			jQuery.timers.push(timer);
			if (timer()) {
				jQuery.fx.start();
			} else {
				jQuery.timers.pop();
			}
		};
	
		jQuery.fx.interval = 13;
		jQuery.fx.start = function () {
			if (!timerId) {
				timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
			}
		};
	
		jQuery.fx.stop = function () {
			window.clearInterval(timerId);
	
			timerId = null;
		};
	
		jQuery.fx.speeds = {
			slow: 600,
			fast: 200,
	
			// Default speed
			_default: 400
		};
	
		// Based off of the plugin by Clint Helfers, with permission.
		// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
		jQuery.fn.delay = function (time, type) {
			time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
			type = type || "fx";
	
			return this.queue(type, function (next, hooks) {
				var timeout = window.setTimeout(next, time);
				hooks.stop = function () {
					window.clearTimeout(timeout);
				};
			});
		};
	
		(function () {
			var input = document.createElement("input"),
			    select = document.createElement("select"),
			    opt = select.appendChild(document.createElement("option"));
	
			input.type = "checkbox";
	
			// Support: iOS<=5.1, Android<=4.2+
			// Default value for a checkbox should be "on"
			support.checkOn = input.value !== "";
	
			// Support: IE<=11+
			// Must access selectedIndex to make default options select
			support.optSelected = opt.selected;
	
			// Support: Android<=2.3
			// Options inside disabled selects are incorrectly marked as disabled
			select.disabled = true;
			support.optDisabled = !opt.disabled;
	
			// Support: IE<=11+
			// An input loses its value after becoming a radio
			input = document.createElement("input");
			input.value = "t";
			input.type = "radio";
			support.radioValue = input.value === "t";
		})();
	
		var boolHook,
		    attrHandle = jQuery.expr.attrHandle;
	
		jQuery.fn.extend({
			attr: function attr(name, value) {
				return access(this, jQuery.attr, name, value, arguments.length > 1);
			},
	
			removeAttr: function removeAttr(name) {
				return this.each(function () {
					jQuery.removeAttr(this, name);
				});
			}
		});
	
		jQuery.extend({
			attr: function attr(elem, name, value) {
				var ret,
				    hooks,
				    nType = elem.nodeType;
	
				// Don't get/set attributes on text, comment and attribute nodes
				if (nType === 3 || nType === 8 || nType === 2) {
					return;
				}
	
				// Fallback to prop when attributes are not supported
				if (typeof elem.getAttribute === "undefined") {
					return jQuery.prop(elem, name, value);
				}
	
				// All attributes are lowercase
				// Grab necessary hook if one is defined
				if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
					name = name.toLowerCase();
					hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
				}
	
				if (value !== undefined) {
					if (value === null) {
						jQuery.removeAttr(elem, name);
						return;
					}
	
					if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
						return ret;
					}
	
					elem.setAttribute(name, value + "");
					return value;
				}
	
				if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
					return ret;
				}
	
				ret = jQuery.find.attr(elem, name);
	
				// Non-existent attributes return null, we normalize to undefined
				return ret == null ? undefined : ret;
			},
	
			attrHooks: {
				type: {
					set: function set(elem, value) {
						if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
							var val = elem.value;
							elem.setAttribute("type", value);
							if (val) {
								elem.value = val;
							}
							return value;
						}
					}
				}
			},
	
			removeAttr: function removeAttr(elem, value) {
				var name,
				    propName,
				    i = 0,
				    attrNames = value && value.match(rnotwhite);
	
				if (attrNames && elem.nodeType === 1) {
					while (name = attrNames[i++]) {
						propName = jQuery.propFix[name] || name;
	
						// Boolean attributes get special treatment (#10870)
						if (jQuery.expr.match.bool.test(name)) {
	
							// Set corresponding property to false
							elem[propName] = false;
						}
	
						elem.removeAttribute(name);
					}
				}
			}
		});
	
		// Hooks for boolean attributes
		boolHook = {
			set: function set(elem, value, name) {
				if (value === false) {
	
					// Remove boolean attributes when set to false
					jQuery.removeAttr(elem, name);
				} else {
					elem.setAttribute(name, name);
				}
				return name;
			}
		};
		jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
			var getter = attrHandle[name] || jQuery.find.attr;
	
			attrHandle[name] = function (elem, name, isXML) {
				var ret, handle;
				if (!isXML) {
	
					// Avoid an infinite loop by temporarily removing this function from the getter
					handle = attrHandle[name];
					attrHandle[name] = ret;
					ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
					attrHandle[name] = handle;
				}
				return ret;
			};
		});
	
		var rfocusable = /^(?:input|select|textarea|button)$/i,
		    rclickable = /^(?:a|area)$/i;
	
		jQuery.fn.extend({
			prop: function prop(name, value) {
				return access(this, jQuery.prop, name, value, arguments.length > 1);
			},
	
			removeProp: function removeProp(name) {
				return this.each(function () {
					delete this[jQuery.propFix[name] || name];
				});
			}
		});
	
		jQuery.extend({
			prop: function prop(elem, name, value) {
				var ret,
				    hooks,
				    nType = elem.nodeType;
	
				// Don't get/set properties on text, comment and attribute nodes
				if (nType === 3 || nType === 8 || nType === 2) {
					return;
				}
	
				if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
	
					// Fix name and attach hooks
					name = jQuery.propFix[name] || name;
					hooks = jQuery.propHooks[name];
				}
	
				if (value !== undefined) {
					if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
						return ret;
					}
	
					return elem[name] = value;
				}
	
				if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
					return ret;
				}
	
				return elem[name];
			},
	
			propHooks: {
				tabIndex: {
					get: function get(elem) {
	
						// elem.tabIndex doesn't always return the
						// correct value when it hasn't been explicitly set
						// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
						// Use proper attribute retrieval(#12072)
						var tabindex = jQuery.find.attr(elem, "tabindex");
	
						return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
					}
				}
			},
	
			propFix: {
				"for": "htmlFor",
				"class": "className"
			}
		});
	
		// Support: IE <=11 only
		// Accessing the selectedIndex property
		// forces the browser to respect setting selected
		// on the option
		// The getter ensures a default option is selected
		// when in an optgroup
		if (!support.optSelected) {
			jQuery.propHooks.selected = {
				get: function get(elem) {
					var parent = elem.parentNode;
					if (parent && parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
					return null;
				},
				set: function set(elem) {
					var parent = elem.parentNode;
					if (parent) {
						parent.selectedIndex;
	
						if (parent.parentNode) {
							parent.parentNode.selectedIndex;
						}
					}
				}
			};
		}
	
		jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
			jQuery.propFix[this.toLowerCase()] = this;
		});
	
		var rclass = /[\t\r\n\f]/g;
	
		function getClass(elem) {
			return elem.getAttribute && elem.getAttribute("class") || "";
		}
	
		jQuery.fn.extend({
			addClass: function addClass(value) {
				var classes,
				    elem,
				    cur,
				    curValue,
				    clazz,
				    j,
				    finalValue,
				    i = 0;
	
				if (jQuery.isFunction(value)) {
					return this.each(function (j) {
						jQuery(this).addClass(value.call(this, j, getClass(this)));
					});
				}
	
				if (typeof value === "string" && value) {
					classes = value.match(rnotwhite) || [];
	
					while (elem = this[i++]) {
						curValue = getClass(elem);
						cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
	
						if (cur) {
							j = 0;
							while (clazz = classes[j++]) {
								if (cur.indexOf(" " + clazz + " ") < 0) {
									cur += clazz + " ";
								}
							}
	
							// Only assign if different to avoid unneeded rendering.
							finalValue = jQuery.trim(cur);
							if (curValue !== finalValue) {
								elem.setAttribute("class", finalValue);
							}
						}
					}
				}
	
				return this;
			},
	
			removeClass: function removeClass(value) {
				var classes,
				    elem,
				    cur,
				    curValue,
				    clazz,
				    j,
				    finalValue,
				    i = 0;
	
				if (jQuery.isFunction(value)) {
					return this.each(function (j) {
						jQuery(this).removeClass(value.call(this, j, getClass(this)));
					});
				}
	
				if (!arguments.length) {
					return this.attr("class", "");
				}
	
				if (typeof value === "string" && value) {
					classes = value.match(rnotwhite) || [];
	
					while (elem = this[i++]) {
						curValue = getClass(elem);
	
						// This expression is here for better compressibility (see addClass)
						cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
	
						if (cur) {
							j = 0;
							while (clazz = classes[j++]) {
	
								// Remove *all* instances
								while (cur.indexOf(" " + clazz + " ") > -1) {
									cur = cur.replace(" " + clazz + " ", " ");
								}
							}
	
							// Only assign if different to avoid unneeded rendering.
							finalValue = jQuery.trim(cur);
							if (curValue !== finalValue) {
								elem.setAttribute("class", finalValue);
							}
						}
					}
				}
	
				return this;
			},
	
			toggleClass: function toggleClass(value, stateVal) {
				var type = typeof value === "undefined" ? "undefined" : _typeof(value);
	
				if (typeof stateVal === "boolean" && type === "string") {
					return stateVal ? this.addClass(value) : this.removeClass(value);
				}
	
				if (jQuery.isFunction(value)) {
					return this.each(function (i) {
						jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
					});
				}
	
				return this.each(function () {
					var className, i, self, classNames;
	
					if (type === "string") {
	
						// Toggle individual class names
						i = 0;
						self = jQuery(this);
						classNames = value.match(rnotwhite) || [];
	
						while (className = classNames[i++]) {
	
							// Check each className given, space separated list
							if (self.hasClass(className)) {
								self.removeClass(className);
							} else {
								self.addClass(className);
							}
						}
	
						// Toggle whole class name
					} else if (value === undefined || type === "boolean") {
						className = getClass(this);
						if (className) {
	
							// Store className if set
							dataPriv.set(this, "__className__", className);
						}
	
						// If the element has a class name or if we're passed `false`,
						// then remove the whole classname (if there was one, the above saved it).
						// Otherwise bring back whatever was previously saved (if anything),
						// falling back to the empty string if nothing was stored.
						if (this.setAttribute) {
							this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
						}
					}
				});
			},
	
			hasClass: function hasClass(selector) {
				var className,
				    elem,
				    i = 0;
	
				className = " " + selector + " ";
				while (elem = this[i++]) {
					if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
						return true;
					}
				}
	
				return false;
			}
		});
	
		var rreturn = /\r/g,
		    rspaces = /[\x20\t\r\n\f]+/g;
	
		jQuery.fn.extend({
			val: function val(value) {
				var hooks,
				    ret,
				    isFunction,
				    elem = this[0];
	
				if (!arguments.length) {
					if (elem) {
						hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
	
						if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
							return ret;
						}
	
						ret = elem.value;
	
						return typeof ret === "string" ?
	
						// Handle most common string cases
						ret.replace(rreturn, "") :
	
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
					}
	
					return;
				}
	
				isFunction = jQuery.isFunction(value);
	
				return this.each(function (i) {
					var val;
	
					if (this.nodeType !== 1) {
						return;
					}
	
					if (isFunction) {
						val = value.call(this, i, jQuery(this).val());
					} else {
						val = value;
					}
	
					// Treat null/undefined as ""; convert numbers to string
					if (val == null) {
						val = "";
					} else if (typeof val === "number") {
						val += "";
					} else if (jQuery.isArray(val)) {
						val = jQuery.map(val, function (value) {
							return value == null ? "" : value + "";
						});
					}
	
					hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
	
					// If set returns undefined, fall back to normal setting
					if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
						this.value = val;
					}
				});
			}
		});
	
		jQuery.extend({
			valHooks: {
				option: {
					get: function get(elem) {
	
						var val = jQuery.find.attr(elem, "value");
						return val != null ? val :
	
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
					}
				},
				select: {
					get: function get(elem) {
						var value,
						    option,
						    options = elem.options,
						    index = elem.selectedIndex,
						    one = elem.type === "select-one" || index < 0,
						    values = one ? null : [],
						    max = one ? index + 1 : options.length,
						    i = index < 0 ? max : one ? index : 0;
	
						// Loop through all the selected options
						for (; i < max; i++) {
							option = options[i];
	
							// IE8-9 doesn't update selected after form reset (#2551)
							if ((option.selected || i === index) && (
	
							// Don't return options that are disabled or in a disabled optgroup
							support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
	
								// Get the specific value for the option
								value = jQuery(option).val();
	
								// We don't need an array for one selects
								if (one) {
									return value;
								}
	
								// Multi-Selects return an array
								values.push(value);
							}
						}
	
						return values;
					},
	
					set: function set(elem, value) {
						var optionSet,
						    option,
						    options = elem.options,
						    values = jQuery.makeArray(value),
						    i = options.length;
	
						while (i--) {
							option = options[i];
							if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
								optionSet = true;
							}
						}
	
						// Force browsers to behave consistently when non-matching value is set
						if (!optionSet) {
							elem.selectedIndex = -1;
						}
						return values;
					}
				}
			}
		});
	
		// Radios and checkboxes getter/setter
		jQuery.each(["radio", "checkbox"], function () {
			jQuery.valHooks[this] = {
				set: function set(elem, value) {
					if (jQuery.isArray(value)) {
						return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
					}
				}
			};
			if (!support.checkOn) {
				jQuery.valHooks[this].get = function (elem) {
					return elem.getAttribute("value") === null ? "on" : elem.value;
				};
			}
		});
	
		// Return jQuery for attributes-only inclusion
	
	
		var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
	
		jQuery.extend(jQuery.event, {
	
			trigger: function trigger(event, data, elem, onlyHandlers) {
	
				var i,
				    cur,
				    tmp,
				    bubbleType,
				    ontype,
				    handle,
				    special,
				    eventPath = [elem || document],
				    type = hasOwn.call(event, "type") ? event.type : event,
				    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
	
				cur = tmp = elem = elem || document;
	
				// Don't do events on text and comment nodes
				if (elem.nodeType === 3 || elem.nodeType === 8) {
					return;
				}
	
				// focus/blur morphs to focusin/out; ensure we're not firing them right now
				if (rfocusMorph.test(type + jQuery.event.triggered)) {
					return;
				}
	
				if (type.indexOf(".") > -1) {
	
					// Namespaced trigger; create a regexp to match event type in handle()
					namespaces = type.split(".");
					type = namespaces.shift();
					namespaces.sort();
				}
				ontype = type.indexOf(":") < 0 && "on" + type;
	
				// Caller can pass in a jQuery.Event object, Object, or just an event type string
				event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);
	
				// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
				event.isTrigger = onlyHandlers ? 2 : 3;
				event.namespace = namespaces.join(".");
				event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
	
				// Clean up the event in case it is being reused
				event.result = undefined;
				if (!event.target) {
					event.target = elem;
				}
	
				// Clone any incoming data and prepend the event, creating the handler arg list
				data = data == null ? [event] : jQuery.makeArray(data, [event]);
	
				// Allow special events to draw outside the lines
				special = jQuery.event.special[type] || {};
				if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
					return;
				}
	
				// Determine event propagation path in advance, per W3C events spec (#9951)
				// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
				if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
	
					bubbleType = special.delegateType || type;
					if (!rfocusMorph.test(bubbleType + type)) {
						cur = cur.parentNode;
					}
					for (; cur; cur = cur.parentNode) {
						eventPath.push(cur);
						tmp = cur;
					}
	
					// Only add window if we got to document (e.g., not plain obj or detached DOM)
					if (tmp === (elem.ownerDocument || document)) {
						eventPath.push(tmp.defaultView || tmp.parentWindow || window);
					}
				}
	
				// Fire handlers on the event path
				i = 0;
				while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
	
					event.type = i > 1 ? bubbleType : special.bindType || type;
	
					// jQuery handler
					handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
					if (handle) {
						handle.apply(cur, data);
					}
	
					// Native handler
					handle = ontype && cur[ontype];
					if (handle && handle.apply && acceptData(cur)) {
						event.result = handle.apply(cur, data);
						if (event.result === false) {
							event.preventDefault();
						}
					}
				}
				event.type = type;
	
				// If nobody prevented the default action, do it now
				if (!onlyHandlers && !event.isDefaultPrevented()) {
	
					if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
	
						// Call a native DOM method on the target with the same name name as the event.
						// Don't do default actions on window, that's where global variables be (#6170)
						if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
	
							// Don't re-trigger an onFOO event when we call its FOO() method
							tmp = elem[ontype];
	
							if (tmp) {
								elem[ontype] = null;
							}
	
							// Prevent re-triggering of the same event, since we already bubbled it above
							jQuery.event.triggered = type;
							elem[type]();
							jQuery.event.triggered = undefined;
	
							if (tmp) {
								elem[ontype] = tmp;
							}
						}
					}
				}
	
				return event.result;
			},
	
			// Piggyback on a donor event to simulate a different one
			// Used only for `focus(in | out)` events
			simulate: function simulate(type, elem, event) {
				var e = jQuery.extend(new jQuery.Event(), event, {
					type: type,
					isSimulated: true
				});
	
				jQuery.event.trigger(e, null, elem);
			}
	
		});
	
		jQuery.fn.extend({
	
			trigger: function trigger(type, data) {
				return this.each(function () {
					jQuery.event.trigger(type, data, this);
				});
			},
			triggerHandler: function triggerHandler(type, data) {
				var elem = this[0];
				if (elem) {
					return jQuery.event.trigger(type, data, elem, true);
				}
			}
		});
	
		jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {
	
			// Handle event binding
			jQuery.fn[name] = function (data, fn) {
				return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
			};
		});
	
		jQuery.fn.extend({
			hover: function hover(fnOver, fnOut) {
				return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
			}
		});
	
		support.focusin = "onfocusin" in window;
	
		// Support: Firefox
		// Firefox doesn't have focus(in | out) events
		// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
		//
		// Support: Chrome, Safari
		// focus(in | out) events fire after focus & blur events,
		// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
		// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
		if (!support.focusin) {
			jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {
	
				// Attach a single capturing handler on the document while someone wants focusin/focusout
				var handler = function handler(event) {
					jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
				};
	
				jQuery.event.special[fix] = {
					setup: function setup() {
						var doc = this.ownerDocument || this,
						    attaches = dataPriv.access(doc, fix);
	
						if (!attaches) {
							doc.addEventListener(orig, handler, true);
						}
						dataPriv.access(doc, fix, (attaches || 0) + 1);
					},
					teardown: function teardown() {
						var doc = this.ownerDocument || this,
						    attaches = dataPriv.access(doc, fix) - 1;
	
						if (!attaches) {
							doc.removeEventListener(orig, handler, true);
							dataPriv.remove(doc, fix);
						} else {
							dataPriv.access(doc, fix, attaches);
						}
					}
				};
			});
		}
		var location = window.location;
	
		var nonce = jQuery.now();
	
		var rquery = /\?/;
	
		// Support: Android 2.3
		// Workaround failure to string-cast null input
		jQuery.parseJSON = function (data) {
			return JSON.parse(data + "");
		};
	
		// Cross-browser xml parsing
		jQuery.parseXML = function (data) {
			var xml;
			if (!data || typeof data !== "string") {
				return null;
			}
	
			// Support: IE9
			try {
				xml = new window.DOMParser().parseFromString(data, "text/xml");
			} catch (e) {
				xml = undefined;
			}
	
			if (!xml || xml.getElementsByTagName("parsererror").length) {
				jQuery.error("Invalid XML: " + data);
			}
			return xml;
		};
	
		var rhash = /#.*$/,
		    rts = /([?&])_=[^&]*/,
		    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		    rnoContent = /^(?:GET|HEAD)$/,
		    rprotocol = /^\/\//,
	
	
		/* Prefilters
	  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	  * 2) These are called:
	  *    - BEFORE asking for a transport
	  *    - AFTER param serialization (s.data is a string if s.processData is true)
	  * 3) key is the dataType
	  * 4) the catchall symbol "*" can be used
	  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	  */
		prefilters = {},
	
	
		/* Transports bindings
	  * 1) key is the dataType
	  * 2) the catchall symbol "*" can be used
	  * 3) selection will start with transport dataType and THEN go to "*" if needed
	  */
		transports = {},
	
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat("*"),
	
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement("a");
		originAnchor.href = location.href;
	
		// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
		function addToPrefiltersOrTransports(structure) {
	
			// dataTypeExpression is optional and defaults to "*"
			return function (dataTypeExpression, func) {
	
				if (typeof dataTypeExpression !== "string") {
					func = dataTypeExpression;
					dataTypeExpression = "*";
				}
	
				var dataType,
				    i = 0,
				    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
	
				if (jQuery.isFunction(func)) {
	
					// For each dataType in the dataTypeExpression
					while (dataType = dataTypes[i++]) {
	
						// Prepend if requested
						if (dataType[0] === "+") {
							dataType = dataType.slice(1) || "*";
							(structure[dataType] = structure[dataType] || []).unshift(func);
	
							// Otherwise append
						} else {
							(structure[dataType] = structure[dataType] || []).push(func);
						}
					}
				}
			};
		}
	
		// Base inspection function for prefilters and transports
		function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
	
			var inspected = {},
			    seekingTransport = structure === transports;
	
			function inspect(dataType) {
				var selected;
				inspected[dataType] = true;
				jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
					var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
					if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
	
						options.dataTypes.unshift(dataTypeOrTransport);
						inspect(dataTypeOrTransport);
						return false;
					} else if (seekingTransport) {
						return !(selected = dataTypeOrTransport);
					}
				});
				return selected;
			}
	
			return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
		}
	
		// A special extend for ajax options
		// that takes "flat" options (not to be deep extended)
		// Fixes #9887
		function ajaxExtend(target, src) {
			var key,
			    deep,
			    flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
			for (key in src) {
				if (src[key] !== undefined) {
					(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
				}
			}
			if (deep) {
				jQuery.extend(true, target, deep);
			}
	
			return target;
		}
	
		/* Handles responses to an ajax request:
	  * - finds the right dataType (mediates between content-type and expected dataType)
	  * - returns the corresponding response
	  */
		function ajaxHandleResponses(s, jqXHR, responses) {
	
			var ct,
			    type,
			    finalDataType,
			    firstDataType,
			    contents = s.contents,
			    dataTypes = s.dataTypes;
	
			// Remove auto dataType and get content-type in the process
			while (dataTypes[0] === "*") {
				dataTypes.shift();
				if (ct === undefined) {
					ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
				}
			}
	
			// Check if we're dealing with a known content-type
			if (ct) {
				for (type in contents) {
					if (contents[type] && contents[type].test(ct)) {
						dataTypes.unshift(type);
						break;
					}
				}
			}
	
			// Check to see if we have a response for the expected dataType
			if (dataTypes[0] in responses) {
				finalDataType = dataTypes[0];
			} else {
	
				// Try convertible dataTypes
				for (type in responses) {
					if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
						finalDataType = type;
						break;
					}
					if (!firstDataType) {
						firstDataType = type;
					}
				}
	
				// Or just use first one
				finalDataType = finalDataType || firstDataType;
			}
	
			// If we found a dataType
			// We add the dataType to the list if needed
			// and return the corresponding response
			if (finalDataType) {
				if (finalDataType !== dataTypes[0]) {
					dataTypes.unshift(finalDataType);
				}
				return responses[finalDataType];
			}
		}
	
		/* Chain conversions given the request and the original response
	  * Also sets the responseXXX fields on the jqXHR instance
	  */
		function ajaxConvert(s, response, jqXHR, isSuccess) {
			var conv2,
			    current,
			    conv,
			    tmp,
			    prev,
			    converters = {},
	
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
			// Create converters map with lowercased keys
			if (dataTypes[1]) {
				for (conv in s.converters) {
					converters[conv.toLowerCase()] = s.converters[conv];
				}
			}
	
			current = dataTypes.shift();
	
			// Convert to each sequential dataType
			while (current) {
	
				if (s.responseFields[current]) {
					jqXHR[s.responseFields[current]] = response;
				}
	
				// Apply the dataFilter if provided
				if (!prev && isSuccess && s.dataFilter) {
					response = s.dataFilter(response, s.dataType);
				}
	
				prev = current;
				current = dataTypes.shift();
	
				if (current) {
	
					// There's only work to do if current dataType is non-auto
					if (current === "*") {
	
						current = prev;
	
						// Convert response if prev dataType is non-auto and differs from current
					} else if (prev !== "*" && prev !== current) {
	
						// Seek a direct converter
						conv = converters[prev + " " + current] || converters["* " + current];
	
						// If none found, seek a pair
						if (!conv) {
							for (conv2 in converters) {
	
								// If conv2 outputs current
								tmp = conv2.split(" ");
								if (tmp[1] === current) {
	
									// If prev can be converted to accepted input
									conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
									if (conv) {
	
										// Condense equivalence converters
										if (conv === true) {
											conv = converters[conv2];
	
											// Otherwise, insert the intermediate dataType
										} else if (converters[conv2] !== true) {
											current = tmp[0];
											dataTypes.unshift(tmp[1]);
										}
										break;
									}
								}
							}
						}
	
						// Apply converter (if not an equivalence)
						if (conv !== true) {
	
							// Unless errors are allowed to bubble, catch and return them
							if (conv && s.throws) {
								response = conv(response);
							} else {
								try {
									response = conv(response);
								} catch (e) {
									return {
										state: "parsererror",
										error: conv ? e : "No conversion from " + prev + " to " + current
									};
								}
							}
						}
					}
				}
			}
	
			return { state: "success", data: response };
		}
	
		jQuery.extend({
	
			// Counter for holding the number of active queries
			active: 0,
	
			// Last-Modified header cache for next request
			lastModified: {},
			etag: {},
	
			ajaxSettings: {
				url: location.href,
				type: "GET",
				isLocal: rlocalProtocol.test(location.protocol),
				global: true,
				processData: true,
				async: true,
				contentType: "application/x-www-form-urlencoded; charset=UTF-8",
				/*
	   timeout: 0,
	   data: null,
	   dataType: null,
	   username: null,
	   password: null,
	   cache: null,
	   throws: false,
	   traditional: false,
	   headers: {},
	   */
	
				accepts: {
					"*": allTypes,
					text: "text/plain",
					html: "text/html",
					xml: "application/xml, text/xml",
					json: "application/json, text/javascript"
				},
	
				contents: {
					xml: /\bxml\b/,
					html: /\bhtml/,
					json: /\bjson\b/
				},
	
				responseFields: {
					xml: "responseXML",
					text: "responseText",
					json: "responseJSON"
				},
	
				// Data converters
				// Keys separate source (or catchall "*") and destination types with a single space
				converters: {
	
					// Convert anything to text
					"* text": String,
	
					// Text to html (true = no transformation)
					"text html": true,
	
					// Evaluate text as a json expression
					"text json": jQuery.parseJSON,
	
					// Parse text as xml
					"text xml": jQuery.parseXML
				},
	
				// For options that shouldn't be deep extended:
				// you can add your own custom options here if
				// and when you create one that shouldn't be
				// deep extended (see ajaxExtend)
				flatOptions: {
					url: true,
					context: true
				}
			},
	
			// Creates a full fledged settings object into target
			// with both ajaxSettings and settings fields.
			// If target is omitted, writes into ajaxSettings.
			ajaxSetup: function ajaxSetup(target, settings) {
				return settings ?
	
				// Building a settings object
				ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
	
				// Extending ajaxSettings
				ajaxExtend(jQuery.ajaxSettings, target);
			},
	
			ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
			ajaxTransport: addToPrefiltersOrTransports(transports),
	
			// Main method
			ajax: function ajax(url, options) {
	
				// If url is an object, simulate pre-1.5 signature
				if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
					options = url;
					url = undefined;
				}
	
				// Force options to be an object
				options = options || {};
	
				var transport,
	
	
				// URL without anti-cache param
				cacheURL,
	
	
				// Response headers
				responseHeadersString,
				    responseHeaders,
	
	
				// timeout handle
				timeoutTimer,
	
	
				// Url cleanup var
				urlAnchor,
	
	
				// To know if global events are to be dispatched
				fireGlobals,
	
	
				// Loop variable
				i,
	
	
				// Create the final options object
				s = jQuery.ajaxSetup({}, options),
	
	
				// Callbacks context
				callbackContext = s.context || s,
	
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
	
	
				// Deferreds
				deferred = jQuery.Deferred(),
				    completeDeferred = jQuery.Callbacks("once memory"),
	
	
				// Status-dependent callbacks
				_statusCode = s.statusCode || {},
	
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				    requestHeadersNames = {},
	
	
				// The jqXHR state
				state = 0,
	
	
				// Default abort message
				strAbort = "canceled",
	
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function getResponseHeader(key) {
						var match;
						if (state === 2) {
							if (!responseHeaders) {
								responseHeaders = {};
								while (match = rheaders.exec(responseHeadersString)) {
									responseHeaders[match[1].toLowerCase()] = match[2];
								}
							}
							match = responseHeaders[key.toLowerCase()];
						}
						return match == null ? null : match;
					},
	
					// Raw string
					getAllResponseHeaders: function getAllResponseHeaders() {
						return state === 2 ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function setRequestHeader(name, value) {
						var lname = name.toLowerCase();
						if (!state) {
							name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
							requestHeaders[name] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function overrideMimeType(type) {
						if (!state) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function statusCode(map) {
						var code;
						if (map) {
							if (state < 2) {
								for (code in map) {
	
									// Lazy-add the new callback in a way that preserves old ones
									_statusCode[code] = [_statusCode[code], map[code]];
								}
							} else {
	
								// Execute the appropriate callbacks
								jqXHR.always(map[jqXHR.status]);
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function abort(statusText) {
						var finalText = statusText || strAbort;
						if (transport) {
							transport.abort(finalText);
						}
						done(0, finalText);
						return this;
					}
				};
	
				// Attach deferreds
				deferred.promise(jqXHR).complete = completeDeferred.add;
				jqXHR.success = jqXHR.done;
				jqXHR.error = jqXHR.fail;
	
				// Remove hash character (#7531: and string promotion)
				// Add protocol if not provided (prefilters might expect it)
				// Handle falsy url in the settings object (#10093: consistency with old signature)
				// We also use the url parameter if available
				s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
	
				// Alias method option to type as per ticket #12004
				s.type = options.method || options.type || s.method || s.type;
	
				// Extract dataTypes list
				s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
	
				// A cross-domain request is in order when the origin doesn't match the current origin.
				if (s.crossDomain == null) {
					urlAnchor = document.createElement("a");
	
					// Support: IE8-11+
					// IE throws exception if url is malformed, e.g. http://example.com:80x/
					try {
						urlAnchor.href = s.url;
	
						// Support: IE8-11+
						// Anchor's host property isn't correctly set when s.url is relative
						urlAnchor.href = urlAnchor.href;
						s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
					} catch (e) {
	
						// If there is an error parsing the URL, assume it is crossDomain,
						// it can be rejected by the transport if it is invalid
						s.crossDomain = true;
					}
				}
	
				// Convert data if not already a string
				if (s.data && s.processData && typeof s.data !== "string") {
					s.data = jQuery.param(s.data, s.traditional);
				}
	
				// Apply prefilters
				inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
	
				// If request was aborted inside a prefilter, stop there
				if (state === 2) {
					return jqXHR;
				}
	
				// We can fire global events as of now if asked to
				// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
				fireGlobals = jQuery.event && s.global;
	
				// Watch for a new set of requests
				if (fireGlobals && jQuery.active++ === 0) {
					jQuery.event.trigger("ajaxStart");
				}
	
				// Uppercase the type
				s.type = s.type.toUpperCase();
	
				// Determine if request has content
				s.hasContent = !rnoContent.test(s.type);
	
				// Save the URL in case we're toying with the If-Modified-Since
				// and/or If-None-Match header later on
				cacheURL = s.url;
	
				// More options handling for requests with no content
				if (!s.hasContent) {
	
					// If data is available, append data to url
					if (s.data) {
						cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
	
						// #9682: remove data so that it's not used in an eventual retry
						delete s.data;
					}
	
					// Add anti-cache in url if needed
					if (s.cache === false) {
						s.url = rts.test(cacheURL) ?
	
						// If there is already a '_' parameter, set its value
						cacheURL.replace(rts, "$1_=" + nonce++) :
	
						// Otherwise add one to the end
						cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
					}
				}
	
				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if (s.ifModified) {
					if (jQuery.lastModified[cacheURL]) {
						jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
					}
					if (jQuery.etag[cacheURL]) {
						jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
					}
				}
	
				// Set the correct header, if data is being sent
				if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
					jqXHR.setRequestHeader("Content-Type", s.contentType);
				}
	
				// Set the Accepts header for the server, depending on the dataType
				jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
	
				// Check for headers option
				for (i in s.headers) {
					jqXHR.setRequestHeader(i, s.headers[i]);
				}
	
				// Allow custom headers/mimetypes and early abort
				if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
	
					// Abort if not done already and return
					return jqXHR.abort();
				}
	
				// Aborting is no longer a cancellation
				strAbort = "abort";
	
				// Install callbacks on deferreds
				for (i in { success: 1, error: 1, complete: 1 }) {
					jqXHR[i](s[i]);
				}
	
				// Get transport
				transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
	
				// If no transport, we auto-abort
				if (!transport) {
					done(-1, "No Transport");
				} else {
					jqXHR.readyState = 1;
	
					// Send global event
					if (fireGlobals) {
						globalEventContext.trigger("ajaxSend", [jqXHR, s]);
					}
	
					// If request was aborted inside ajaxSend, stop there
					if (state === 2) {
						return jqXHR;
					}
	
					// Timeout
					if (s.async && s.timeout > 0) {
						timeoutTimer = window.setTimeout(function () {
							jqXHR.abort("timeout");
						}, s.timeout);
					}
	
					try {
						state = 1;
						transport.send(requestHeaders, done);
					} catch (e) {
	
						// Propagate exception as error if not done
						if (state < 2) {
							done(-1, e);
	
							// Simply rethrow otherwise
						} else {
							throw e;
						}
					}
				}
	
				// Callback for when everything is done
				function done(status, nativeStatusText, responses, headers) {
					var isSuccess,
					    success,
					    error,
					    response,
					    modified,
					    statusText = nativeStatusText;
	
					// Called once
					if (state === 2) {
						return;
					}
	
					// State is "done" now
					state = 2;
	
					// Clear timeout if it exists
					if (timeoutTimer) {
						window.clearTimeout(timeoutTimer);
					}
	
					// Dereference transport for early garbage collection
					// (no matter how long the jqXHR object will be used)
					transport = undefined;
	
					// Cache response headers
					responseHeadersString = headers || "";
	
					// Set readyState
					jqXHR.readyState = status > 0 ? 4 : 0;
	
					// Determine if successful
					isSuccess = status >= 200 && status < 300 || status === 304;
	
					// Get response data
					if (responses) {
						response = ajaxHandleResponses(s, jqXHR, responses);
					}
	
					// Convert no matter what (that way responseXXX fields are always set)
					response = ajaxConvert(s, response, jqXHR, isSuccess);
	
					// If successful, handle type chaining
					if (isSuccess) {
	
						// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
						if (s.ifModified) {
							modified = jqXHR.getResponseHeader("Last-Modified");
							if (modified) {
								jQuery.lastModified[cacheURL] = modified;
							}
							modified = jqXHR.getResponseHeader("etag");
							if (modified) {
								jQuery.etag[cacheURL] = modified;
							}
						}
	
						// if no content
						if (status === 204 || s.type === "HEAD") {
							statusText = "nocontent";
	
							// if not modified
						} else if (status === 304) {
							statusText = "notmodified";
	
							// If we have data, let's convert it
						} else {
							statusText = response.state;
							success = response.data;
							error = response.error;
							isSuccess = !error;
						}
					} else {
	
						// Extract error from statusText and normalize for non-aborts
						error = statusText;
						if (status || !statusText) {
							statusText = "error";
							if (status < 0) {
								status = 0;
							}
						}
					}
	
					// Set data for the fake xhr object
					jqXHR.status = status;
					jqXHR.statusText = (nativeStatusText || statusText) + "";
	
					// Success/Error
					if (isSuccess) {
						deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
					} else {
						deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
					}
	
					// Status-dependent callbacks
					jqXHR.statusCode(_statusCode);
					_statusCode = undefined;
	
					if (fireGlobals) {
						globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
					}
	
					// Complete
					completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
	
					if (fireGlobals) {
						globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
	
						// Handle the global AJAX counter
						if (! --jQuery.active) {
							jQuery.event.trigger("ajaxStop");
						}
					}
				}
	
				return jqXHR;
			},
	
			getJSON: function getJSON(url, data, callback) {
				return jQuery.get(url, data, callback, "json");
			},
	
			getScript: function getScript(url, callback) {
				return jQuery.get(url, undefined, callback, "script");
			}
		});
	
		jQuery.each(["get", "post"], function (i, method) {
			jQuery[method] = function (url, data, callback, type) {
	
				// Shift arguments if data argument was omitted
				if (jQuery.isFunction(data)) {
					type = type || callback;
					callback = data;
					data = undefined;
				}
	
				// The url can be an options object (which then must have .url)
				return jQuery.ajax(jQuery.extend({
					url: url,
					type: method,
					dataType: type,
					data: data,
					success: callback
				}, jQuery.isPlainObject(url) && url));
			};
		});
	
		jQuery._evalUrl = function (url) {
			return jQuery.ajax({
				url: url,
	
				// Make this explicit, since user can override this through ajaxSetup (#11264)
				type: "GET",
				dataType: "script",
				async: false,
				global: false,
				"throws": true
			});
		};
	
		jQuery.fn.extend({
			wrapAll: function wrapAll(html) {
				var wrap;
	
				if (jQuery.isFunction(html)) {
					return this.each(function (i) {
						jQuery(this).wrapAll(html.call(this, i));
					});
				}
	
				if (this[0]) {
	
					// The elements to wrap the target around
					wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
	
					if (this[0].parentNode) {
						wrap.insertBefore(this[0]);
					}
	
					wrap.map(function () {
						var elem = this;
	
						while (elem.firstElementChild) {
							elem = elem.firstElementChild;
						}
	
						return elem;
					}).append(this);
				}
	
				return this;
			},
	
			wrapInner: function wrapInner(html) {
				if (jQuery.isFunction(html)) {
					return this.each(function (i) {
						jQuery(this).wrapInner(html.call(this, i));
					});
				}
	
				return this.each(function () {
					var self = jQuery(this),
					    contents = self.contents();
	
					if (contents.length) {
						contents.wrapAll(html);
					} else {
						self.append(html);
					}
				});
			},
	
			wrap: function wrap(html) {
				var isFunction = jQuery.isFunction(html);
	
				return this.each(function (i) {
					jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
				});
			},
	
			unwrap: function unwrap() {
				return this.parent().each(function () {
					if (!jQuery.nodeName(this, "body")) {
						jQuery(this).replaceWith(this.childNodes);
					}
				}).end();
			}
		});
	
		jQuery.expr.filters.hidden = function (elem) {
			return !jQuery.expr.filters.visible(elem);
		};
		jQuery.expr.filters.visible = function (elem) {
	
			// Support: Opera <= 12.12
			// Opera reports offsetWidths and offsetHeights less than zero on some elements
			// Use OR instead of AND as the element is not visible if either is true
			// See tickets #10406 and #13132
			return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
		};
	
		var r20 = /%20/g,
		    rbracket = /\[\]$/,
		    rCRLF = /\r?\n/g,
		    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		    rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
		function buildParams(prefix, obj, traditional, add) {
			var name;
	
			if (jQuery.isArray(obj)) {
	
				// Serialize array item.
				jQuery.each(obj, function (i, v) {
					if (traditional || rbracket.test(prefix)) {
	
						// Treat each array item as a scalar.
						add(prefix, v);
					} else {
	
						// Item is non-scalar (array or object), encode its numeric index.
						buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v != null ? i : "") + "]", v, traditional, add);
					}
				});
			} else if (!traditional && jQuery.type(obj) === "object") {
	
				// Serialize object item.
				for (name in obj) {
					buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
				}
			} else {
	
				// Serialize scalar item.
				add(prefix, obj);
			}
		}
	
		// Serialize an array of form elements or a set of
		// key/values into a query string
		jQuery.param = function (a, traditional) {
			var prefix,
			    s = [],
			    add = function add(key, value) {
	
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
				s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
			};
	
			// Set traditional to true for jQuery <= 1.3.2 behavior.
			if (traditional === undefined) {
				traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
			}
	
			// If an array was passed in, assume that it is an array of form elements.
			if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
	
				// Serialize the form elements
				jQuery.each(a, function () {
					add(this.name, this.value);
				});
			} else {
	
				// If traditional, encode the "old" way (the way 1.3.2 or older
				// did it), otherwise encode params recursively.
				for (prefix in a) {
					buildParams(prefix, a[prefix], traditional, add);
				}
			}
	
			// Return the resulting serialization
			return s.join("&").replace(r20, "+");
		};
	
		jQuery.fn.extend({
			serialize: function serialize() {
				return jQuery.param(this.serializeArray());
			},
			serializeArray: function serializeArray() {
				return this.map(function () {
	
					// Can add propHook for "elements" to filter or add form elements
					var elements = jQuery.prop(this, "elements");
					return elements ? jQuery.makeArray(elements) : this;
				}).filter(function () {
					var type = this.type;
	
					// Use .is( ":disabled" ) so that fieldset[disabled] works
					return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
				}).map(function (i, elem) {
					var val = jQuery(this).val();
	
					return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
						return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
					}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}).get();
			}
		});
	
		jQuery.ajaxSettings.xhr = function () {
			try {
				return new window.XMLHttpRequest();
			} catch (e) {}
		};
	
		var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		    xhrSupported = jQuery.ajaxSettings.xhr();
	
		support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
		support.ajax = xhrSupported = !!xhrSupported;
	
		jQuery.ajaxTransport(function (options) {
			var _callback, errorCallback;
	
			// Cross domain only allowed if supported through XMLHttpRequest
			if (support.cors || xhrSupported && !options.crossDomain) {
				return {
					send: function send(headers, complete) {
						var i,
						    xhr = options.xhr();
	
						xhr.open(options.type, options.url, options.async, options.username, options.password);
	
						// Apply custom fields if provided
						if (options.xhrFields) {
							for (i in options.xhrFields) {
								xhr[i] = options.xhrFields[i];
							}
						}
	
						// Override mime type if needed
						if (options.mimeType && xhr.overrideMimeType) {
							xhr.overrideMimeType(options.mimeType);
						}
	
						// X-Requested-With header
						// For cross-domain requests, seeing as conditions for a preflight are
						// akin to a jigsaw puzzle, we simply never set it to be sure.
						// (it can always be set on a per-request basis or even using ajaxSetup)
						// For same-domain requests, won't change header if already provided.
						if (!options.crossDomain && !headers["X-Requested-With"]) {
							headers["X-Requested-With"] = "XMLHttpRequest";
						}
	
						// Set headers
						for (i in headers) {
							xhr.setRequestHeader(i, headers[i]);
						}
	
						// Callback
						_callback = function callback(type) {
							return function () {
								if (_callback) {
									_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
	
									if (type === "abort") {
										xhr.abort();
									} else if (type === "error") {
	
										// Support: IE9
										// On a manual native abort, IE9 throws
										// errors on any property access that is not readyState
										if (typeof xhr.status !== "number") {
											complete(0, "error");
										} else {
											complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status, xhr.statusText);
										}
									} else {
										complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,
	
										// Support: IE9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
									}
								}
							};
						};
	
						// Listen to events
						xhr.onload = _callback();
						errorCallback = xhr.onerror = _callback("error");
	
						// Support: IE9
						// Use onreadystatechange to replace onabort
						// to handle uncaught aborts
						if (xhr.onabort !== undefined) {
							xhr.onabort = errorCallback;
						} else {
							xhr.onreadystatechange = function () {
	
								// Check readyState before timeout as it changes
								if (xhr.readyState === 4) {
	
									// Allow onerror to be called first,
									// but that will not handle a native abort
									// Also, save errorCallback to a variable
									// as xhr.onerror cannot be accessed
									window.setTimeout(function () {
										if (_callback) {
											errorCallback();
										}
									});
								}
							};
						}
	
						// Create the abort callback
						_callback = _callback("abort");
	
						try {
	
							// Do send the request (this may raise an exception)
							xhr.send(options.hasContent && options.data || null);
						} catch (e) {
	
							// #14683: Only rethrow if this hasn't been notified as an error yet
							if (_callback) {
								throw e;
							}
						}
					},
	
					abort: function abort() {
						if (_callback) {
							_callback();
						}
					}
				};
			}
		});
	
		// Install script dataType
		jQuery.ajaxSetup({
			accepts: {
				script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
			},
			contents: {
				script: /\b(?:java|ecma)script\b/
			},
			converters: {
				"text script": function textScript(text) {
					jQuery.globalEval(text);
					return text;
				}
			}
		});
	
		// Handle cache's special case and crossDomain
		jQuery.ajaxPrefilter("script", function (s) {
			if (s.cache === undefined) {
				s.cache = false;
			}
			if (s.crossDomain) {
				s.type = "GET";
			}
		});
	
		// Bind script tag hack transport
		jQuery.ajaxTransport("script", function (s) {
	
			// This transport only deals with cross domain requests
			if (s.crossDomain) {
				var script, _callback2;
				return {
					send: function send(_, complete) {
						script = jQuery("<script>").prop({
							charset: s.scriptCharset,
							src: s.url
						}).on("load error", _callback2 = function callback(evt) {
							script.remove();
							_callback2 = null;
							if (evt) {
								complete(evt.type === "error" ? 404 : 200, evt.type);
							}
						});
	
						// Use native DOM manipulation to avoid our domManip AJAX trickery
						document.head.appendChild(script[0]);
					},
					abort: function abort() {
						if (_callback2) {
							_callback2();
						}
					}
				};
			}
		});
	
		var oldCallbacks = [],
		    rjsonp = /(=)\?(?=&|$)|\?\?/;
	
		// Default jsonp settings
		jQuery.ajaxSetup({
			jsonp: "callback",
			jsonpCallback: function jsonpCallback() {
				var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
				this[callback] = true;
				return callback;
			}
		});
	
		// Detect, normalize options and install callbacks for jsonp requests
		jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
	
			var callbackName,
			    overwritten,
			    responseContainer,
			    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
	
			// Handle iff the expected data type is "jsonp" or we have a parameter to set
			if (jsonProp || s.dataTypes[0] === "jsonp") {
	
				// Get callback name, remembering preexisting value associated with it
				callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
	
				// Insert callback into url or form data
				if (jsonProp) {
					s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
				} else if (s.jsonp !== false) {
					s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
				}
	
				// Use data converter to retrieve json after script execution
				s.converters["script json"] = function () {
					if (!responseContainer) {
						jQuery.error(callbackName + " was not called");
					}
					return responseContainer[0];
				};
	
				// Force json dataType
				s.dataTypes[0] = "json";
	
				// Install callback
				overwritten = window[callbackName];
				window[callbackName] = function () {
					responseContainer = arguments;
				};
	
				// Clean-up function (fires after converters)
				jqXHR.always(function () {
	
					// If previous value didn't exist - remove it
					if (overwritten === undefined) {
						jQuery(window).removeProp(callbackName);
	
						// Otherwise restore preexisting value
					} else {
						window[callbackName] = overwritten;
					}
	
					// Save back as free
					if (s[callbackName]) {
	
						// Make sure that re-using the options doesn't screw things around
						s.jsonpCallback = originalSettings.jsonpCallback;
	
						// Save the callback name for future use
						oldCallbacks.push(callbackName);
					}
	
					// Call if it was a function and we have a response
					if (responseContainer && jQuery.isFunction(overwritten)) {
						overwritten(responseContainer[0]);
					}
	
					responseContainer = overwritten = undefined;
				});
	
				// Delegate to script
				return "script";
			}
		});
	
		// Argument "data" should be string of html
		// context (optional): If specified, the fragment will be created in this context,
		// defaults to document
		// keepScripts (optional): If true, will include scripts passed in the html string
		jQuery.parseHTML = function (data, context, keepScripts) {
			if (!data || typeof data !== "string") {
				return null;
			}
			if (typeof context === "boolean") {
				keepScripts = context;
				context = false;
			}
			context = context || document;
	
			var parsed = rsingleTag.exec(data),
			    scripts = !keepScripts && [];
	
			// Single tag
			if (parsed) {
				return [context.createElement(parsed[1])];
			}
	
			parsed = buildFragment([data], context, scripts);
	
			if (scripts && scripts.length) {
				jQuery(scripts).remove();
			}
	
			return jQuery.merge([], parsed.childNodes);
		};
	
		// Keep a copy of the old load method
		var _load = jQuery.fn.load;
	
		/**
	  * Load a url into a page
	  */
		jQuery.fn.load = function (url, params, callback) {
			if (typeof url !== "string" && _load) {
				return _load.apply(this, arguments);
			}
	
			var selector,
			    type,
			    response,
			    self = this,
			    off = url.indexOf(" ");
	
			if (off > -1) {
				selector = jQuery.trim(url.slice(off));
				url = url.slice(0, off);
			}
	
			// If it's a function
			if (jQuery.isFunction(params)) {
	
				// We assume that it's the callback
				callback = params;
				params = undefined;
	
				// Otherwise, build a param string
			} else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
				type = "POST";
			}
	
			// If we have elements to modify, make the request
			if (self.length > 0) {
				jQuery.ajax({
					url: url,
	
					// If "type" variable is undefined, then "GET" method will be used.
					// Make value of this field explicit since
					// user can override it through ajaxSetup method
					type: type || "GET",
					dataType: "html",
					data: params
				}).done(function (responseText) {
	
					// Save response for use in complete callback
					response = arguments;
	
					self.html(selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
	
					// Otherwise use the full result
					responseText);
	
					// If the request succeeds, this function gets "data", "status", "jqXHR"
					// but they are ignored because response was set above.
					// If it fails, this function gets "jqXHR", "status", "error"
				}).always(callback && function (jqXHR, status) {
					self.each(function () {
						callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
					});
				});
			}
	
			return this;
		};
	
		// Attach a bunch of functions for handling common AJAX events
		jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
			jQuery.fn[type] = function (fn) {
				return this.on(type, fn);
			};
		});
	
		jQuery.expr.filters.animated = function (elem) {
			return jQuery.grep(jQuery.timers, function (fn) {
				return elem === fn.elem;
			}).length;
		};
	
		/**
	  * Gets a window from an element
	  */
		function getWindow(elem) {
			return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
		}
	
		jQuery.offset = {
			setOffset: function setOffset(elem, options, i) {
				var curPosition,
				    curLeft,
				    curCSSTop,
				    curTop,
				    curOffset,
				    curCSSLeft,
				    calculatePosition,
				    position = jQuery.css(elem, "position"),
				    curElem = jQuery(elem),
				    props = {};
	
				// Set position first, in-case top/left are set even on static elem
				if (position === "static") {
					elem.style.position = "relative";
				}
	
				curOffset = curElem.offset();
				curCSSTop = jQuery.css(elem, "top");
				curCSSLeft = jQuery.css(elem, "left");
				calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
	
				// Need to be able to calculate position if either
				// top or left is auto and position is either absolute or fixed
				if (calculatePosition) {
					curPosition = curElem.position();
					curTop = curPosition.top;
					curLeft = curPosition.left;
				} else {
					curTop = parseFloat(curCSSTop) || 0;
					curLeft = parseFloat(curCSSLeft) || 0;
				}
	
				if (jQuery.isFunction(options)) {
	
					// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
					options = options.call(elem, i, jQuery.extend({}, curOffset));
				}
	
				if (options.top != null) {
					props.top = options.top - curOffset.top + curTop;
				}
				if (options.left != null) {
					props.left = options.left - curOffset.left + curLeft;
				}
	
				if ("using" in options) {
					options.using.call(elem, props);
				} else {
					curElem.css(props);
				}
			}
		};
	
		jQuery.fn.extend({
			offset: function offset(options) {
				if (arguments.length) {
					return options === undefined ? this : this.each(function (i) {
						jQuery.offset.setOffset(this, options, i);
					});
				}
	
				var docElem,
				    win,
				    elem = this[0],
				    box = { top: 0, left: 0 },
				    doc = elem && elem.ownerDocument;
	
				if (!doc) {
					return;
				}
	
				docElem = doc.documentElement;
	
				// Make sure it's not a disconnected DOM node
				if (!jQuery.contains(docElem, elem)) {
					return box;
				}
	
				box = elem.getBoundingClientRect();
				win = getWindow(doc);
				return {
					top: box.top + win.pageYOffset - docElem.clientTop,
					left: box.left + win.pageXOffset - docElem.clientLeft
				};
			},
	
			position: function position() {
				if (!this[0]) {
					return;
				}
	
				var offsetParent,
				    offset,
				    elem = this[0],
				    parentOffset = { top: 0, left: 0 };
	
				// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
				// because it is its only offset parent
				if (jQuery.css(elem, "position") === "fixed") {
	
					// Assume getBoundingClientRect is there when computed position is fixed
					offset = elem.getBoundingClientRect();
				} else {
	
					// Get *real* offsetParent
					offsetParent = this.offsetParent();
	
					// Get correct offsets
					offset = this.offset();
					if (!jQuery.nodeName(offsetParent[0], "html")) {
						parentOffset = offsetParent.offset();
					}
	
					// Add offsetParent borders
					parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
					parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
				}
	
				// Subtract parent offsets and element margins
				return {
					top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
					left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
				};
			},
	
			// This method will return documentElement in the following cases:
			// 1) For the element inside the iframe without offsetParent, this method will return
			//    documentElement of the parent window
			// 2) For the hidden or detached element
			// 3) For body or html element, i.e. in case of the html node - it will return itself
			//
			// but those exceptions were never presented as a real life use-cases
			// and might be considered as more preferable results.
			//
			// This logic, however, is not guaranteed and can change at any point in the future
			offsetParent: function offsetParent() {
				return this.map(function () {
					var offsetParent = this.offsetParent;
	
					while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
						offsetParent = offsetParent.offsetParent;
					}
	
					return offsetParent || documentElement;
				});
			}
		});
	
		// Create scrollLeft and scrollTop methods
		jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
			var top = "pageYOffset" === prop;
	
			jQuery.fn[method] = function (val) {
				return access(this, function (elem, method, val) {
					var win = getWindow(elem);
	
					if (val === undefined) {
						return win ? win[prop] : elem[method];
					}
	
					if (win) {
						win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
					} else {
						elem[method] = val;
					}
				}, method, val, arguments.length);
			};
		});
	
		// Support: Safari<7-8+, Chrome<37-44+
		// Add the top/left cssHooks using jQuery.fn.position
		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
		// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
		// getComputedStyle returns percent when specified for top/left/bottom/right;
		// rather than make the css module depend on the offset module, just check for it here
		jQuery.each(["top", "left"], function (i, prop) {
			jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
				if (computed) {
					computed = curCSS(elem, prop);
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
				}
			});
		});
	
		// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
		jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
			jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {
	
				// Margin is only for outerHeight, outerWidth
				jQuery.fn[funcName] = function (margin, value) {
					var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
					    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
	
					return access(this, function (elem, type, value) {
						var doc;
	
						if (jQuery.isWindow(elem)) {
	
							// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
							// isn't a whole lot we can do. See pull request at this URL for discussion:
							// https://github.com/jquery/jquery/pull/764
							return elem.document.documentElement["client" + name];
						}
	
						// Get document width or height
						if (elem.nodeType === 9) {
							doc = elem.documentElement;
	
							// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
							// whichever is greatest
							return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
						}
	
						return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css(elem, type, extra) :
	
						// Set width or height on the element
						jQuery.style(elem, type, value, extra);
					}, type, chainable ? margin : undefined, chainable, null);
				};
			});
		});
	
		jQuery.fn.extend({
	
			bind: function bind(types, data, fn) {
				return this.on(types, null, data, fn);
			},
			unbind: function unbind(types, fn) {
				return this.off(types, null, fn);
			},
	
			delegate: function delegate(selector, types, data, fn) {
				return this.on(types, selector, data, fn);
			},
			undelegate: function undelegate(selector, types, fn) {
	
				// ( namespace ) or ( selector, types [, fn] )
				return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
			},
			size: function size() {
				return this.length;
			}
		});
	
		jQuery.fn.andSelf = jQuery.fn.addBack;
	
		// Register as a named AMD module, since jQuery can be concatenated with other
		// files that may use define, but not via a proper concatenation script that
		// understands anonymous AMD modules. A named AMD is safest and most robust
		// way to register. Lowercase jquery is used because AMD module names are
		// derived from file names, and jQuery is normally delivered in a lowercase
		// file name. Do this after creating the global so that if an AMD module wants
		// to call noConflict to hide this version of jQuery, it will work.
	
		// Note that for maximum portability, libraries that are not jQuery should
		// declare themselves as anonymous modules, and avoid setting a global if an
		// AMD loader is present. jQuery is a special case. For more information, see
		// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return jQuery;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
	
		var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
		jQuery.noConflict = function (deep) {
			if (window.$ === jQuery) {
				window.$ = _$;
			}
	
			if (deep && window.jQuery === jQuery) {
				window.jQuery = _jQuery;
			}
	
			return jQuery;
		};
	
		// Expose jQuery and $ identifiers, even in AMD
		// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
		// and CommonJS for browser emulators (#13566)
		if (!noGlobal) {
			window.jQuery = window.$ = jQuery;
		}
	
		return jQuery;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../webpack/buildin/module.js */ 38)(module)))

/***/ }),
/* 4 */
/*!**************************************!*\
  !*** ./~/css-loader/lib/css-base.js ***!
  \**************************************/
/***/ (function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ }),
/* 5 */,
/* 6 */
/*!*************************************!*\
  !*** ./~/style-loader/addStyles.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(true) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 7 */,
/* 8 */
/*!*******************************!*\
  !*** ./~/prop-types/index.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	if (true) {
	  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;
	
	  var isValidElement = function isValidElement(object) {
	    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	  };
	
	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ 247)(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = require('./factoryWithThrowingShims')();
	}

/***/ }),
/* 9 */
/*!************************************!*\
  !*** ./~/underscore/underscore.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	//     Underscore.js 1.9.1
	//     http://underscorejs.org
	//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.
	
	(function () {
	
	  // Baseline setup
	  // --------------
	
	  // Establish the root object, `window` (`self`) in the browser, `global`
	  // on the server, or `this` in some virtual machines. We use `self`
	  // instead of `window` for `WebWorker` support.
	  var root = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global || this || {};
	
	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;
	
	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype,
	      ObjProto = Object.prototype;
	  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;
	
	  // Create quick reference variables for speed access to core prototypes.
	  var push = ArrayProto.push,
	      slice = ArrayProto.slice,
	      toString = ObjProto.toString,
	      hasOwnProperty = ObjProto.hasOwnProperty;
	
	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var nativeIsArray = Array.isArray,
	      nativeKeys = Object.keys,
	      nativeCreate = Object.create;
	
	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function Ctor() {};
	
	  // Create a safe reference to the Underscore object for use below.
	  var _ = function _(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };
	
	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for their old module API. If we're in
	  // the browser, add `_` as a global object.
	  // (`nodeType` is checked to ensure that `module`
	  // and `exports` are not HTML elements.)
	  if (typeof exports != 'undefined' && !exports.nodeType) {
	    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }
	
	  // Current version.
	  _.VERSION = '1.9.1';
	
	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function optimizeCb(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1:
	        return function (value) {
	          return func.call(context, value);
	        };
	      // The 2-argument case is omitted because were not using it.
	      case 3:
	        return function (value, index, collection) {
	          return func.call(context, value, index, collection);
	        };
	      case 4:
	        return function (accumulator, value, index, collection) {
	          return func.call(context, accumulator, value, index, collection);
	        };
	    }
	    return function () {
	      return func.apply(context, arguments);
	    };
	  };
	
	  var builtinIteratee;
	
	  // An internal function to generate callbacks that can be applied to each
	  // element in a collection, returning the desired result  either `identity`,
	  // an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function cb(value, context, argCount) {
	    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
	    return _.property(value);
	  };
	
	  // External wrapper for our callback generator. Users may customize
	  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
	  // This abstraction hides the internal-only argCount argument.
	  _.iteratee = builtinIteratee = function builtinIteratee(value, context) {
	    return cb(value, context, Infinity);
	  };
	
	  // Some functions take a variable number of arguments, or a few expected
	  // arguments at the beginning and then a variable number of values to operate
	  // on. This helper accumulates all remaining arguments past the functions
	  // argument length (or an explicit `startIndex`), into an array that becomes
	  // the last argument. Similar to ES6s "rest parameter".
	  var restArguments = function restArguments(func, startIndex) {
	    startIndex = startIndex == null ? func.length - 1 : +startIndex;
	    return function () {
	      var length = Math.max(arguments.length - startIndex, 0),
	          rest = Array(length),
	          index = 0;
	      for (; index < length; index++) {
	        rest[index] = arguments[index + startIndex];
	      }
	      switch (startIndex) {
	        case 0:
	          return func.call(this, rest);
	        case 1:
	          return func.call(this, arguments[0], rest);
	        case 2:
	          return func.call(this, arguments[0], arguments[1], rest);
	      }
	      var args = Array(startIndex + 1);
	      for (index = 0; index < startIndex; index++) {
	        args[index] = arguments[index];
	      }
	      args[startIndex] = rest;
	      return func.apply(this, args);
	    };
	  };
	
	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function baseCreate(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor();
	    Ctor.prototype = null;
	    return result;
	  };
	
	  var shallowProperty = function shallowProperty(key) {
	    return function (obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };
	
	  var has = function has(obj, path) {
	    return obj != null && hasOwnProperty.call(obj, path);
	  };
	
	  var deepGet = function deepGet(obj, path) {
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      if (obj == null) return void 0;
	      obj = obj[path[i]];
	    }
	    return length ? obj : void 0;
	  };
	
	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object.
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = shallowProperty('length');
	  var isArrayLike = function isArrayLike(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };
	
	  // Collection Functions
	  // --------------------
	
	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function (obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };
	
	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function (obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };
	
	  // Create a reducing function iterating left or right.
	  var createReduce = function createReduce(dir) {
	    // Wrap code that reassigns argument variables in a separate function than
	    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
	    var reducer = function reducer(obj, iteratee, memo, initial) {
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      if (!initial) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    };
	
	    return function (obj, iteratee, memo, context) {
	      var initial = arguments.length >= 3;
	      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
	    };
	  };
	
	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);
	
	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);
	
	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function (obj, predicate, context) {
	    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
	    var key = keyFinder(obj, predicate, context);
	    if (key !== void 0 && key !== -1) return obj[key];
	  };
	
	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function (obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function (value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };
	
	  // Return all the elements for which a truth test fails.
	  _.reject = function (obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };
	
	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function (obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };
	
	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function (obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };
	
	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };
	
	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = restArguments(function (obj, path, args) {
	    var contextPath, func;
	    if (_.isFunction(path)) {
	      func = path;
	    } else if (_.isArray(path)) {
	      contextPath = path.slice(0, -1);
	      path = path[path.length - 1];
	    }
	    return _.map(obj, function (context) {
	      var method = func;
	      if (!method) {
	        if (contextPath && contextPath.length) {
	          context = deepGet(context, contextPath);
	        }
	        if (context == null) return void 0;
	        method = context[path];
	      }
	      return method == null ? method : method.apply(context, args);
	    });
	  });
	
	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function (obj, key) {
	    return _.map(obj, _.property(key));
	  };
	
	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function (obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };
	
	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function (obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };
	
	  // Return the maximum element (or element-based computation).
	  _.max = function (obj, iteratee, context) {
	    var result = -Infinity,
	        lastComputed = -Infinity,
	        value,
	        computed;
	    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function (v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Return the minimum element (or element-based computation).
	  _.min = function (obj, iteratee, context) {
	    var result = Infinity,
	        lastComputed = Infinity,
	        value,
	        computed;
	    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function (v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Shuffle a collection.
	  _.shuffle = function (obj) {
	    return _.sample(obj, Infinity);
	  };
	
	  // Sample **n** random values from a collection using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function (obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
	    var length = getLength(sample);
	    n = Math.max(Math.min(n, length), 0);
	    var last = length - 1;
	    for (var index = 0; index < n; index++) {
	      var rand = _.random(index, last);
	      var temp = sample[index];
	      sample[index] = sample[rand];
	      sample[rand] = temp;
	    }
	    return sample.slice(0, n);
	  };
	
	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function (obj, iteratee, context) {
	    var index = 0;
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function (value, key, list) {
	      return {
	        value: value,
	        index: index++,
	        criteria: iteratee(value, key, list)
	      };
	    }).sort(function (left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };
	
	  // An internal function used for aggregate "group by" operations.
	  var group = function group(behavior, partition) {
	    return function (obj, iteratee, context) {
	      var result = partition ? [[], []] : {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function (value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };
	
	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function (result, value, key) {
	    if (has(result, key)) result[key].push(value);else result[key] = [value];
	  });
	
	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function (result, value, key) {
	    result[key] = value;
	  });
	
	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function (result, value, key) {
	    if (has(result, key)) result[key]++;else result[key] = 1;
	  });
	
	  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function (obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (_.isString(obj)) {
	      // Keep surrogate pair characters together
	      return obj.match(reStrSymbol);
	    }
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };
	
	  // Return the number of elements in an object.
	  _.size = function (obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };
	
	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = group(function (result, value, pass) {
	    result[pass ? 0 : 1].push(value);
	  }, true);
	
	  // Array Functions
	  // ---------------
	
	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function (array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };
	
	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function (array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };
	
	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function (array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };
	
	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function (array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };
	
	  // Trim out all falsy values from an array.
	  _.compact = function (array) {
	    return _.filter(array, Boolean);
	  };
	
	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function flatten(input, shallow, strict, output) {
	    output = output || [];
	    var idx = output.length;
	    for (var i = 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        // Flatten current level of array or arguments object.
	        if (shallow) {
	          var j = 0,
	              len = value.length;
	          while (j < len) {
	            output[idx++] = value[j++];
	          }
	        } else {
	          flatten(value, shallow, strict, output);
	          idx = output.length;
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };
	
	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function (array, shallow) {
	    return flatten(array, shallow, false);
	  };
	
	  // Return a version of the array that does not contain the specified value(s).
	  _.without = restArguments(function (array, otherArrays) {
	    return _.difference(array, otherArrays);
	  });
	
	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // The faster algorithm will not work with an iteratee if the iteratee
	  // is not a one-to-one function, so providing an iteratee will disable
	  // the faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function (array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted && !iteratee) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };
	
	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = restArguments(function (arrays) {
	    return _.uniq(flatten(arrays, true, true));
	  });
	
	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function (array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      var j;
	      for (j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };
	
	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = restArguments(function (array, rest) {
	    rest = flatten(rest, true, true);
	    return _.filter(array, function (value) {
	      return !_.contains(rest, value);
	    });
	  });
	
	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices.
	  _.unzip = function (array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);
	
	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };
	
	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = restArguments(_.unzip);
	
	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values. Passing by pairs is the reverse of _.pairs.
	  _.object = function (list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };
	
	  // Generator function to create the findIndex and findLastIndex functions.
	  var createPredicateIndexFinder = function createPredicateIndexFinder(dir) {
	    return function (array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  };
	
	  // Returns the first index on an array-like that passes a predicate test.
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);
	
	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function (array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0,
	        high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
	    }
	    return low;
	  };
	
	  // Generator function to create the indexOf and lastIndexOf functions.
	  var createIndexFinder = function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function (array, item, idx) {
	      var i = 0,
	          length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	          i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  };
	
	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
	
	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function (start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    if (!step) {
	      step = stop < start ? -1 : 1;
	    }
	
	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);
	
	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }
	
	    return range;
	  };
	
	  // Chunk a single array into multiple arrays, each containing `count` or fewer
	  // items.
	  _.chunk = function (array, count) {
	    if (count == null || count < 1) return [];
	    var result = [];
	    var i = 0,
	        length = array.length;
	    while (i < length) {
	      result.push(slice.call(array, i, i += count));
	    }
	    return result;
	  };
	
	  // Function (ahem) Functions
	  // ------------------
	
	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments.
	  var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };
	
	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = restArguments(function (func, context, args) {
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var bound = restArguments(function (callArgs) {
	      return executeBound(func, bound, context, this, args.concat(callArgs));
	    });
	    return bound;
	  });
	
	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder by default, allowing any combination of arguments to be
	  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
	  _.partial = restArguments(function (func, boundArgs) {
	    var placeholder = _.partial.placeholder;
	    var bound = function bound() {
	      var position = 0,
	          length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) {
	        args.push(arguments[position++]);
	      }return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  });
	
	  _.partial.placeholder = _;
	
	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = restArguments(function (obj, keys) {
	    keys = flatten(keys, false, false);
	    var index = keys.length;
	    if (index < 1) throw new Error('bindAll must be passed function names');
	    while (index--) {
	      var key = keys[index];
	      obj[key] = _.bind(obj[key], obj);
	    }
	  });
	
	  // Memoize an expensive function by storing its results.
	  _.memoize = function (func, hasher) {
	    var memoize = function memoize(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };
	
	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = restArguments(function (func, wait, args) {
	    return setTimeout(function () {
	      return func.apply(null, args);
	    }, wait);
	  });
	
	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);
	
	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function (func, wait, options) {
	    var timeout, context, args, result;
	    var previous = 0;
	    if (!options) options = {};
	
	    var later = function later() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	
	    var throttled = function throttled() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	
	    throttled.cancel = function () {
	      clearTimeout(timeout);
	      previous = 0;
	      timeout = context = args = null;
	    };
	
	    return throttled;
	  };
	
	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function (func, wait, immediate) {
	    var timeout, result;
	
	    var later = function later(context, args) {
	      timeout = null;
	      if (args) result = func.apply(context, args);
	    };
	
	    var debounced = restArguments(function (args) {
	      if (timeout) clearTimeout(timeout);
	      if (immediate) {
	        var callNow = !timeout;
	        timeout = setTimeout(later, wait);
	        if (callNow) result = func.apply(this, args);
	      } else {
	        timeout = _.delay(later, wait, this, args);
	      }
	
	      return result;
	    });
	
	    debounced.cancel = function () {
	      clearTimeout(timeout);
	      timeout = null;
	    };
	
	    return debounced;
	  };
	
	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function (func, wrapper) {
	    return _.partial(wrapper, func);
	  };
	
	  // Returns a negated version of the passed-in predicate.
	  _.negate = function (predicate) {
	    return function () {
	      return !predicate.apply(this, arguments);
	    };
	  };
	
	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function () {
	    var args = arguments;
	    var start = args.length - 1;
	    return function () {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) {
	        result = args[i].call(this, result);
	      }return result;
	    };
	  };
	
	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function (times, func) {
	    return function () {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };
	
	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function (times, func) {
	    var memo;
	    return function () {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };
	
	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);
	
	  _.restArguments = restArguments;
	
	  // Object Functions
	  // ----------------
	
	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
	
	  var collectNonEnumProps = function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
	
	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
	
	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  };
	
	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`.
	  _.keys = function (obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) {
	      if (has(obj, key)) keys.push(key);
	    } // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve all the property names of an object.
	  _.allKeys = function (obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) {
	      keys.push(key);
	    } // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve the values of an object's properties.
	  _.values = function (obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };
	
	  // Returns the results of applying the iteratee to each element of the object.
	  // In contrast to _.map it returns an object.
	  _.mapObject = function (obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = _.keys(obj),
	        length = keys.length,
	        results = {};
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys[index];
	      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };
	
	  // Convert an object into a list of `[key, value]` pairs.
	  // The opposite of _.object.
	  _.pairs = function (obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };
	
	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function (obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };
	
	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`.
	  _.functions = _.methods = function (obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };
	
	  // An internal function for creating assigner functions.
	  var createAssigner = function createAssigner(keysFunc, defaults) {
	    return function (obj) {
	      var length = arguments.length;
	      if (defaults) obj = Object(obj);
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!defaults || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };
	
	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);
	
	  // Assigns a given object with all the own properties in the passed-in object(s).
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);
	
	  // Returns the first key on an object that passes a predicate test.
	  _.findKey = function (obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj),
	        key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };
	
	  // Internal pick helper function to determine if `obj` has key `key`.
	  var keyInObj = function keyInObj(value, key, obj) {
	    return key in obj;
	  };
	
	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = restArguments(function (obj, keys) {
	    var result = {},
	        iteratee = keys[0];
	    if (obj == null) return result;
	    if (_.isFunction(iteratee)) {
	      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
	      keys = _.allKeys(obj);
	    } else {
	      iteratee = keyInObj;
	      keys = flatten(keys, false, false);
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  });
	
	  // Return a copy of the object without the blacklisted properties.
	  _.omit = restArguments(function (obj, keys) {
	    var iteratee = keys[0],
	        context;
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	      if (keys.length > 1) context = keys[1];
	    } else {
	      keys = _.map(flatten(keys, false, false), String);
	      iteratee = function iteratee(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  });
	
	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);
	
	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function (prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };
	
	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function (obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };
	
	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function (obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };
	
	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function (object, attrs) {
	    var keys = _.keys(attrs),
	        length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };
	
	  // Internal recursive comparison function for `isEqual`.
	  var eq, deepEq;
	  eq = function eq(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // `null` or `undefined` only equal to itself (strict comparison).
	    if (a == null || b == null) return false;
	    // `NaN`s are equivalent, but non-reflexive.
	    if (a !== a) return b !== b;
	    // Exhaust primitive checks
	    var type = typeof a === 'undefined' ? 'undefined' : _typeof(a);
	    if (type !== 'function' && type !== 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;
	    return deepEq(a, b, aStack, bStack);
	  };
	
	  // Internal recursive comparison function for `isEqual`.
	  deepEq = function deepEq(a, b, aStack, bStack) {
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN.
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	      case '[object Symbol]':
	        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
	    }
	
	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;
	
	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor,
	          bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	
	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }
	
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	
	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a),
	          key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };
	
	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function (a, b) {
	    return eq(a, b);
	  };
	
	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function (obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };
	
	  // Is a given value a DOM element?
	  _.isElement = function (obj) {
	    return !!(obj && obj.nodeType === 1);
	  };
	
	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function (obj) {
	    return toString.call(obj) === '[object Array]';
	  };
	
	  // Is a given variable an object?
	  _.isObject = function (obj) {
	    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
	    return type === 'function' || type === 'object' && !!obj;
	  };
	
	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
	    _['is' + name] = function (obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });
	
	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function (obj) {
	      return has(obj, 'callee');
	    };
	  }
	
	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
	  var nodelist = root.document && root.document.childNodes;
	  if (typeof /./ != 'function' && (typeof Int8Array === 'undefined' ? 'undefined' : _typeof(Int8Array)) != 'object' && typeof nodelist != 'function') {
	    _.isFunction = function (obj) {
	      return typeof obj == 'function' || false;
	    };
	  }
	
	  // Is a given object a finite number?
	  _.isFinite = function (obj) {
	    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
	  };
	
	  // Is the given value `NaN`?
	  _.isNaN = function (obj) {
	    return _.isNumber(obj) && isNaN(obj);
	  };
	
	  // Is a given value a boolean?
	  _.isBoolean = function (obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };
	
	  // Is a given value equal to null?
	  _.isNull = function (obj) {
	    return obj === null;
	  };
	
	  // Is a given variable undefined?
	  _.isUndefined = function (obj) {
	    return obj === void 0;
	  };
	
	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function (obj, path) {
	    if (!_.isArray(path)) {
	      return has(obj, path);
	    }
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      var key = path[i];
	      if (obj == null || !hasOwnProperty.call(obj, key)) {
	        return false;
	      }
	      obj = obj[key];
	    }
	    return !!length;
	  };
	
	  // Utility Functions
	  // -----------------
	
	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function () {
	    root._ = previousUnderscore;
	    return this;
	  };
	
	  // Keep the identity function around for default iteratees.
	  _.identity = function (value) {
	    return value;
	  };
	
	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function (value) {
	    return function () {
	      return value;
	    };
	  };
	
	  _.noop = function () {};
	
	  // Creates a function that, when passed an object, will traverse that objects
	  // properties down the given `path`, specified as an array of keys or indexes.
	  _.property = function (path) {
	    if (!_.isArray(path)) {
	      return shallowProperty(path);
	    }
	    return function (obj) {
	      return deepGet(obj, path);
	    };
	  };
	
	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function (obj) {
	    if (obj == null) {
	      return function () {};
	    }
	    return function (path) {
	      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
	    };
	  };
	
	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function (attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function (obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };
	
	  // Run a function **n** times.
	  _.times = function (n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) {
	      accum[i] = iteratee(i);
	    }return accum;
	  };
	
	  // Return a random integer between min and max (inclusive).
	  _.random = function (min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };
	
	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function () {
	    return new Date().getTime();
	  };
	
	  // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);
	
	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function createEscaper(map) {
	    var escaper = function escaper(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped.
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function (string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);
	
	  // Traverses the children of `obj` along `path`. If a child is a function, it
	  // is invoked with its parent as context. Returns the value of the final
	  // child, or `fallback` if any child is undefined.
	  _.result = function (obj, path, fallback) {
	    if (!_.isArray(path)) path = [path];
	    var length = path.length;
	    if (!length) {
	      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
	    }
	    for (var i = 0; i < length; i++) {
	      var prop = obj == null ? void 0 : obj[path[i]];
	      if (prop === void 0) {
	        prop = fallback;
	        i = length; // Ensure we don't continue iterating.
	      }
	      obj = _.isFunction(prop) ? prop.call(obj) : prop;
	    }
	    return obj;
	  };
	
	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function (prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };
	
	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate: /<%([\s\S]+?)%>/g,
	    interpolate: /<%=([\s\S]+?)%>/g,
	    escape: /<%-([\s\S]+?)%>/g
	  };
	
	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;
	
	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'": "'",
	    '\\': '\\',
	    '\r': 'r',
	    '\n': 'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
	
	  var escapeChar = function escapeChar(match) {
	    return '\\' + escapes[match];
	  };
	
	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function (text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);
	
	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');
	
	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
	      index = offset + match.length;
	
	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	
	      // Adobe VMs need the match returned to produce the correct offset.
	      return match;
	    });
	    source += "';\n";
	
	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
	
	    var render;
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }
	
	    var template = function template(data) {
	      return render.call(this, data, _);
	    };
	
	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';
	
	    return template;
	  };
	
	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function (obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };
	
	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.
	
	  // Helper function to continue chaining intermediate results.
	  var chainResult = function chainResult(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };
	
	  // Add your own custom functions to the Underscore object.
	  _.mixin = function (obj) {
	    _.each(_.functions(obj), function (name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function () {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return chainResult(this, func.apply(_, args));
	      };
	    });
	    return _;
	  };
	
	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);
	
	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function () {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return chainResult(this, obj);
	    };
	  });
	
	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function (name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function () {
	      return chainResult(this, method.apply(this._wrapped, arguments));
	    };
	  });
	
	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function () {
	    return this._wrapped;
	  };
	
	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
	
	  _.prototype.toString = function () {
	    return String(this._wrapped);
	  };
	
	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./../webpack/buildin/module.js */ 38)(module)))

/***/ }),
/* 10 */
/*!**********************************!*\
  !*** ./~/react-mdl/lib/index.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	Object.defineProperty(exports, 'mdlUpgrade', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_mdlUpgrade).default;
	    }
	});
	
	var _MDLComponent = __webpack_require__(/*! ./utils/MDLComponent */ 78);
	
	Object.defineProperty(exports, 'MDLComponent', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_MDLComponent).default;
	    }
	});
	
	var _palette = __webpack_require__(/*! ./utils/palette */ 292);
	
	Object.defineProperty(exports, 'getColorClass', {
	    enumerable: true,
	    get: function get() {
	        return _palette.getColorClass;
	    }
	});
	Object.defineProperty(exports, 'getTextColorClass', {
	    enumerable: true,
	    get: function get() {
	        return _palette.getTextColorClass;
	    }
	});
	
	var _Badge = __webpack_require__(/*! ./Badge */ 248);
	
	Object.defineProperty(exports, 'Badge', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Badge).default;
	    }
	});
	
	var _Button = __webpack_require__(/*! ./Button */ 75);
	
	Object.defineProperty(exports, 'Button', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Button).default;
	    }
	});
	
	var _Card = __webpack_require__(/*! ./Card */ 252);
	
	Object.defineProperty(exports, 'Card', {
	    enumerable: true,
	    get: function get() {
	        return _Card.Card;
	    }
	});
	Object.defineProperty(exports, 'CardTitle', {
	    enumerable: true,
	    get: function get() {
	        return _Card.CardTitle;
	    }
	});
	Object.defineProperty(exports, 'CardActions', {
	    enumerable: true,
	    get: function get() {
	        return _Card.CardActions;
	    }
	});
	Object.defineProperty(exports, 'CardMedia', {
	    enumerable: true,
	    get: function get() {
	        return _Card.CardMedia;
	    }
	});
	Object.defineProperty(exports, 'CardText', {
	    enumerable: true,
	    get: function get() {
	        return _Card.CardText;
	    }
	});
	Object.defineProperty(exports, 'CardMenu', {
	    enumerable: true,
	    get: function get() {
	        return _Card.CardMenu;
	    }
	});
	
	var _Checkbox = __webpack_require__(/*! ./Checkbox */ 125);
	
	Object.defineProperty(exports, 'Checkbox', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Checkbox).default;
	    }
	});
	
	var _Chip = __webpack_require__(/*! ./Chip */ 253);
	
	Object.defineProperty(exports, 'Chip', {
	    enumerable: true,
	    get: function get() {
	        return _Chip.Chip;
	    }
	});
	Object.defineProperty(exports, 'ChipContact', {
	    enumerable: true,
	    get: function get() {
	        return _Chip.ChipContact;
	    }
	});
	
	var _DataTable = __webpack_require__(/*! ./DataTable */ 257);
	
	Object.defineProperty(exports, 'DataTable', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_DataTable).default;
	    }
	});
	Object.defineProperty(exports, 'Table', {
	    enumerable: true,
	    get: function get() {
	        return _DataTable.Table;
	    }
	});
	Object.defineProperty(exports, 'TableHeader', {
	    enumerable: true,
	    get: function get() {
	        return _DataTable.TableHeader;
	    }
	});
	
	var _Dialog = __webpack_require__(/*! ./Dialog */ 261);
	
	Object.defineProperty(exports, 'Dialog', {
	    enumerable: true,
	    get: function get() {
	        return _Dialog.Dialog;
	    }
	});
	Object.defineProperty(exports, 'DialogTitle', {
	    enumerable: true,
	    get: function get() {
	        return _Dialog.DialogTitle;
	    }
	});
	Object.defineProperty(exports, 'DialogContent', {
	    enumerable: true,
	    get: function get() {
	        return _Dialog.DialogContent;
	    }
	});
	Object.defineProperty(exports, 'DialogActions', {
	    enumerable: true,
	    get: function get() {
	        return _Dialog.DialogActions;
	    }
	});
	
	var _FABButton = __webpack_require__(/*! ./FABButton */ 262);
	
	Object.defineProperty(exports, 'FABButton', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_FABButton).default;
	    }
	});
	
	var _Footer = __webpack_require__(/*! ./Footer */ 267);
	
	Object.defineProperty(exports, 'Footer', {
	    enumerable: true,
	    get: function get() {
	        return _Footer.Footer;
	    }
	});
	Object.defineProperty(exports, 'FooterSection', {
	    enumerable: true,
	    get: function get() {
	        return _Footer.FooterSection;
	    }
	});
	Object.defineProperty(exports, 'FooterDropDownSection', {
	    enumerable: true,
	    get: function get() {
	        return _Footer.FooterDropDownSection;
	    }
	});
	Object.defineProperty(exports, 'FooterLinkList', {
	    enumerable: true,
	    get: function get() {
	        return _Footer.FooterLinkList;
	    }
	});
	
	var _Grid = __webpack_require__(/*! ./Grid */ 270);
	
	Object.defineProperty(exports, 'Grid', {
	    enumerable: true,
	    get: function get() {
	        return _Grid.Grid;
	    }
	});
	Object.defineProperty(exports, 'Cell', {
	    enumerable: true,
	    get: function get() {
	        return _Grid.Cell;
	    }
	});
	
	var _Icon = __webpack_require__(/*! ./Icon */ 37);
	
	Object.defineProperty(exports, 'Icon', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Icon).default;
	    }
	});
	
	var _IconButton = __webpack_require__(/*! ./IconButton */ 271);
	
	Object.defineProperty(exports, 'IconButton', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_IconButton).default;
	    }
	});
	
	var _IconToggle = __webpack_require__(/*! ./IconToggle */ 272);
	
	Object.defineProperty(exports, 'IconToggle', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_IconToggle).default;
	    }
	});
	
	var _Layout = __webpack_require__(/*! ./Layout */ 278);
	
	Object.defineProperty(exports, 'Layout', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.Layout;
	    }
	});
	Object.defineProperty(exports, 'Header', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.Header;
	    }
	});
	Object.defineProperty(exports, 'Drawer', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.Drawer;
	    }
	});
	Object.defineProperty(exports, 'HeaderRow', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.HeaderRow;
	    }
	});
	Object.defineProperty(exports, 'HeaderTabs', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.HeaderTabs;
	    }
	});
	Object.defineProperty(exports, 'Spacer', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.Spacer;
	    }
	});
	Object.defineProperty(exports, 'Navigation', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.Navigation;
	    }
	});
	Object.defineProperty(exports, 'Content', {
	    enumerable: true,
	    get: function get() {
	        return _Layout.Content;
	    }
	});
	
	var _List = __webpack_require__(/*! ./List */ 281);
	
	Object.defineProperty(exports, 'List', {
	    enumerable: true,
	    get: function get() {
	        return _List.List;
	    }
	});
	Object.defineProperty(exports, 'ListItem', {
	    enumerable: true,
	    get: function get() {
	        return _List.ListItem;
	    }
	});
	Object.defineProperty(exports, 'ListItemAction', {
	    enumerable: true,
	    get: function get() {
	        return _List.ListItemAction;
	    }
	});
	Object.defineProperty(exports, 'ListItemContent', {
	    enumerable: true,
	    get: function get() {
	        return _List.ListItemContent;
	    }
	});
	
	var _Menu = __webpack_require__(/*! ./Menu */ 282);
	
	Object.defineProperty(exports, 'Menu', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Menu).default;
	    }
	});
	Object.defineProperty(exports, 'MenuItem', {
	    enumerable: true,
	    get: function get() {
	        return _Menu.MenuItem;
	    }
	});
	
	var _ProgressBar = __webpack_require__(/*! ./ProgressBar */ 283);
	
	Object.defineProperty(exports, 'ProgressBar', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_ProgressBar).default;
	    }
	});
	
	var _Radio = __webpack_require__(/*! ./Radio */ 129);
	
	Object.defineProperty(exports, 'Radio', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Radio).default;
	    }
	});
	
	var _RadioGroup = __webpack_require__(/*! ./RadioGroup */ 284);
	
	Object.defineProperty(exports, 'RadioGroup', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_RadioGroup).default;
	    }
	});
	
	var _Slider = __webpack_require__(/*! ./Slider */ 285);
	
	Object.defineProperty(exports, 'Slider', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Slider).default;
	    }
	});
	
	var _Snackbar = __webpack_require__(/*! ./Snackbar */ 286);
	
	Object.defineProperty(exports, 'Snackbar', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Snackbar).default;
	    }
	});
	
	var _Spinner = __webpack_require__(/*! ./Spinner */ 287);
	
	Object.defineProperty(exports, 'Spinner', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Spinner).default;
	    }
	});
	
	var _Switch = __webpack_require__(/*! ./Switch */ 288);
	
	Object.defineProperty(exports, 'Switch', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Switch).default;
	    }
	});
	
	var _Tabs = __webpack_require__(/*! ./Tabs */ 290);
	
	Object.defineProperty(exports, 'Tabs', {
	    enumerable: true,
	    get: function get() {
	        return _Tabs.Tabs;
	    }
	});
	Object.defineProperty(exports, 'Tab', {
	    enumerable: true,
	    get: function get() {
	        return _Tabs.Tab;
	    }
	});
	Object.defineProperty(exports, 'TabBar', {
	    enumerable: true,
	    get: function get() {
	        return _Tabs.TabBar;
	    }
	});
	
	var _Textfield = __webpack_require__(/*! ./Textfield */ 291);
	
	Object.defineProperty(exports, 'Textfield', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Textfield).default;
	    }
	});
	
	var _Tooltip = __webpack_require__(/*! ./Tooltip */ 131);
	
	Object.defineProperty(exports, 'Tooltip', {
	    enumerable: true,
	    get: function get() {
	        return _interopRequireDefault(_Tooltip).default;
	    }
	});
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

/***/ }),
/* 11 */
/*!***************************!*\
  !*** external "ReactDOM" ***!
  \***************************/
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

/***/ }),
/* 12 */,
/* 13 */
/*!************************************************!*\
  !*** ./~/fixed-data-table-2/internal/React.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	module.exports = __webpack_require__(/*! react */ 1);

/***/ }),
/* 14 */
/*!*********************************************!*\
  !*** ./~/react-mdl/lib/utils/mdlUpgrade.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var React = _interopRequireWildcard(_react);
	
	var _MDLComponent = __webpack_require__(/*! ./MDLComponent */ 78);
	
	var _MDLComponent2 = _interopRequireDefault(_MDLComponent);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	        return obj;
	    } else {
	        var newObj = {};if (obj != null) {
	            for (var key in obj) {
	                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	            }
	        }newObj.default = obj;return newObj;
	    }
	}
	
	function patchComponentClass(Component, recursive) {
	    var oldRender = Component.prototype.render;
	
	    Component.prototype.render = function render() {
	        // eslint-disable-line no-param-reassign
	        return React.createElement(_MDLComponent2.default, { recursive: recursive }, oldRender.call(this));
	    };
	
	    return Component;
	}
	
	function patchSFC(component, recursive) {
	    var patchedComponent = function patchedComponent(props) {
	        return React.createElement(_MDLComponent2.default, { recursive: recursive }, component(props));
	    };
	
	    // Attempt to change the function name for easier debugging, but don't die
	    // if the browser doesn't support it
	    try {
	        Object.defineProperty(patchedComponent, 'name', {
	            value: component.name
	        });
	    } catch (e) {} // eslint-disable-line no-empty
	
	    return patchedComponent;
	}
	
	exports.default = function (Component) {
	    var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    return Component.prototype && Component.prototype.isReactComponent ? patchComponentClass(Component, recursive) : patchSFC(Component, recursive);
	};

/***/ }),
/* 15 */
/*!********************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/instances.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../lib/helper */ 17);
	var cls = __webpack_require__(/*! ../lib/class */ 49);
	var defaultSettings = __webpack_require__(/*! ./default-setting */ 234);
	var dom = __webpack_require__(/*! ../lib/dom */ 24);
	var EventManager = __webpack_require__(/*! ../lib/event-manager */ 231);
	var guid = __webpack_require__(/*! ../lib/guid */ 232);
	
	var instances = {};
	
	function Instance(element) {
	  var i = this;
	
	  i.settings = _.clone(defaultSettings);
	  i.containerWidth = null;
	  i.containerHeight = null;
	  i.contentWidth = null;
	  i.contentHeight = null;
	
	  i.isRtl = dom.css(element, 'direction') === "rtl";
	  i.isNegativeScroll = function () {
	    var originalScrollLeft = element.scrollLeft;
	    var result = null;
	    element.scrollLeft = -1;
	    result = element.scrollLeft < 0;
	    element.scrollLeft = originalScrollLeft;
	    return result;
	  }();
	  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
	  i.event = new EventManager();
	  i.ownerDocument = element.ownerDocument || document;
	
	  function focus() {
	    cls.add(element, 'ps-focus');
	  }
	
	  function blur() {
	    cls.remove(element, 'ps-focus');
	  }
	
	  i.scrollbarXRail = dom.appendTo(dom.e('div', 'ps-scrollbar-x-rail'), element);
	  i.scrollbarX = dom.appendTo(dom.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
	  i.scrollbarX.setAttribute('tabindex', 0);
	  i.event.bind(i.scrollbarX, 'focus', focus);
	  i.event.bind(i.scrollbarX, 'blur', blur);
	  i.scrollbarXActive = null;
	  i.scrollbarXWidth = null;
	  i.scrollbarXLeft = null;
	  i.scrollbarXBottom = _.toInt(dom.css(i.scrollbarXRail, 'bottom'));
	  i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
	  i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : _.toInt(dom.css(i.scrollbarXRail, 'top'));
	  i.railBorderXWidth = _.toInt(dom.css(i.scrollbarXRail, 'borderLeftWidth')) + _.toInt(dom.css(i.scrollbarXRail, 'borderRightWidth'));
	  // Set rail to display:block to calculate margins
	  dom.css(i.scrollbarXRail, 'display', 'block');
	  i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
	  dom.css(i.scrollbarXRail, 'display', '');
	  i.railXWidth = null;
	  i.railXRatio = null;
	
	  i.scrollbarYRail = dom.appendTo(dom.e('div', 'ps-scrollbar-y-rail'), element);
	  i.scrollbarY = dom.appendTo(dom.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
	  i.scrollbarY.setAttribute('tabindex', 0);
	  i.event.bind(i.scrollbarY, 'focus', focus);
	  i.event.bind(i.scrollbarY, 'blur', blur);
	  i.scrollbarYActive = null;
	  i.scrollbarYHeight = null;
	  i.scrollbarYTop = null;
	  i.scrollbarYRight = _.toInt(dom.css(i.scrollbarYRail, 'right'));
	  i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
	  i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : _.toInt(dom.css(i.scrollbarYRail, 'left'));
	  i.scrollbarYOuterWidth = i.isRtl ? _.outerWidth(i.scrollbarY) : null;
	  i.railBorderYWidth = _.toInt(dom.css(i.scrollbarYRail, 'borderTopWidth')) + _.toInt(dom.css(i.scrollbarYRail, 'borderBottomWidth'));
	  dom.css(i.scrollbarYRail, 'display', 'block');
	  i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));
	  dom.css(i.scrollbarYRail, 'display', '');
	  i.railYHeight = null;
	  i.railYRatio = null;
	}
	
	function getId(element) {
	  return element.getAttribute('data-ps-id');
	}
	
	function setId(element, id) {
	  element.setAttribute('data-ps-id', id);
	}
	
	function removeId(element) {
	  element.removeAttribute('data-ps-id');
	}
	
	exports.add = function (element) {
	  var newId = guid();
	  setId(element, newId);
	  instances[newId] = new Instance(element);
	  return instances[newId];
	};
	
	exports.remove = function (element) {
	  delete instances[getId(element)];
	  removeId(element);
	};
	
	exports.get = function (element) {
	  return instances[getId(element)];
	};

/***/ }),
/* 16 */
/*!*********************************************!*\
  !*** ./~/fixed-data-table-2/internal/cx.js ***!
  \*********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule cx
	 */
	
	var slashReplaceRegex = /\//g;
	var cache = {};
	
	function getClassName(className) {
	  if (cache[className]) {
	    return cache[className];
	  }
	
	  cache[className] = className.replace(slashReplaceRegex, '_');
	  return cache[className];
	}
	
	/**
	 * This function is used to mark string literals representing CSS class names
	 * so that they can be transformed statically. This allows for modularization
	 * and minification of CSS class names.
	 *
	 * In static_upstream, this function is actually implemented, but it should
	 * eventually be replaced with something more descriptive, and the transform
	 * that is used in the main stack should be ported for use elsewhere.
	 *
	 * @param string|object className to modularize, or an object of key/values.
	 *                      In the object case, the values are conditions that
	 *                      determine if the className keys should be included.
	 * @param [string ...]  Variable list of classNames in the string case.
	 * @return string       Renderable space-separated CSS className.
	 */
	function cx(classNames) {
	  var classNamesArray;
	  if ((typeof classNames === 'undefined' ? 'undefined' : _typeof(classNames)) == 'object') {
	    classNamesArray = Object.keys(classNames).filter(function (className) {
	      return classNames[className];
	    });
	  } else {
	    classNamesArray = Array.prototype.slice.call(arguments);
	  }
	
	  return classNamesArray.map(getClassName).join(' ');
	}
	
	module.exports = cx;

/***/ }),
/* 17 */
/*!**************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/lib/helper.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var cls = __webpack_require__(/*! ./class */ 49);
	var dom = __webpack_require__(/*! ./dom */ 24);
	
	var toInt = exports.toInt = function (x) {
	  return parseInt(x, 10) || 0;
	};
	
	var clone = exports.clone = function (obj) {
	  if (!obj) {
	    return null;
	  } else if (obj.constructor === Array) {
	    return obj.map(clone);
	  } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    var result = {};
	    for (var key in obj) {
	      result[key] = clone(obj[key]);
	    }
	    return result;
	  } else {
	    return obj;
	  }
	};
	
	exports.extend = function (original, source) {
	  var result = clone(original);
	  for (var key in source) {
	    result[key] = clone(source[key]);
	  }
	  return result;
	};
	
	exports.isEditable = function (el) {
	  return dom.matches(el, "input,[contenteditable]") || dom.matches(el, "select,[contenteditable]") || dom.matches(el, "textarea,[contenteditable]") || dom.matches(el, "button,[contenteditable]");
	};
	
	exports.removePsClasses = function (element) {
	  var clsList = cls.list(element);
	  for (var i = 0; i < clsList.length; i++) {
	    var className = clsList[i];
	    if (className.indexOf('ps-') === 0) {
	      cls.remove(element, className);
	    }
	  }
	};
	
	exports.outerWidth = function (element) {
	  return toInt(dom.css(element, 'width')) + toInt(dom.css(element, 'paddingLeft')) + toInt(dom.css(element, 'paddingRight')) + toInt(dom.css(element, 'borderLeftWidth')) + toInt(dom.css(element, 'borderRightWidth'));
	};
	
	exports.startScrolling = function (element, axis) {
	  cls.add(element, 'ps-in-scrolling');
	  if (typeof axis !== 'undefined') {
	    cls.add(element, 'ps-' + axis);
	  } else {
	    cls.add(element, 'ps-x');
	    cls.add(element, 'ps-y');
	  }
	};
	
	exports.stopScrolling = function (element, axis) {
	  cls.remove(element, 'ps-in-scrolling');
	  if (typeof axis !== 'undefined') {
	    cls.remove(element, 'ps-' + axis);
	  } else {
	    cls.remove(element, 'ps-x');
	    cls.remove(element, 'ps-y');
	  }
	};
	
	exports.env = {
	  isWebKit: 'WebkitAppearance' in document.documentElement.style,
	  supportsTouch: 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,
	  supportsIePointer: window.navigator.msMaxTouchPoints !== null
	};

/***/ }),
/* 18 */
/*!**************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/update-geometry.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../lib/helper */ 17);
	var cls = __webpack_require__(/*! ../lib/class */ 49);
	var dom = __webpack_require__(/*! ../lib/dom */ 24);
	var instances = __webpack_require__(/*! ./instances */ 15);
	var updateScroll = __webpack_require__(/*! ./update-scroll */ 20);
	
	function getThumbSize(i, thumbSize) {
	  if (i.settings.minScrollbarLength) {
	    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
	  }
	  if (i.settings.maxScrollbarLength) {
	    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
	  }
	  return thumbSize;
	}
	
	function updateCss(element, i) {
	  var xRailOffset = { width: i.railXWidth };
	  if (i.isRtl) {
	    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
	  } else {
	    xRailOffset.left = element.scrollLeft;
	  }
	  if (i.isScrollbarXUsingBottom) {
	    xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
	  } else {
	    xRailOffset.top = i.scrollbarXTop + element.scrollTop;
	  }
	  dom.css(i.scrollbarXRail, xRailOffset);
	
	  var yRailOffset = { top: element.scrollTop, height: i.railYHeight };
	  if (i.isScrollbarYUsingRight) {
	    if (i.isRtl) {
	      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
	    } else {
	      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
	    }
	  } else {
	    if (i.isRtl) {
	      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
	    } else {
	      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
	    }
	  }
	  dom.css(i.scrollbarYRail, yRailOffset);
	
	  dom.css(i.scrollbarX, { left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth });
	  dom.css(i.scrollbarY, { top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth });
	}
	
	module.exports = function (element) {
	  var i = instances.get(element);
	
	  i.containerWidth = element.clientWidth;
	  i.containerHeight = element.clientHeight;
	  i.contentWidth = element.scrollWidth;
	  i.contentHeight = element.scrollHeight;
	
	  var existingRails;
	  if (!element.contains(i.scrollbarXRail)) {
	    existingRails = dom.queryChildren(element, '.ps-scrollbar-x-rail');
	    if (existingRails.length > 0) {
	      existingRails.forEach(function (rail) {
	        dom.remove(rail);
	      });
	    }
	    dom.appendTo(i.scrollbarXRail, element);
	  }
	  if (!element.contains(i.scrollbarYRail)) {
	    existingRails = dom.queryChildren(element, '.ps-scrollbar-y-rail');
	    if (existingRails.length > 0) {
	      existingRails.forEach(function (rail) {
	        dom.remove(rail);
	      });
	    }
	    dom.appendTo(i.scrollbarYRail, element);
	  }
	
	  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
	    i.scrollbarXActive = true;
	    i.railXWidth = i.containerWidth - i.railXMarginWidth;
	    i.railXRatio = i.containerWidth / i.railXWidth;
	    i.scrollbarXWidth = getThumbSize(i, _.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
	    i.scrollbarXLeft = _.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
	  } else {
	    i.scrollbarXActive = false;
	  }
	
	  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
	    i.scrollbarYActive = true;
	    i.railYHeight = i.containerHeight - i.railYMarginHeight;
	    i.railYRatio = i.containerHeight / i.railYHeight;
	    i.scrollbarYHeight = getThumbSize(i, _.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
	    i.scrollbarYTop = _.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
	  } else {
	    i.scrollbarYActive = false;
	  }
	
	  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
	    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
	  }
	  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
	    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
	  }
	
	  updateCss(element, i);
	
	  if (i.scrollbarXActive) {
	    cls.add(element, 'ps-active-x');
	  } else {
	    cls.remove(element, 'ps-active-x');
	    i.scrollbarXWidth = 0;
	    i.scrollbarXLeft = 0;
	    updateScroll(element, 'left', 0);
	  }
	  if (i.scrollbarYActive) {
	    cls.add(element, 'ps-active-y');
	  } else {
	    cls.remove(element, 'ps-active-y');
	    i.scrollbarYHeight = 0;
	    i.scrollbarYTop = 0;
	    updateScroll(element, 'top', 0);
	  }
	};

/***/ }),
/* 19 */
/*!********************************!*\
  !*** ./~/jquery-ui/ui/core.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/*!
	 * jQuery UI Core 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/category/ui-core/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
	
		// $.ui might exist from components with no dependencies, e.g., $.ui.position
		$.ui = $.ui || {};
	
		$.extend($.ui, {
			version: "1.11.4",
	
			keyCode: {
				BACKSPACE: 8,
				COMMA: 188,
				DELETE: 46,
				DOWN: 40,
				END: 35,
				ENTER: 13,
				ESCAPE: 27,
				HOME: 36,
				LEFT: 37,
				PAGE_DOWN: 34,
				PAGE_UP: 33,
				PERIOD: 190,
				RIGHT: 39,
				SPACE: 32,
				TAB: 9,
				UP: 38
			}
		});
	
		// plugins
		$.fn.extend({
			scrollParent: function scrollParent(includeHidden) {
				var position = this.css("position"),
				    excludeStaticParent = position === "absolute",
				    overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
				    scrollParent = this.parents().filter(function () {
					var parent = $(this);
					if (excludeStaticParent && parent.css("position") === "static") {
						return false;
					}
					return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
				}).eq(0);
	
				return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
			},
	
			uniqueId: function () {
				var uuid = 0;
	
				return function () {
					return this.each(function () {
						if (!this.id) {
							this.id = "ui-id-" + ++uuid;
						}
					});
				};
			}(),
	
			removeUniqueId: function removeUniqueId() {
				return this.each(function () {
					if (/^ui-id-\d+$/.test(this.id)) {
						$(this).removeAttr("id");
					}
				});
			}
		});
	
		// selectors
		function _focusable(element, isTabIndexNotNaN) {
			var map,
			    mapName,
			    img,
			    nodeName = element.nodeName.toLowerCase();
			if ("area" === nodeName) {
				map = element.parentNode;
				mapName = map.name;
				if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
					return false;
				}
				img = $("img[usemap='#" + mapName + "']")[0];
				return !!img && visible(img);
			}
			return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) &&
			// the element and all of its ancestors must be visible
			visible(element);
		}
	
		function visible(element) {
			return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
				return $.css(this, "visibility") === "hidden";
			}).length;
		}
	
		$.extend($.expr[":"], {
			data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
				return function (elem) {
					return !!$.data(elem, dataName);
				};
			}) :
			// support: jQuery <1.8
			function (elem, i, match) {
				return !!$.data(elem, match[3]);
			},
	
			focusable: function focusable(element) {
				return _focusable(element, !isNaN($.attr(element, "tabindex")));
			},
	
			tabbable: function tabbable(element) {
				var tabIndex = $.attr(element, "tabindex"),
				    isTabIndexNaN = isNaN(tabIndex);
				return (isTabIndexNaN || tabIndex >= 0) && _focusable(element, !isTabIndexNaN);
			}
		});
	
		// support: jQuery <1.8
		if (!$("<a>").outerWidth(1).jquery) {
			$.each(["Width", "Height"], function (i, name) {
				var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
				    type = name.toLowerCase(),
				    orig = {
					innerWidth: $.fn.innerWidth,
					innerHeight: $.fn.innerHeight,
					outerWidth: $.fn.outerWidth,
					outerHeight: $.fn.outerHeight
				};
	
				function reduce(elem, size, border, margin) {
					$.each(side, function () {
						size -= parseFloat($.css(elem, "padding" + this)) || 0;
						if (border) {
							size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
						}
						if (margin) {
							size -= parseFloat($.css(elem, "margin" + this)) || 0;
						}
					});
					return size;
				}
	
				$.fn["inner" + name] = function (size) {
					if (size === undefined) {
						return orig["inner" + name].call(this);
					}
	
					return this.each(function () {
						$(this).css(type, reduce(this, size) + "px");
					});
				};
	
				$.fn["outer" + name] = function (size, margin) {
					if (typeof size !== "number") {
						return orig["outer" + name].call(this, size);
					}
	
					return this.each(function () {
						$(this).css(type, reduce(this, size, true, margin) + "px");
					});
				};
			});
		}
	
		// support: jQuery <1.8
		if (!$.fn.addBack) {
			$.fn.addBack = function (selector) {
				return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
			};
		}
	
		// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
		if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
			$.fn.removeData = function (removeData) {
				return function (key) {
					if (arguments.length) {
						return removeData.call(this, $.camelCase(key));
					} else {
						return removeData.call(this);
					}
				};
			}($.fn.removeData);
		}
	
		// deprecated
		$.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
	
		$.fn.extend({
			focus: function (orig) {
				return function (delay, fn) {
					return typeof delay === "number" ? this.each(function () {
						var elem = this;
						setTimeout(function () {
							$(elem).focus();
							if (fn) {
								fn.call(elem);
							}
						}, delay);
					}) : orig.apply(this, arguments);
				};
			}($.fn.focus),
	
			disableSelection: function () {
				var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
	
				return function () {
					return this.bind(eventType + ".ui-disableSelection", function (event) {
						event.preventDefault();
					});
				};
			}(),
	
			enableSelection: function enableSelection() {
				return this.unbind(".ui-disableSelection");
			},
	
			zIndex: function zIndex(_zIndex) {
				if (_zIndex !== undefined) {
					return this.css("zIndex", _zIndex);
				}
	
				if (this.length) {
					var elem = $(this[0]),
					    position,
					    value;
					while (elem.length && elem[0] !== document) {
						// Ignore z-index if position is set to a value where z-index is ignored by the browser
						// This makes behavior of this function consistent across browsers
						// WebKit always returns auto if the element is positioned
						position = elem.css("position");
						if (position === "absolute" || position === "relative" || position === "fixed") {
							// IE returns 0 when zIndex is not specified
							// other browsers return a string
							// we ignore the case of nested elements with an explicit value of 0
							// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
							value = parseInt(elem.css("zIndex"), 10);
							if (!isNaN(value) && value !== 0) {
								return value;
							}
						}
						elem = elem.parent();
					}
				}
	
				return 0;
			}
		});
	
		// $.ui.plugin is deprecated. Use $.widget() extensions instead.
		$.ui.plugin = {
			add: function add(module, option, set) {
				var i,
				    proto = $.ui[module].prototype;
				for (i in set) {
					proto.plugins[i] = proto.plugins[i] || [];
					proto.plugins[i].push([option, set[i]]);
				}
			},
			call: function call(instance, name, args, allowDisconnected) {
				var i,
				    set = instance.plugins[name];
	
				if (!set) {
					return;
				}
	
				if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
					return;
				}
	
				for (i = 0; i < set.length; i++) {
					if (instance.options[set[i][0]]) {
						set[i][1].apply(instance.element, args);
					}
				}
			}
		};
	});

/***/ }),
/* 20 */
/*!************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/update-scroll.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var instances = __webpack_require__(/*! ./instances */ 15);
	
	var lastTop;
	var lastLeft;
	
	var createDOMEvent = function createDOMEvent(name) {
	  var event = document.createEvent("Event");
	  event.initEvent(name, true, true);
	  return event;
	};
	
	module.exports = function (element, axis, value) {
	  if (typeof element === 'undefined') {
	    throw 'You must provide an element to the update-scroll function';
	  }
	
	  if (typeof axis === 'undefined') {
	    throw 'You must provide an axis to the update-scroll function';
	  }
	
	  if (typeof value === 'undefined') {
	    throw 'You must provide a value to the update-scroll function';
	  }
	
	  if (axis === 'top' && value <= 0) {
	    element.scrollTop = value = 0; // don't allow negative scroll
	    element.dispatchEvent(createDOMEvent('ps-y-reach-start'));
	  }
	
	  if (axis === 'left' && value <= 0) {
	    element.scrollLeft = value = 0; // don't allow negative scroll
	    element.dispatchEvent(createDOMEvent('ps-x-reach-start'));
	  }
	
	  var i = instances.get(element);
	
	  if (axis === 'top' && value >= i.contentHeight - i.containerHeight) {
	    // don't allow scroll past container
	    value = i.contentHeight - i.containerHeight;
	    if (value - element.scrollTop <= 1) {
	      // mitigates rounding errors on non-subpixel scroll values
	      value = element.scrollTop;
	    } else {
	      element.scrollTop = value;
	    }
	    element.dispatchEvent(createDOMEvent('ps-y-reach-end'));
	  }
	
	  if (axis === 'left' && value >= i.contentWidth - i.containerWidth) {
	    // don't allow scroll past container
	    value = i.contentWidth - i.containerWidth;
	    if (value - element.scrollLeft <= 1) {
	      // mitigates rounding errors on non-subpixel scroll values
	      value = element.scrollLeft;
	    } else {
	      element.scrollLeft = value;
	    }
	    element.dispatchEvent(createDOMEvent('ps-x-reach-end'));
	  }
	
	  if (!lastTop) {
	    lastTop = element.scrollTop;
	  }
	
	  if (!lastLeft) {
	    lastLeft = element.scrollLeft;
	  }
	
	  if (axis === 'top' && value < lastTop) {
	    element.dispatchEvent(createDOMEvent('ps-scroll-up'));
	  }
	
	  if (axis === 'top' && value > lastTop) {
	    element.dispatchEvent(createDOMEvent('ps-scroll-down'));
	  }
	
	  if (axis === 'left' && value < lastLeft) {
	    element.dispatchEvent(createDOMEvent('ps-scroll-left'));
	  }
	
	  if (axis === 'left' && value > lastLeft) {
	    element.dispatchEvent(createDOMEvent('ps-scroll-right'));
	  }
	
	  if (axis === 'top') {
	    element.scrollTop = lastTop = value;
	    element.dispatchEvent(createDOMEvent('ps-scroll-y'));
	  }
	
	  if (axis === 'left') {
	    element.scrollLeft = lastLeft = value;
	    element.dispatchEvent(createDOMEvent('ps-scroll-x'));
	  }
	};

/***/ }),
/* 21 */
/*!***************************************!*\
  !*** ./~/create-react-class/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var React = __webpack_require__(/*! react */ 1);
	var factory = __webpack_require__(/*! ./factory */ 191);
	
	if (typeof React === 'undefined') {
	  throw Error('create-react-class could not find the React object. If you are using script tags, ' + 'make sure that React is being loaded before create-react-class.');
	}
	
	// Hack to grab NoopUpdateQueue from isomorphic React
	var ReactNoopUpdateQueue = new React.Component().updater;
	
	module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);

/***/ }),
/* 22 */
/*!********************************************************!*\
  !*** ./~/fixed-data-table-2/internal/emptyFunction.js ***!
  \********************************************************/
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ }),
/* 23 */
/*!**************************************!*\
  !*** ./~/fixed-data-table-2/main.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(/*! ./internal/FixedDataTableRoot */ 201);

/***/ }),
/* 24 */
/*!***********************************************!*\
  !*** ./~/perfect-scrollbar/src/js/lib/dom.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var DOM = {};
	
	DOM.e = function (tagName, className) {
	  var element = document.createElement(tagName);
	  element.className = className;
	  return element;
	};
	
	DOM.appendTo = function (child, parent) {
	  parent.appendChild(child);
	  return child;
	};
	
	function cssGet(element, styleName) {
	  return window.getComputedStyle(element)[styleName];
	}
	
	function cssSet(element, styleName, styleValue) {
	  if (typeof styleValue === 'number') {
	    styleValue = styleValue.toString() + 'px';
	  }
	  element.style[styleName] = styleValue;
	  return element;
	}
	
	function cssMultiSet(element, obj) {
	  for (var key in obj) {
	    var val = obj[key];
	    if (typeof val === 'number') {
	      val = val.toString() + 'px';
	    }
	    element.style[key] = val;
	  }
	  return element;
	}
	
	DOM.css = function (element, styleNameOrObject, styleValue) {
	  if ((typeof styleNameOrObject === 'undefined' ? 'undefined' : _typeof(styleNameOrObject)) === 'object') {
	    // multiple set with object
	    return cssMultiSet(element, styleNameOrObject);
	  } else {
	    if (typeof styleValue === 'undefined') {
	      return cssGet(element, styleNameOrObject);
	    } else {
	      return cssSet(element, styleNameOrObject, styleValue);
	    }
	  }
	};
	
	DOM.matches = function (element, query) {
	  if (typeof element.matches !== 'undefined') {
	    return element.matches(query);
	  } else {
	    if (typeof element.matchesSelector !== 'undefined') {
	      return element.matchesSelector(query);
	    } else if (typeof element.webkitMatchesSelector !== 'undefined') {
	      return element.webkitMatchesSelector(query);
	    } else if (typeof element.mozMatchesSelector !== 'undefined') {
	      return element.mozMatchesSelector(query);
	    } else if (typeof element.msMatchesSelector !== 'undefined') {
	      return element.msMatchesSelector(query);
	    }
	  }
	};
	
	DOM.remove = function (element) {
	  if (typeof element.remove !== 'undefined') {
	    element.remove();
	  } else {
	    if (element.parentNode) {
	      element.parentNode.removeChild(element);
	    }
	  }
	};
	
	DOM.queryChildren = function (element, selector) {
	  return Array.prototype.filter.call(element.childNodes, function (child) {
	    return DOM.matches(child, selector);
	  });
	};
	
	module.exports = DOM;

/***/ }),
/* 25 */,
/* 26 */,
/* 27 */
/*!**************************************!*\
  !*** ./~/perfect-scrollbar/index.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(/*! ./src/js/main */ 233);

/***/ }),
/* 28 */
/*!****************************************************!*\
  !*** ./~/react-mdl/lib/utils/basicClassCreator.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	exports.default = function (displayName, defaultClassName) {
	    var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'div';
	
	    var fn = function fn(props) {
	        var className = props.className,
	            children = props.children,
	            otherProps = _objectWithoutProperties(props, ['className', 'children']);
	
	        return _react2.default.createElement(element, _extends({
	            className: (0, _classnames2.default)(defaultClassName, className)
	        }, otherProps), children);
	    };
	
	    fn.displayName = displayName;
	    fn.propTypes = {
	        className: _react.PropTypes.string
	    };
	
	    return fn;
	};

/***/ }),
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 33 */,
/* 34 */
/*!****************************************************!*\
  !*** ./~/fixed-data-table-2/internal/invariant.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	"use strict";
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (true) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;

/***/ }),
/* 35 */
/*!******************************************************!*\
  !*** ./~/fixed-data-table-2/internal/joinClasses.js ***!
  \******************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule joinClasses
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Combines multiple className strings into one.
	 * http://jsperf.com/joinclasses-args-vs-array
	 *
	 * @param {...?string} className
	 * @return {string}
	 */
	
	function joinClasses(className /*, ... */) {
	  if (!className) {
	    className = '';
	  }
	  var nextClass;
	  var argLength = arguments.length;
	  if (argLength > 1) {
	    for (var ii = 1; ii < argLength; ii++) {
	      nextClass = arguments[ii];
	      if (nextClass) {
	        className = (className ? className + ' ' : '') + nextClass;
	      }
	    }
	  }
	  return className;
	}
	
	module.exports = joinClasses;

/***/ }),
/* 36 */
/*!**********************************!*\
  !*** ./~/jquery-ui/ui/widget.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/*!
	 * jQuery UI Widget 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/jQuery.widget/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
	
		var widget_uuid = 0,
		    widget_slice = Array.prototype.slice;
	
		$.cleanData = function (orig) {
			return function (elems) {
				var events, elem, i;
				for (i = 0; (elem = elems[i]) != null; i++) {
					try {
	
						// Only trigger remove when necessary to save time
						events = $._data(elem, "events");
						if (events && events.remove) {
							$(elem).triggerHandler("remove");
						}
	
						// http://bugs.jquery.com/ticket/8235
					} catch (e) {}
				}
				orig(elems);
			};
		}($.cleanData);
	
		$.widget = function (name, base, prototype) {
			var fullName,
			    existingConstructor,
			    constructor,
			    basePrototype,
	
			// proxiedPrototype allows the provided prototype to remain unmodified
			// so that it can be used as a mixin for multiple widgets (#8876)
			proxiedPrototype = {},
			    namespace = name.split(".")[0];
	
			name = name.split(".")[1];
			fullName = namespace + "-" + name;
	
			if (!prototype) {
				prototype = base;
				base = $.Widget;
			}
	
			// create selector for plugin
			$.expr[":"][fullName.toLowerCase()] = function (elem) {
				return !!$.data(elem, fullName);
			};
	
			$[namespace] = $[namespace] || {};
			existingConstructor = $[namespace][name];
			constructor = $[namespace][name] = function (options, element) {
				// allow instantiation without "new" keyword
				if (!this._createWidget) {
					return new constructor(options, element);
				}
	
				// allow instantiation without initializing for simple inheritance
				// must use "new" keyword (the code above always passes args)
				if (arguments.length) {
					this._createWidget(options, element);
				}
			};
			// extend with the existing constructor to carry over any static properties
			$.extend(constructor, existingConstructor, {
				version: prototype.version,
				// copy the object used to create the prototype in case we need to
				// redefine the widget later
				_proto: $.extend({}, prototype),
				// track widgets that inherit from this widget in case this widget is
				// redefined after a widget inherits from it
				_childConstructors: []
			});
	
			basePrototype = new base();
			// we need to make the options hash a property directly on the new instance
			// otherwise we'll modify the options hash on the prototype that we're
			// inheriting from
			basePrototype.options = $.widget.extend({}, basePrototype.options);
			$.each(prototype, function (prop, value) {
				if (!$.isFunction(value)) {
					proxiedPrototype[prop] = value;
					return;
				}
				proxiedPrototype[prop] = function () {
					var _super = function _super() {
						return base.prototype[prop].apply(this, arguments);
					},
					    _superApply = function _superApply(args) {
						return base.prototype[prop].apply(this, args);
					};
					return function () {
						var __super = this._super,
						    __superApply = this._superApply,
						    returnValue;
	
						this._super = _super;
						this._superApply = _superApply;
	
						returnValue = value.apply(this, arguments);
	
						this._super = __super;
						this._superApply = __superApply;
	
						return returnValue;
					};
				}();
			});
			constructor.prototype = $.widget.extend(basePrototype, {
				// TODO: remove support for widgetEventPrefix
				// always use the name + a colon as the prefix, e.g., draggable:start
				// don't prefix for widgets that aren't DOM-based
				widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
			}, proxiedPrototype, {
				constructor: constructor,
				namespace: namespace,
				widgetName: name,
				widgetFullName: fullName
			});
	
			// If this widget is being redefined then we need to find all widgets that
			// are inheriting from it and redefine all of them so that they inherit from
			// the new version of this widget. We're essentially trying to replace one
			// level in the prototype chain.
			if (existingConstructor) {
				$.each(existingConstructor._childConstructors, function (i, child) {
					var childPrototype = child.prototype;
	
					// redefine the child widget using the same prototype that was
					// originally used, but inherit from the new version of the base
					$.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
				});
				// remove the list of existing child constructors from the old constructor
				// so the old child constructors can be garbage collected
				delete existingConstructor._childConstructors;
			} else {
				base._childConstructors.push(constructor);
			}
	
			$.widget.bridge(name, constructor);
	
			return constructor;
		};
	
		$.widget.extend = function (target) {
			var input = widget_slice.call(arguments, 1),
			    inputIndex = 0,
			    inputLength = input.length,
			    key,
			    value;
			for (; inputIndex < inputLength; inputIndex++) {
				for (key in input[inputIndex]) {
					value = input[inputIndex][key];
					if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
						// Clone objects
						if ($.isPlainObject(value)) {
							target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) :
							// Don't extend strings, arrays, etc. with objects
							$.widget.extend({}, value);
							// Copy everything else by reference
						} else {
							target[key] = value;
						}
					}
				}
			}
			return target;
		};
	
		$.widget.bridge = function (name, object) {
			var fullName = object.prototype.widgetFullName || name;
			$.fn[name] = function (options) {
				var isMethodCall = typeof options === "string",
				    args = widget_slice.call(arguments, 1),
				    returnValue = this;
	
				if (isMethodCall) {
					this.each(function () {
						var methodValue,
						    instance = $.data(this, fullName);
						if (options === "instance") {
							returnValue = instance;
							return false;
						}
						if (!instance) {
							return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
						}
						if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
							return $.error("no such method '" + options + "' for " + name + " widget instance");
						}
						methodValue = instance[options].apply(instance, args);
						if (methodValue !== instance && methodValue !== undefined) {
							returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
							return false;
						}
					});
				} else {
	
					// Allow multiple hashes to be passed on init
					if (args.length) {
						options = $.widget.extend.apply(null, [options].concat(args));
					}
	
					this.each(function () {
						var instance = $.data(this, fullName);
						if (instance) {
							instance.option(options || {});
							if (instance._init) {
								instance._init();
							}
						} else {
							$.data(this, fullName, new object(options, this));
						}
					});
				}
	
				return returnValue;
			};
		};
	
		$.Widget = function () /* options, element */{};
		$.Widget._childConstructors = [];
	
		$.Widget.prototype = {
			widgetName: "widget",
			widgetEventPrefix: "",
			defaultElement: "<div>",
			options: {
				disabled: false,
	
				// callbacks
				create: null
			},
			_createWidget: function _createWidget(options, element) {
				element = $(element || this.defaultElement || this)[0];
				this.element = $(element);
				this.uuid = widget_uuid++;
				this.eventNamespace = "." + this.widgetName + this.uuid;
	
				this.bindings = $();
				this.hoverable = $();
				this.focusable = $();
	
				if (element !== this) {
					$.data(element, this.widgetFullName, this);
					this._on(true, this.element, {
						remove: function remove(event) {
							if (event.target === element) {
								this.destroy();
							}
						}
					});
					this.document = $(element.style ?
					// element within the document
					element.ownerDocument :
					// element is window or document
					element.document || element);
					this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
				}
	
				this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
	
				this._create();
				this._trigger("create", null, this._getCreateEventData());
				this._init();
			},
			_getCreateOptions: $.noop,
			_getCreateEventData: $.noop,
			_create: $.noop,
			_init: $.noop,
	
			destroy: function destroy() {
				this._destroy();
				// we can probably remove the unbind calls in 2.0
				// all event bindings should go through this._on()
				this.element.unbind(this.eventNamespace).removeData(this.widgetFullName)
				// support: jquery <1.6.3
				// http://bugs.jquery.com/ticket/9413
				.removeData($.camelCase(this.widgetFullName));
				this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled");
	
				// clean up events and states
				this.bindings.unbind(this.eventNamespace);
				this.hoverable.removeClass("ui-state-hover");
				this.focusable.removeClass("ui-state-focus");
			},
			_destroy: $.noop,
	
			widget: function widget() {
				return this.element;
			},
	
			option: function option(key, value) {
				var options = key,
				    parts,
				    curOption,
				    i;
	
				if (arguments.length === 0) {
					// don't return a reference to the internal hash
					return $.widget.extend({}, this.options);
				}
	
				if (typeof key === "string") {
					// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
					options = {};
					parts = key.split(".");
					key = parts.shift();
					if (parts.length) {
						curOption = options[key] = $.widget.extend({}, this.options[key]);
						for (i = 0; i < parts.length - 1; i++) {
							curOption[parts[i]] = curOption[parts[i]] || {};
							curOption = curOption[parts[i]];
						}
						key = parts.pop();
						if (arguments.length === 1) {
							return curOption[key] === undefined ? null : curOption[key];
						}
						curOption[key] = value;
					} else {
						if (arguments.length === 1) {
							return this.options[key] === undefined ? null : this.options[key];
						}
						options[key] = value;
					}
				}
	
				this._setOptions(options);
	
				return this;
			},
			_setOptions: function _setOptions(options) {
				var key;
	
				for (key in options) {
					this._setOption(key, options[key]);
				}
	
				return this;
			},
			_setOption: function _setOption(key, value) {
				this.options[key] = value;
	
				if (key === "disabled") {
					this.widget().toggleClass(this.widgetFullName + "-disabled", !!value);
	
					// If the widget is becoming disabled, then nothing is interactive
					if (value) {
						this.hoverable.removeClass("ui-state-hover");
						this.focusable.removeClass("ui-state-focus");
					}
				}
	
				return this;
			},
	
			enable: function enable() {
				return this._setOptions({ disabled: false });
			},
			disable: function disable() {
				return this._setOptions({ disabled: true });
			},
	
			_on: function _on(suppressDisabledCheck, element, handlers) {
				var delegateElement,
				    instance = this;
	
				// no suppressDisabledCheck flag, shuffle arguments
				if (typeof suppressDisabledCheck !== "boolean") {
					handlers = element;
					element = suppressDisabledCheck;
					suppressDisabledCheck = false;
				}
	
				// no element argument, shuffle and use this.element
				if (!handlers) {
					handlers = element;
					element = this.element;
					delegateElement = this.widget();
				} else {
					element = delegateElement = $(element);
					this.bindings = this.bindings.add(element);
				}
	
				$.each(handlers, function (event, handler) {
					function handlerProxy() {
						// allow widgets to customize the disabled handling
						// - disabled as an array instead of boolean
						// - disabled class as method for disabling individual parts
						if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
							return;
						}
						return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
					}
	
					// copy the guid so direct unbinding works
					if (typeof handler !== "string") {
						handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
					}
	
					var match = event.match(/^([\w:-]*)\s*(.*)$/),
					    eventName = match[1] + instance.eventNamespace,
					    selector = match[2];
					if (selector) {
						delegateElement.delegate(selector, eventName, handlerProxy);
					} else {
						element.bind(eventName, handlerProxy);
					}
				});
			},
	
			_off: function _off(element, eventName) {
				eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
				element.unbind(eventName).undelegate(eventName);
	
				// Clear the stack to avoid memory leaks (#10056)
				this.bindings = $(this.bindings.not(element).get());
				this.focusable = $(this.focusable.not(element).get());
				this.hoverable = $(this.hoverable.not(element).get());
			},
	
			_delay: function _delay(handler, delay) {
				function handlerProxy() {
					return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
				}
				var instance = this;
				return setTimeout(handlerProxy, delay || 0);
			},
	
			_hoverable: function _hoverable(element) {
				this.hoverable = this.hoverable.add(element);
				this._on(element, {
					mouseenter: function mouseenter(event) {
						$(event.currentTarget).addClass("ui-state-hover");
					},
					mouseleave: function mouseleave(event) {
						$(event.currentTarget).removeClass("ui-state-hover");
					}
				});
			},
	
			_focusable: function _focusable(element) {
				this.focusable = this.focusable.add(element);
				this._on(element, {
					focusin: function focusin(event) {
						$(event.currentTarget).addClass("ui-state-focus");
					},
					focusout: function focusout(event) {
						$(event.currentTarget).removeClass("ui-state-focus");
					}
				});
			},
	
			_trigger: function _trigger(type, event, data) {
				var prop,
				    orig,
				    callback = this.options[type];
	
				data = data || {};
				event = $.Event(event);
				event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
				// the original event may come from any element
				// so we need to reset the target on the new event
				event.target = this.element[0];
	
				// copy original event properties over to the new event
				orig = event.originalEvent;
				if (orig) {
					for (prop in orig) {
						if (!(prop in event)) {
							event[prop] = orig[prop];
						}
					}
				}
	
				this.element.trigger(event, data);
				return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
			}
		};
	
		$.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
			$.Widget.prototype["_" + method] = function (element, options, callback) {
				if (typeof options === "string") {
					options = { effect: options };
				}
				var hasOptions,
				    effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
				options = options || {};
				if (typeof options === "number") {
					options = { duration: options };
				}
				hasOptions = !$.isEmptyObject(options);
				options.complete = callback;
				if (options.delay) {
					element.delay(options.delay);
				}
				if (hasOptions && $.effects && $.effects.effect[effectName]) {
					element[method](options);
				} else if (effectName !== method && element[effectName]) {
					element[effectName](options.duration, options.easing, callback);
				} else {
					element.queue(function (next) {
						$(this)[method]();
						if (callback) {
							callback.call(element[0]);
						}
						next();
					});
				}
			};
		});
	
		return $.widget;
	});

/***/ }),
/* 37 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/Icon/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    name: _react.PropTypes.string.isRequired
	};
	
	var Icon = function Icon(props) {
	    var className = props.className,
	        name = props.name,
	        otherProps = _objectWithoutProperties(props, ['className', 'name']);
	
	    var classes = (0, _classnames2.default)('material-icons', className);
	
	    return _react2.default.createElement('i', _extends({ className: classes }, otherProps), name);
	};
	
	Icon.propTypes = propTypes;
	
	exports.default = Icon;

/***/ }),
/* 38 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ }),
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */
/*!**************************!*\
  !*** ./~/clamp/index.js ***!
  \**************************/
/***/ (function(module, exports) {

	"use strict";
	
	module.exports = clamp;
	
	function clamp(value, min, max) {
	  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
	}

/***/ }),
/* 44 */,
/* 45 */
/*!*****************************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableTranslateDOMPosition.js ***!
  \*****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _translateDOMPositionXY = __webpack_require__(/*! ./translateDOMPositionXY */ 220);
	
	var _translateDOMPositionXY2 = _interopRequireDefault(_translateDOMPositionXY);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function FixedDataTableTranslateDOMPosition( /*object*/style, /*number*/x, /*number*/y) {
	  var initialRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	
	  if (initialRender) {
	    style.left = x + 'px';
	    style.top = y + 'px';
	  } else {
	    (0, _translateDOMPositionXY2.default)(style, x, y);
	  }
	} /**
	   * Copyright Schrodinger, LLC
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * @providesModule FixedDataTableTranslateDOMPosition
	   * @typechecks
	   */
	
	module.exports = FixedDataTableTranslateDOMPosition;

/***/ }),
/* 46 */
/*!****************************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/ReactComponentWithPureRenderMixin.js ***!
  \****************************************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentWithPureRenderMixin
	 */
	
	'use strict';
	
	/**
	 * Performs equality by iterating through keys on an object and returning
	 * false when any key has values which are not strictly equal between
	 * objA and objB. Returns true when the values of all keys are strictly equal.
	 *
	 * @return {boolean}
	 */
	
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	  var key;
	  // Test for A's keys different from B.
	  for (key in objA) {
	    if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
	      return false;
	    }
	  }
	  // Test for B's keys missing from A.
	  for (key in objB) {
	    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * If your React component's render function is "pure", e.g. it will render the
	 * same result given the same props and state, provide this Mixin for a
	 * considerable performance boost.
	 *
	 * Most React components have pure render functions.
	 *
	 * Example:
	 *
	 *   var ReactComponentWithPureRenderMixin =
	 *     require('ReactComponentWithPureRenderMixin');
	 *   React.createClass({
	 *     mixins: [ReactComponentWithPureRenderMixin],
	 *
	 *     render: function() {
	 *       return <div className={this.props.className}>foo</div>;
	 *     }
	 *   });
	 *
	 * Note: This only checks shallow equality for props and state. If these contain
	 * complex data structures this mixin may have false-negatives for deeper
	 * differences. Only mixin to components which have simple props and state, or
	 * use `forceUpdate()` when you know deep data structures have changed.
	 */
	var ReactComponentWithPureRenderMixin = {
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
	  }
	};
	
	module.exports = ReactComponentWithPureRenderMixin;

/***/ }),
/* 47 */
/*!************************************************!*\
  !*** ./~/fixed-data-table-2/internal/clamp.js ***!
  \************************************************/
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule clamp
	 * @typechecks
	 */
	
	/**
	 * Clamps (or clips or confines) the value to be between min and max.
	 * @param {number} value
	 * @param {number} min
	 * @param {number} max
	 * @return {number}
	 */
	
	function clamp(value, min, max) {
	  if (value < min) {
	    return min;
	  }
	  if (value > max) {
	    return max;
	  }
	  return value;
	}
	
	module.exports = clamp;

/***/ }),
/* 48 */,
/* 49 */
/*!*************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/lib/class.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	function oldAdd(element, className) {
	  var classes = element.className.split(' ');
	  if (classes.indexOf(className) < 0) {
	    classes.push(className);
	  }
	  element.className = classes.join(' ');
	}
	
	function oldRemove(element, className) {
	  var classes = element.className.split(' ');
	  var idx = classes.indexOf(className);
	  if (idx >= 0) {
	    classes.splice(idx, 1);
	  }
	  element.className = classes.join(' ');
	}
	
	exports.add = function (element, className) {
	  if (element.classList) {
	    element.classList.add(className);
	  } else {
	    oldAdd(element, className);
	  }
	};
	
	exports.remove = function (element, className) {
	  if (element.classList) {
	    element.classList.remove(className);
	  } else {
	    oldRemove(element, className);
	  }
	};
	
	exports.list = function (element) {
	  if (element.classList) {
	    return Array.prototype.slice.apply(element.classList);
	  } else {
	    return element.className.split(' ');
	  }
	};

/***/ }),
/* 50 */
/*!**************************************************!*\
  !*** ./~/react-mdl/lib/DataTable/TableHeader.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Tooltip = __webpack_require__(/*! ../Tooltip */ 131);
	
	var _Tooltip2 = _interopRequireDefault(_Tooltip);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    cellFormatter: _react.PropTypes.func, // Used by the Table component to format the cell content for this "column"
	    className: _react.PropTypes.string,
	    name: _react.PropTypes.string.isRequired,
	    numeric: _react.PropTypes.bool,
	    onClick: _react.PropTypes.func,
	    nosort: _react.PropTypes.bool,
	    sortFn: _react.PropTypes.func, // Used by the Sortable component
	    tooltip: _react.PropTypes.node
	};
	
	var TableHeader = function TableHeader(props) {
	    var className = props.className,
	        name = props.name,
	        numeric = props.numeric,
	        onClick = props.onClick,
	        nosort = props.nosort,
	        tooltip = props.tooltip,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'name', 'numeric', 'onClick', 'nosort', 'tooltip', 'children']);
	
	    // remove unwanted props
	    // see https://github.com/Hacker0x01/react-datepicker/issues/517#issuecomment-230171426
	
	
	    delete otherProps.cellFormatter;
	    delete otherProps.sortFn;
	
	    var classes = (0, _classnames2.default)({
	        'mdl-data-table__cell--non-numeric': !numeric
	    }, className);
	
	    var clickFn = !nosort && onClick ? function (e) {
	        return onClick(e, name);
	    } : null;
	
	    return _react2.default.createElement('th', _extends({ className: classes, onClick: clickFn }, otherProps), !!tooltip ? _react2.default.createElement(_Tooltip2.default, { label: tooltip }, children) : children);
	};
	
	TableHeader.propTypes = propTypes;
	
	exports.default = TableHeader;

/***/ }),
/* 51 */
/*!************************************************!*\
  !*** ./~/react-mdl/lib/utils/cloneChildren.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = function (children, props) {
	    return _react2.default.Children.map(children, function (child) {
	        if (!child) return child;
	        var newProps = typeof props === 'function' ? props(child) : props;
	        return _react2.default.cloneElement(child, newProps);
	    });
	};

/***/ }),
/* 52 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/utils/shadows.js ***!
  \******************************************/
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var values = [2, 3, 4, 6, 8, 16, 24];
	exports.default = values.map(function (v) {
	  return "mdl-shadow--" + v + "dp";
	});

/***/ }),
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */
/*!*********************************!*\
  !*** ./~/fbjs/lib/invariant.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var validateFormat = function validateFormat(format) {};
	
	if (true) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;

/***/ }),
/* 66 */
/*!*******************************!*\
  !*** ./~/fbjs/lib/warning.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(/*! ./emptyFunction */ 112);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (true) {
	  var printWarning = function printWarning(format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	
	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	
	  warning = function warning(condition, format) {
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }
	
	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}
	
	module.exports = warning;

/***/ }),
/* 67 */
/*!**************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/DOMMouseMoveTracker.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * This class listens to events on the document and then updates a react
	 * component through callbacks.
	 * Please note that captureMouseMove must be called in
	 * order to initialize listeners on mousemove and mouseup.
	 * releaseMouseMove must be called to remove them. It is important to
	 * call releaseMouseMoves since mousemove is expensive to listen to.
	 *
	 * @providesModule DOMMouseMoveTracker
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _EventListener = __webpack_require__(/*! ./EventListener */ 194);
	
	var _EventListener2 = _interopRequireDefault(_EventListener);
	
	var _cancelAnimationFramePolyfill = __webpack_require__(/*! ./cancelAnimationFramePolyfill */ 214);
	
	var _cancelAnimationFramePolyfill2 = _interopRequireDefault(_cancelAnimationFramePolyfill);
	
	var _requestAnimationFramePolyfill = __webpack_require__(/*! ./requestAnimationFramePolyfill */ 70);
	
	var _requestAnimationFramePolyfill2 = _interopRequireDefault(_requestAnimationFramePolyfill);
	
	var _FixedDataTableEventHelper = __webpack_require__(/*! ./FixedDataTableEventHelper */ 68);
	
	var _FixedDataTableEventHelper2 = _interopRequireDefault(_FixedDataTableEventHelper);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var DOMMouseMoveTracker = function () {
	  /**
	   * onMove is the callback that will be called on every mouse move.
	   * onMoveEnd is called on mouse up when movement has ended.
	   */
	  function DOMMouseMoveTracker(
	  /*function*/onMove,
	  /*function*/onMoveEnd,
	  /*DOMElement*/domNode,
	  /*boolean*/touchEnabled) {
	    _classCallCheck(this, DOMMouseMoveTracker);
	
	    this._isDragging = false;
	    this._isTouchEnabled = touchEnabled;
	    this._animationFrameID = null;
	    this._domNode = domNode;
	    this._onMove = onMove;
	    this._onMoveEnd = onMoveEnd;
	    this._onMouseEnd = this._onMouseEnd.bind(this);
	    this._onMouseMove = this._onMouseMove.bind(this);
	    this._onMouseUp = this._onMouseUp.bind(this);
	    this._didMouseMove = this._didMouseMove.bind(this);
	  }
	
	  /**
	   * This is to set up the listeners for listening to mouse move
	   * and mouse up signaling the movement has ended. Please note that these
	   * listeners are added at the document.body level. It takes in an event
	   * in order to grab inital state.
	   */
	
	  _createClass(DOMMouseMoveTracker, [{
	    key: 'captureMouseMoves',
	    value: function captureMouseMoves( /*object*/event) {
	      if (!this._eventMoveToken && !this._eventUpToken && !this._eventLeaveToken && !this._eventOutToken) {
	        this._eventMoveToken = _EventListener2.default.listen(this._domNode, 'mousemove', this._onMouseMove);
	        this._eventUpToken = _EventListener2.default.listen(this._domNode, 'mouseup', this._onMouseUp);
	        this._eventLeaveToken = _EventListener2.default.listen(this._domNode, 'mouseleave', this._onMouseEnd);
	        this._eventOutToken = _EventListener2.default.listen(this._domNode, 'mouseout', this.onMouseEnd);
	      }
	
	      if (this._isTouchEnabled && !this._eventTouchStartToken && !this._eventTouchMoveToken && !this._eventTouchEndToken) {
	        this._eventTouchStartToken = _EventListener2.default.listen(this._domNode, 'touchstart', this._onMouseMove);
	        this._eventTouchMoveToken = _EventListener2.default.listen(this._domNode, 'touchmove', this._onMouseMove);
	        this._eventTouchEndToken = _EventListener2.default.listen(this._domNode, 'touchend', this._onMouseUp);
	      }
	
	      if (!this._isDragging) {
	        this._deltaX = 0;
	        this._deltaY = 0;
	        this._isDragging = true;
	        var coordinates = _FixedDataTableEventHelper2.default.getCoordinatesFromEvent(event);
	        var x = coordinates.x;
	        var y = coordinates.y;
	        this._x = x;
	        this._y = y;
	      }
	      event.preventDefault();
	    }
	
	    /**
	     * These releases all of the listeners on document.body.
	     */
	
	  }, {
	    key: 'releaseMouseMoves',
	    value: function releaseMouseMoves() {
	      if (this._eventMoveToken && this._eventUpToken && this._eventLeaveToken && this._eventOutToken) {
	        this._eventMoveToken.remove();
	        this._eventMoveToken = null;
	        this._eventUpToken.remove();
	        this._eventUpToken = null;
	        this._eventLeaveToken.remove();
	        this._eventLeaveToken = null;
	        this._eventOutToken.remove();
	        this._eventOutToken = null;
	      }
	
	      if (this._isTouchEnabled && this._eventTouchStartToken && this._eventTouchMoveToken && this._eventTouchEndToken) {
	        this._eventTouchStartToken.remove();
	        this._eventTouchStartToken = null;
	        this._eventTouchMoveToken.remove();
	        this._eventTouchMoveToken = null;
	        this._eventTouchEndToken.remove();
	        this._eventTouchEndToken = null;
	      }
	
	      if (this._animationFrameID !== null) {
	        (0, _cancelAnimationFramePolyfill2.default)(this._animationFrameID);
	        this._animationFrameID = null;
	      }
	
	      if (this._isDragging) {
	        this._isDragging = false;
	        this._x = null;
	        this._y = null;
	      }
	    }
	
	    /**
	     * Returns whether or not if the mouse movement is being tracked.
	     */
	
	  }, {
	    key: 'isDragging',
	    value: function isDragging() /*boolean*/{
	      return this._isDragging;
	    }
	
	    /**
	     * Calls onMove passed into constructor and updates internal state.
	     */
	
	  }, {
	    key: '_onMouseMove',
	    value: function _onMouseMove( /*object*/event) {
	      var coordinates = _FixedDataTableEventHelper2.default.getCoordinatesFromEvent(event);
	      var x = coordinates.x;
	      var y = coordinates.y;
	
	      this._deltaX += x - this._x;
	      this._deltaY += y - this._y;
	
	      if (this._animationFrameID === null) {
	        // The mouse may move faster then the animation frame does.
	        // Use `requestAnimationFramePolyfill` to avoid over-updating.
	        this._animationFrameID = (0, _requestAnimationFramePolyfill2.default)(this._didMouseMove);
	      }
	
	      this._x = x;
	      this._y = y;
	      event.preventDefault();
	    }
	  }, {
	    key: '_didMouseMove',
	    value: function _didMouseMove() {
	      this._animationFrameID = null;
	      this._onMove(this._deltaX, this._deltaY);
	      this._deltaX = 0;
	      this._deltaY = 0;
	    }
	
	    /**
	     * Calls onMoveEnd passed into constructor and updates internal state.
	     */
	
	  }, {
	    key: '_onMouseUp',
	    value: function _onMouseUp() {
	      if (this._animationFrameID) {
	        this._didMouseMove();
	      }
	      this._onMoveEnd(false);
	    }
	
	    /**
	     * Calls onMoveEnd passed into the constructor, updates internal state, and cancels the move.
	     */
	
	  }, {
	    key: '_onMouseEnd',
	    value: function _onMouseEnd() {
	      this._onMoveEnd(true);
	    }
	  }]);
	
	  return DOMMouseMoveTracker;
	}();
	
	module.exports = DOMMouseMoveTracker;

/***/ }),
/* 68 */
/*!********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableEventHelper.js ***!
  \********************************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableEventHelper
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the horizontal and vertical coordinates from a mouse or touch event.
	 */
	
	function getCoordinatesFromEvent( /*object*/event) /*object*/{
	    var x = 0;
	    var y = 0;
	
	    if (!event.clientX || !event.clientY) {
	        if (event.touches && event.touches.length > 0) {
	            var touch = event.touches[0];
	            x = touch.clientX;
	            y = touch.clientY;
	        }
	    } else {
	        x = event.clientX;
	        y = event.clientY;
	    }
	
	    return { x: x, y: y };
	}
	
	var FixedDataTableEventHelper = {
	    getCoordinatesFromEvent: getCoordinatesFromEvent
	};
	
	module.exports = FixedDataTableEventHelper;

/***/ }),
/* 69 */
/*!*************************************************!*\
  !*** ./~/fixed-data-table-2/internal/Locale.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Locale
	 */
	
	"use strict";
	
	// Hard code this for now.
	
	var Locale = {
	  isRTL: function isRTL() {
	    return false;
	  },
	  getDirection: function getDirection() {
	    return 'LTR';
	  }
	};
	
	module.exports = Locale;

/***/ }),
/* 70 */
/*!************************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/requestAnimationFramePolyfill.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _emptyFunction = __webpack_require__(/*! ./emptyFunction */ 22);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	var _nativeRequestAnimationFrame = __webpack_require__(/*! ./nativeRequestAnimationFrame */ 218);
	
	var _nativeRequestAnimationFrame2 = _interopRequireDefault(_nativeRequestAnimationFrame);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule requestAnimationFramePolyfill
	 */
	
	var lastTime = 0;
	
	/**
	 * Here is the native and polyfill version of requestAnimationFrame.
	 * Please don't use it directly and use requestAnimationFrame module instead.
	 */
	var requestAnimationFrame = _nativeRequestAnimationFrame2.default || function (callback) {
	  var currTime = Date.now();
	  var timeDelay = Math.max(0, 16 - (currTime - lastTime));
	  lastTime = currTime + timeDelay;
	  return global.setTimeout(function () {
	    callback(Date.now());
	  }, timeDelay);
	};
	
	// Works around a rare bug in Safari 6 where the first request is never invoked.
	requestAnimationFrame(_emptyFunction2.default);
	
	module.exports = requestAnimationFrame;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 71 */
/*!*************************!*\
  !*** ./~/flux/index.js ***!
  \*************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	module.exports.Dispatcher = __webpack_require__(/*! ./lib/Dispatcher */ 221);

/***/ }),
/* 72 */
/*!*********************************!*\
  !*** ./~/jquery-ui/ui/mouse.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/*!
	 * jQuery UI Mouse 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/mouse/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3), __webpack_require__(/*! ./widget */ 36)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
	
		var mouseHandled = false;
		$(document).mouseup(function () {
			mouseHandled = false;
		});
	
		return $.widget("ui.mouse", {
			version: "1.11.4",
			options: {
				cancel: "input,textarea,button,select,option",
				distance: 1,
				delay: 0
			},
			_mouseInit: function _mouseInit() {
				var that = this;
	
				this.element.bind("mousedown." + this.widgetName, function (event) {
					return that._mouseDown(event);
				}).bind("click." + this.widgetName, function (event) {
					if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
						$.removeData(event.target, that.widgetName + ".preventClickEvent");
						event.stopImmediatePropagation();
						return false;
					}
				});
	
				this.started = false;
			},
	
			// TODO: make sure destroying one instance of mouse doesn't mess with
			// other instances of mouse
			_mouseDestroy: function _mouseDestroy() {
				this.element.unbind("." + this.widgetName);
				if (this._mouseMoveDelegate) {
					this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
				}
			},
	
			_mouseDown: function _mouseDown(event) {
				// don't let more than one widget handle mouseStart
				if (mouseHandled) {
					return;
				}
	
				this._mouseMoved = false;
	
				// we may have missed mouseup (out of window)
				this._mouseStarted && this._mouseUp(event);
	
				this._mouseDownEvent = event;
	
				var that = this,
				    btnIsLeft = event.which === 1,
	
				// event.target.nodeName works around a bug in IE 8 with
				// disabled inputs (#7620)
				elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
				if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
					return true;
				}
	
				this.mouseDelayMet = !this.options.delay;
				if (!this.mouseDelayMet) {
					this._mouseDelayTimer = setTimeout(function () {
						that.mouseDelayMet = true;
					}, this.options.delay);
				}
	
				if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
					this._mouseStarted = this._mouseStart(event) !== false;
					if (!this._mouseStarted) {
						event.preventDefault();
						return true;
					}
				}
	
				// Click event may never have fired (Gecko & Opera)
				if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, this.widgetName + ".preventClickEvent");
				}
	
				// these delegates are required to keep context
				this._mouseMoveDelegate = function (event) {
					return that._mouseMove(event);
				};
				this._mouseUpDelegate = function (event) {
					return that._mouseUp(event);
				};
	
				this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
	
				event.preventDefault();
	
				mouseHandled = true;
				return true;
			},
	
			_mouseMove: function _mouseMove(event) {
				// Only check for mouseups outside the document if you've moved inside the document
				// at least once. This prevents the firing of mouseup in the case of IE<9, which will
				// fire a mousemove event if content is placed under the cursor. See #7778
				// Support: IE <9
				if (this._mouseMoved) {
					// IE mouseup check - mouseup happened when mouse was out of window
					if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
						return this._mouseUp(event);
	
						// Iframe mouseup check - mouseup occurred in another document
					} else if (!event.which) {
						return this._mouseUp(event);
					}
				}
	
				if (event.which || event.button) {
					this._mouseMoved = true;
				}
	
				if (this._mouseStarted) {
					this._mouseDrag(event);
					return event.preventDefault();
				}
	
				if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
					this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
					this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
				}
	
				return !this._mouseStarted;
			},
	
			_mouseUp: function _mouseUp(event) {
				this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
	
				if (this._mouseStarted) {
					this._mouseStarted = false;
	
					if (event.target === this._mouseDownEvent.target) {
						$.data(event.target, this.widgetName + ".preventClickEvent", true);
					}
	
					this._mouseStop(event);
				}
	
				mouseHandled = false;
				return false;
			},
	
			_mouseDistanceMet: function _mouseDistanceMet(event) {
				return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
			},
	
			_mouseDelayMet: function _mouseDelayMet() /* event */{
				return this.mouseDelayMet;
			},
	
			// These are placeholder methods, to be overriden by extending plugin
			_mouseStart: function _mouseStart() /* event */{},
			_mouseDrag: function _mouseDrag() /* event */{},
			_mouseStop: function _mouseStop() /* event */{},
			_mouseCapture: function _mouseCapture() /* event */{
				return true;
			}
		});
	});

/***/ }),
/* 73 */
/*!*************************************!*\
  !*** ./~/jquery-ui/ui/resizable.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/*!
	 * jQuery UI Resizable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/resizable/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3), __webpack_require__(/*! ./core */ 19), __webpack_require__(/*! ./mouse */ 72), __webpack_require__(/*! ./widget */ 36)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
	
		$.widget("ui.resizable", $.ui.mouse, {
			version: "1.11.4",
			widgetEventPrefix: "resize",
			options: {
				alsoResize: false,
				animate: false,
				animateDuration: "slow",
				animateEasing: "swing",
				aspectRatio: false,
				autoHide: false,
				containment: false,
				ghost: false,
				grid: false,
				handles: "e,s,se",
				helper: false,
				maxHeight: null,
				maxWidth: null,
				minHeight: 10,
				minWidth: 10,
				// See #7960
				zIndex: 90,
	
				// callbacks
				resize: null,
				start: null,
				stop: null
			},
	
			_num: function _num(value) {
				return parseInt(value, 10) || 0;
			},
	
			_isNumber: function _isNumber(value) {
				return !isNaN(parseInt(value, 10));
			},
	
			_hasScroll: function _hasScroll(el, a) {
	
				if ($(el).css("overflow") === "hidden") {
					return false;
				}
	
				var scroll = a && a === "left" ? "scrollLeft" : "scrollTop",
				    has = false;
	
				if (el[scroll] > 0) {
					return true;
				}
	
				// TODO: determine which cases actually cause this to happen
				// if the element doesn't have the scroll set, see if it's possible to
				// set the scroll
				el[scroll] = 1;
				has = el[scroll] > 0;
				el[scroll] = 0;
				return has;
			},
	
			_create: function _create() {
	
				var n,
				    i,
				    handle,
				    axis,
				    hname,
				    that = this,
				    o = this.options;
				this.element.addClass("ui-resizable");
	
				$.extend(this, {
					_aspectRatio: !!o.aspectRatio,
					aspectRatio: o.aspectRatio,
					originalElement: this.element,
					_proportionallyResizeElements: [],
					_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
				});
	
				// Wrap the element if it cannot hold child nodes
				if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
	
					this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
						position: this.element.css("position"),
						width: this.element.outerWidth(),
						height: this.element.outerHeight(),
						top: this.element.css("top"),
						left: this.element.css("left")
					}));
	
					this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
	
					this.elementIsWrapper = true;
	
					this.element.css({
						marginLeft: this.originalElement.css("marginLeft"),
						marginTop: this.originalElement.css("marginTop"),
						marginRight: this.originalElement.css("marginRight"),
						marginBottom: this.originalElement.css("marginBottom")
					});
					this.originalElement.css({
						marginLeft: 0,
						marginTop: 0,
						marginRight: 0,
						marginBottom: 0
					});
					// support: Safari
					// Prevent Safari textarea resize
					this.originalResizeStyle = this.originalElement.css("resize");
					this.originalElement.css("resize", "none");
	
					this._proportionallyResizeElements.push(this.originalElement.css({
						position: "static",
						zoom: 1,
						display: "block"
					}));
	
					// support: IE9
					// avoid IE jump (hard set the margin)
					this.originalElement.css({ margin: this.originalElement.css("margin") });
	
					this._proportionallyResize();
				}
	
				this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
					n: ".ui-resizable-n",
					e: ".ui-resizable-e",
					s: ".ui-resizable-s",
					w: ".ui-resizable-w",
					se: ".ui-resizable-se",
					sw: ".ui-resizable-sw",
					ne: ".ui-resizable-ne",
					nw: ".ui-resizable-nw"
				});
	
				this._handles = $();
				if (this.handles.constructor === String) {
	
					if (this.handles === "all") {
						this.handles = "n,e,s,w,se,sw,ne,nw";
					}
	
					n = this.handles.split(",");
					this.handles = {};
	
					for (i = 0; i < n.length; i++) {
	
						handle = $.trim(n[i]);
						hname = "ui-resizable-" + handle;
						axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
	
						axis.css({ zIndex: o.zIndex });
	
						// TODO : What's going on here?
						if ("se" === handle) {
							axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
						}
	
						this.handles[handle] = ".ui-resizable-" + handle;
						this.element.append(axis);
					}
				}
	
				this._renderAxis = function (target) {
	
					var i, axis, padPos, padWrapper;
	
					target = target || this.element;
	
					for (i in this.handles) {
	
						if (this.handles[i].constructor === String) {
							this.handles[i] = this.element.children(this.handles[i]).first().show();
						} else if (this.handles[i].jquery || this.handles[i].nodeType) {
							this.handles[i] = $(this.handles[i]);
							this._on(this.handles[i], { "mousedown": that._mouseDown });
						}
	
						if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
	
							axis = $(this.handles[i], this.element);
	
							padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
	
							padPos = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join("");
	
							target.css(padPos, padWrapper);
	
							this._proportionallyResize();
						}
	
						this._handles = this._handles.add(this.handles[i]);
					}
				};
	
				// TODO: make renderAxis a prototype function
				this._renderAxis(this.element);
	
				this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
				this._handles.disableSelection();
	
				this._handles.mouseover(function () {
					if (!that.resizing) {
						if (this.className) {
							axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
						}
						that.axis = axis && axis[1] ? axis[1] : "se";
					}
				});
	
				if (o.autoHide) {
					this._handles.hide();
					$(this.element).addClass("ui-resizable-autohide").mouseenter(function () {
						if (o.disabled) {
							return;
						}
						$(this).removeClass("ui-resizable-autohide");
						that._handles.show();
					}).mouseleave(function () {
						if (o.disabled) {
							return;
						}
						if (!that.resizing) {
							$(this).addClass("ui-resizable-autohide");
							that._handles.hide();
						}
					});
				}
	
				this._mouseInit();
			},
	
			_destroy: function _destroy() {
	
				this._mouseDestroy();
	
				var wrapper,
				    _destroy = function _destroy(exp) {
					$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
				};
	
				// TODO: Unwrap at same DOM position
				if (this.elementIsWrapper) {
					_destroy(this.element);
					wrapper = this.element;
					this.originalElement.css({
						position: wrapper.css("position"),
						width: wrapper.outerWidth(),
						height: wrapper.outerHeight(),
						top: wrapper.css("top"),
						left: wrapper.css("left")
					}).insertAfter(wrapper);
					wrapper.remove();
				}
	
				this.originalElement.css("resize", this.originalResizeStyle);
				_destroy(this.originalElement);
	
				return this;
			},
	
			_mouseCapture: function _mouseCapture(event) {
				var i,
				    handle,
				    capture = false;
	
				for (i in this.handles) {
					handle = $(this.handles[i])[0];
					if (handle === event.target || $.contains(handle, event.target)) {
						capture = true;
					}
				}
	
				return !this.options.disabled && capture;
			},
	
			_mouseStart: function _mouseStart(event) {
	
				var curleft,
				    curtop,
				    cursor,
				    o = this.options,
				    el = this.element;
	
				this.resizing = true;
	
				this._renderProxy();
	
				curleft = this._num(this.helper.css("left"));
				curtop = this._num(this.helper.css("top"));
	
				if (o.containment) {
					curleft += $(o.containment).scrollLeft() || 0;
					curtop += $(o.containment).scrollTop() || 0;
				}
	
				this.offset = this.helper.offset();
				this.position = { left: curleft, top: curtop };
	
				this.size = this._helper ? {
					width: this.helper.width(),
					height: this.helper.height()
				} : {
					width: el.width(),
					height: el.height()
				};
	
				this.originalSize = this._helper ? {
					width: el.outerWidth(),
					height: el.outerHeight()
				} : {
					width: el.width(),
					height: el.height()
				};
	
				this.sizeDiff = {
					width: el.outerWidth() - el.width(),
					height: el.outerHeight() - el.height()
				};
	
				this.originalPosition = { left: curleft, top: curtop };
				this.originalMousePosition = { left: event.pageX, top: event.pageY };
	
				this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
	
				cursor = $(".ui-resizable-" + this.axis).css("cursor");
				$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
	
				el.addClass("ui-resizable-resizing");
				this._propagate("start", event);
				return true;
			},
	
			_mouseDrag: function _mouseDrag(event) {
	
				var data,
				    props,
				    smp = this.originalMousePosition,
				    a = this.axis,
				    dx = event.pageX - smp.left || 0,
				    dy = event.pageY - smp.top || 0,
				    trigger = this._change[a];
	
				this._updatePrevProperties();
	
				if (!trigger) {
					return false;
				}
	
				data = trigger.apply(this, [event, dx, dy]);
	
				this._updateVirtualBoundaries(event.shiftKey);
				if (this._aspectRatio || event.shiftKey) {
					data = this._updateRatio(data, event);
				}
	
				data = this._respectSize(data, event);
	
				this._updateCache(data);
	
				this._propagate("resize", event);
	
				props = this._applyChanges();
	
				if (!this._helper && this._proportionallyResizeElements.length) {
					this._proportionallyResize();
				}
	
				if (!$.isEmptyObject(props)) {
					this._updatePrevProperties();
					this._trigger("resize", event, this.ui());
					this._applyChanges();
				}
	
				return false;
			},
	
			_mouseStop: function _mouseStop(event) {
	
				this.resizing = false;
				var pr,
				    ista,
				    soffseth,
				    soffsetw,
				    s,
				    left,
				    top,
				    o = this.options,
				    that = this;
	
				if (this._helper) {
	
					pr = this._proportionallyResizeElements;
					ista = pr.length && /textarea/i.test(pr[0].nodeName);
					soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
					soffsetw = ista ? 0 : that.sizeDiff.width;
	
					s = {
						width: that.helper.width() - soffsetw,
						height: that.helper.height() - soffseth
					};
					left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null;
					top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
	
					if (!o.animate) {
						this.element.css($.extend(s, { top: top, left: left }));
					}
	
					that.helper.height(that.size.height);
					that.helper.width(that.size.width);
	
					if (this._helper && !o.animate) {
						this._proportionallyResize();
					}
				}
	
				$("body").css("cursor", "auto");
	
				this.element.removeClass("ui-resizable-resizing");
	
				this._propagate("stop", event);
	
				if (this._helper) {
					this.helper.remove();
				}
	
				return false;
			},
	
			_updatePrevProperties: function _updatePrevProperties() {
				this.prevPosition = {
					top: this.position.top,
					left: this.position.left
				};
				this.prevSize = {
					width: this.size.width,
					height: this.size.height
				};
			},
	
			_applyChanges: function _applyChanges() {
				var props = {};
	
				if (this.position.top !== this.prevPosition.top) {
					props.top = this.position.top + "px";
				}
				if (this.position.left !== this.prevPosition.left) {
					props.left = this.position.left + "px";
				}
				if (this.size.width !== this.prevSize.width) {
					props.width = this.size.width + "px";
				}
				if (this.size.height !== this.prevSize.height) {
					props.height = this.size.height + "px";
				}
	
				this.helper.css(props);
	
				return props;
			},
	
			_updateVirtualBoundaries: function _updateVirtualBoundaries(forceAspectRatio) {
				var pMinWidth,
				    pMaxWidth,
				    pMinHeight,
				    pMaxHeight,
				    b,
				    o = this.options;
	
				b = {
					minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
					maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
					minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
					maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
				};
	
				if (this._aspectRatio || forceAspectRatio) {
					pMinWidth = b.minHeight * this.aspectRatio;
					pMinHeight = b.minWidth / this.aspectRatio;
					pMaxWidth = b.maxHeight * this.aspectRatio;
					pMaxHeight = b.maxWidth / this.aspectRatio;
	
					if (pMinWidth > b.minWidth) {
						b.minWidth = pMinWidth;
					}
					if (pMinHeight > b.minHeight) {
						b.minHeight = pMinHeight;
					}
					if (pMaxWidth < b.maxWidth) {
						b.maxWidth = pMaxWidth;
					}
					if (pMaxHeight < b.maxHeight) {
						b.maxHeight = pMaxHeight;
					}
				}
				this._vBoundaries = b;
			},
	
			_updateCache: function _updateCache(data) {
				this.offset = this.helper.offset();
				if (this._isNumber(data.left)) {
					this.position.left = data.left;
				}
				if (this._isNumber(data.top)) {
					this.position.top = data.top;
				}
				if (this._isNumber(data.height)) {
					this.size.height = data.height;
				}
				if (this._isNumber(data.width)) {
					this.size.width = data.width;
				}
			},
	
			_updateRatio: function _updateRatio(data) {
	
				var cpos = this.position,
				    csize = this.size,
				    a = this.axis;
	
				if (this._isNumber(data.height)) {
					data.width = data.height * this.aspectRatio;
				} else if (this._isNumber(data.width)) {
					data.height = data.width / this.aspectRatio;
				}
	
				if (a === "sw") {
					data.left = cpos.left + (csize.width - data.width);
					data.top = null;
				}
				if (a === "nw") {
					data.top = cpos.top + (csize.height - data.height);
					data.left = cpos.left + (csize.width - data.width);
				}
	
				return data;
			},
	
			_respectSize: function _respectSize(data) {
	
				var o = this._vBoundaries,
				    a = this.axis,
				    ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width,
				    ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height,
				    isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width,
				    isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height,
				    dw = this.originalPosition.left + this.originalSize.width,
				    dh = this.position.top + this.size.height,
				    cw = /sw|nw|w/.test(a),
				    ch = /nw|ne|n/.test(a);
				if (isminw) {
					data.width = o.minWidth;
				}
				if (isminh) {
					data.height = o.minHeight;
				}
				if (ismaxw) {
					data.width = o.maxWidth;
				}
				if (ismaxh) {
					data.height = o.maxHeight;
				}
	
				if (isminw && cw) {
					data.left = dw - o.minWidth;
				}
				if (ismaxw && cw) {
					data.left = dw - o.maxWidth;
				}
				if (isminh && ch) {
					data.top = dh - o.minHeight;
				}
				if (ismaxh && ch) {
					data.top = dh - o.maxHeight;
				}
	
				// Fixing jump error on top/left - bug #2330
				if (!data.width && !data.height && !data.left && data.top) {
					data.top = null;
				} else if (!data.width && !data.height && !data.top && data.left) {
					data.left = null;
				}
	
				return data;
			},
	
			_getPaddingPlusBorderDimensions: function _getPaddingPlusBorderDimensions(element) {
				var i = 0,
				    widths = [],
				    borders = [element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth")],
				    paddings = [element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft")];
	
				for (; i < 4; i++) {
					widths[i] = parseInt(borders[i], 10) || 0;
					widths[i] += parseInt(paddings[i], 10) || 0;
				}
	
				return {
					height: widths[0] + widths[2],
					width: widths[1] + widths[3]
				};
			},
	
			_proportionallyResize: function _proportionallyResize() {
	
				if (!this._proportionallyResizeElements.length) {
					return;
				}
	
				var prel,
				    i = 0,
				    element = this.helper || this.element;
	
				for (; i < this._proportionallyResizeElements.length; i++) {
	
					prel = this._proportionallyResizeElements[i];
	
					// TODO: Seems like a bug to cache this.outerDimensions
					// considering that we are in a loop.
					if (!this.outerDimensions) {
						this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
					}
	
					prel.css({
						height: element.height() - this.outerDimensions.height || 0,
						width: element.width() - this.outerDimensions.width || 0
					});
				}
			},
	
			_renderProxy: function _renderProxy() {
	
				var el = this.element,
				    o = this.options;
				this.elementOffset = el.offset();
	
				if (this._helper) {
	
					this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
	
					this.helper.addClass(this._helper).css({
						width: this.element.outerWidth() - 1,
						height: this.element.outerHeight() - 1,
						position: "absolute",
						left: this.elementOffset.left + "px",
						top: this.elementOffset.top + "px",
						zIndex: ++o.zIndex //TODO: Don't modify option
					});
	
					this.helper.appendTo("body").disableSelection();
				} else {
					this.helper = this.element;
				}
			},
	
			_change: {
				e: function e(event, dx) {
					return { width: this.originalSize.width + dx };
				},
				w: function w(event, dx) {
					var cs = this.originalSize,
					    sp = this.originalPosition;
					return { left: sp.left + dx, width: cs.width - dx };
				},
				n: function n(event, dx, dy) {
					var cs = this.originalSize,
					    sp = this.originalPosition;
					return { top: sp.top + dy, height: cs.height - dy };
				},
				s: function s(event, dx, dy) {
					return { height: this.originalSize.height + dy };
				},
				se: function se(event, dx, dy) {
					return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
				},
				sw: function sw(event, dx, dy) {
					return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
				},
				ne: function ne(event, dx, dy) {
					return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
				},
				nw: function nw(event, dx, dy) {
					return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
				}
			},
	
			_propagate: function _propagate(n, event) {
				$.ui.plugin.call(this, n, [event, this.ui()]);
				n !== "resize" && this._trigger(n, event, this.ui());
			},
	
			plugins: {},
	
			ui: function ui() {
				return {
					originalElement: this.originalElement,
					element: this.element,
					helper: this.helper,
					position: this.position,
					size: this.size,
					originalSize: this.originalSize,
					originalPosition: this.originalPosition
				};
			}
	
		});
	
		/*
	  * Resizable Extensions
	  */
	
		$.ui.plugin.add("resizable", "animate", {
	
			stop: function stop(event) {
				var that = $(this).resizable("instance"),
				    o = that.options,
				    pr = that._proportionallyResizeElements,
				    ista = pr.length && /textarea/i.test(pr[0].nodeName),
				    soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
				    soffsetw = ista ? 0 : that.sizeDiff.width,
				    style = { width: that.size.width - soffsetw, height: that.size.height - soffseth },
				    left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null,
				    top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
	
				that.element.animate($.extend(style, top && left ? { top: top, left: left } : {}), {
					duration: o.animateDuration,
					easing: o.animateEasing,
					step: function step() {
	
						var data = {
							width: parseInt(that.element.css("width"), 10),
							height: parseInt(that.element.css("height"), 10),
							top: parseInt(that.element.css("top"), 10),
							left: parseInt(that.element.css("left"), 10)
						};
	
						if (pr && pr.length) {
							$(pr[0]).css({ width: data.width, height: data.height });
						}
	
						// propagating resize, and updating values for each animation step
						that._updateCache(data);
						that._propagate("resize", event);
					}
				});
			}
	
		});
	
		$.ui.plugin.add("resizable", "containment", {
	
			start: function start() {
				var element,
				    p,
				    co,
				    ch,
				    cw,
				    width,
				    height,
				    that = $(this).resizable("instance"),
				    o = that.options,
				    el = that.element,
				    oc = o.containment,
				    ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
	
				if (!ce) {
					return;
				}
	
				that.containerElement = $(ce);
	
				if (/document/.test(oc) || oc === document) {
					that.containerOffset = {
						left: 0,
						top: 0
					};
					that.containerPosition = {
						left: 0,
						top: 0
					};
	
					that.parentData = {
						element: $(document),
						left: 0,
						top: 0,
						width: $(document).width(),
						height: $(document).height() || document.body.parentNode.scrollHeight
					};
				} else {
					element = $(ce);
					p = [];
					$(["Top", "Right", "Left", "Bottom"]).each(function (i, name) {
						p[i] = that._num(element.css("padding" + name));
					});
	
					that.containerOffset = element.offset();
					that.containerPosition = element.position();
					that.containerSize = {
						height: element.innerHeight() - p[3],
						width: element.innerWidth() - p[1]
					};
	
					co = that.containerOffset;
					ch = that.containerSize.height;
					cw = that.containerSize.width;
					width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw;
					height = that._hasScroll(ce) ? ce.scrollHeight : ch;
	
					that.parentData = {
						element: ce,
						left: co.left,
						top: co.top,
						width: width,
						height: height
					};
				}
			},
	
			resize: function resize(event) {
				var woset,
				    hoset,
				    isParent,
				    isOffsetRelative,
				    that = $(this).resizable("instance"),
				    o = that.options,
				    co = that.containerOffset,
				    cp = that.position,
				    pRatio = that._aspectRatio || event.shiftKey,
				    cop = {
					top: 0,
					left: 0
				},
				    ce = that.containerElement,
				    continueResize = true;
	
				if (ce[0] !== document && /static/.test(ce.css("position"))) {
					cop = co;
				}
	
				if (cp.left < (that._helper ? co.left : 0)) {
					that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
	
					if (pRatio) {
						that.size.height = that.size.width / that.aspectRatio;
						continueResize = false;
					}
					that.position.left = o.helper ? co.left : 0;
				}
	
				if (cp.top < (that._helper ? co.top : 0)) {
					that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
	
					if (pRatio) {
						that.size.width = that.size.height * that.aspectRatio;
						continueResize = false;
					}
					that.position.top = that._helper ? co.top : 0;
				}
	
				isParent = that.containerElement.get(0) === that.element.parent().get(0);
				isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
	
				if (isParent && isOffsetRelative) {
					that.offset.left = that.parentData.left + that.position.left;
					that.offset.top = that.parentData.top + that.position.top;
				} else {
					that.offset.left = that.element.offset().left;
					that.offset.top = that.element.offset().top;
				}
	
				woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));
	
				hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));
	
				if (woset + that.size.width >= that.parentData.width) {
					that.size.width = that.parentData.width - woset;
					if (pRatio) {
						that.size.height = that.size.width / that.aspectRatio;
						continueResize = false;
					}
				}
	
				if (hoset + that.size.height >= that.parentData.height) {
					that.size.height = that.parentData.height - hoset;
					if (pRatio) {
						that.size.width = that.size.height * that.aspectRatio;
						continueResize = false;
					}
				}
	
				if (!continueResize) {
					that.position.left = that.prevPosition.left;
					that.position.top = that.prevPosition.top;
					that.size.width = that.prevSize.width;
					that.size.height = that.prevSize.height;
				}
			},
	
			stop: function stop() {
				var that = $(this).resizable("instance"),
				    o = that.options,
				    co = that.containerOffset,
				    cop = that.containerPosition,
				    ce = that.containerElement,
				    helper = $(that.helper),
				    ho = helper.offset(),
				    w = helper.outerWidth() - that.sizeDiff.width,
				    h = helper.outerHeight() - that.sizeDiff.height;
	
				if (that._helper && !o.animate && /relative/.test(ce.css("position"))) {
					$(this).css({
						left: ho.left - cop.left - co.left,
						width: w,
						height: h
					});
				}
	
				if (that._helper && !o.animate && /static/.test(ce.css("position"))) {
					$(this).css({
						left: ho.left - cop.left - co.left,
						width: w,
						height: h
					});
				}
			}
		});
	
		$.ui.plugin.add("resizable", "alsoResize", {
	
			start: function start() {
				var that = $(this).resizable("instance"),
				    o = that.options;
	
				$(o.alsoResize).each(function () {
					var el = $(this);
					el.data("ui-resizable-alsoresize", {
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
						left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
					});
				});
			},
	
			resize: function resize(event, ui) {
				var that = $(this).resizable("instance"),
				    o = that.options,
				    os = that.originalSize,
				    op = that.originalPosition,
				    delta = {
					height: that.size.height - os.height || 0,
					width: that.size.width - os.width || 0,
					top: that.position.top - op.top || 0,
					left: that.position.left - op.left || 0
				};
	
				$(o.alsoResize).each(function () {
					var el = $(this),
					    start = $(this).data("ui-resizable-alsoresize"),
					    style = {},
					    css = el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
	
					$.each(css, function (i, prop) {
						var sum = (start[prop] || 0) + (delta[prop] || 0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});
	
					el.css(style);
				});
			},
	
			stop: function stop() {
				$(this).removeData("resizable-alsoresize");
			}
		});
	
		$.ui.plugin.add("resizable", "ghost", {
	
			start: function start() {
	
				var that = $(this).resizable("instance"),
				    o = that.options,
				    cs = that.size;
	
				that.ghost = that.originalElement.clone();
				that.ghost.css({
					opacity: 0.25,
					display: "block",
					position: "relative",
					height: cs.height,
					width: cs.width,
					margin: 0,
					left: 0,
					top: 0
				}).addClass("ui-resizable-ghost").addClass(typeof o.ghost === "string" ? o.ghost : "");
	
				that.ghost.appendTo(that.helper);
			},
	
			resize: function resize() {
				var that = $(this).resizable("instance");
				if (that.ghost) {
					that.ghost.css({
						position: "relative",
						height: that.size.height,
						width: that.size.width
					});
				}
			},
	
			stop: function stop() {
				var that = $(this).resizable("instance");
				if (that.ghost && that.helper) {
					that.helper.get(0).removeChild(that.ghost.get(0));
				}
			}
	
		});
	
		$.ui.plugin.add("resizable", "grid", {
	
			resize: function resize() {
				var outerDimensions,
				    that = $(this).resizable("instance"),
				    o = that.options,
				    cs = that.size,
				    os = that.originalSize,
				    op = that.originalPosition,
				    a = that.axis,
				    grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
				    gridX = grid[0] || 1,
				    gridY = grid[1] || 1,
				    ox = Math.round((cs.width - os.width) / gridX) * gridX,
				    oy = Math.round((cs.height - os.height) / gridY) * gridY,
				    newWidth = os.width + ox,
				    newHeight = os.height + oy,
				    isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
				    isMaxHeight = o.maxHeight && o.maxHeight < newHeight,
				    isMinWidth = o.minWidth && o.minWidth > newWidth,
				    isMinHeight = o.minHeight && o.minHeight > newHeight;
	
				o.grid = grid;
	
				if (isMinWidth) {
					newWidth += gridX;
				}
				if (isMinHeight) {
					newHeight += gridY;
				}
				if (isMaxWidth) {
					newWidth -= gridX;
				}
				if (isMaxHeight) {
					newHeight -= gridY;
				}
	
				if (/^(se|s|e)$/.test(a)) {
					that.size.width = newWidth;
					that.size.height = newHeight;
				} else if (/^(ne)$/.test(a)) {
					that.size.width = newWidth;
					that.size.height = newHeight;
					that.position.top = op.top - oy;
				} else if (/^(sw)$/.test(a)) {
					that.size.width = newWidth;
					that.size.height = newHeight;
					that.position.left = op.left - ox;
				} else {
					if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
						outerDimensions = that._getPaddingPlusBorderDimensions(this);
					}
	
					if (newHeight - gridY > 0) {
						that.size.height = newHeight;
						that.position.top = op.top - oy;
					} else {
						newHeight = gridY - outerDimensions.height;
						that.size.height = newHeight;
						that.position.top = op.top + os.height - newHeight;
					}
					if (newWidth - gridX > 0) {
						that.size.width = newWidth;
						that.position.left = op.left - ox;
					} else {
						newWidth = gridX - outerDimensions.width;
						that.size.width = newWidth;
						that.position.left = op.left + os.width - newWidth;
					}
				}
			}
	
		});
	
		return $.ui.resizable;
	});

/***/ }),
/* 74 */
/*!**********************************!*\
  !*** ./~/object-assign/index.js ***!
  \**********************************/
/***/ (function(module, exports) {

	'use strict';
	
	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	module.exports = Object.assign || function (target, source) {
		var pendingException;
		var from;
		var keys;
		var to = ToObject(target);
	
		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = Object.keys(Object(from));
	
			for (var i = 0; i < keys.length; i++) {
				try {
					to[keys[i]] = from[keys[i]];
				} catch (err) {
					if (pendingException === undefined) {
						pendingException = err;
					}
				}
			}
		}
	
		if (pendingException) {
			throw pendingException;
		}
	
		return to;
	};

/***/ }),
/* 75 */
/*!***********************************!*\
  !*** ./~/react-mdl/lib/Button.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    accent: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    colored: _react.PropTypes.bool,
	    component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element, _react.PropTypes.func]),
	    href: _react.PropTypes.string,
	    primary: _react.PropTypes.bool,
	    raised: _react.PropTypes.bool,
	    ripple: _react.PropTypes.bool
	};
	
	// eslint-disable-next-line react/prefer-stateless-function
	
	var Button = function (_React$Component) {
	    _inherits(Button, _React$Component);
	
	    function Button() {
	        _classCallCheck(this, Button);
	
	        return _possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
	    }
	
	    _createClass(Button, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                accent = _props.accent,
	                className = _props.className,
	                colored = _props.colored,
	                primary = _props.primary,
	                raised = _props.raised,
	                ripple = _props.ripple,
	                component = _props.component,
	                href = _props.href,
	                children = _props.children,
	                otherProps = _objectWithoutProperties(_props, ['accent', 'className', 'colored', 'primary', 'raised', 'ripple', 'component', 'href', 'children']);
	
	            var buttonClasses = (0, _classnames2.default)('mdl-button mdl-js-button', {
	                'mdl-js-ripple-effect': ripple,
	                'mdl-button--raised': raised,
	                'mdl-button--colored': colored,
	                'mdl-button--primary': primary,
	                'mdl-button--accent': accent
	            }, className);
	
	            return _react2.default.createElement(component || (href ? 'a' : 'button'), _extends({
	                className: buttonClasses,
	                href: href
	            }, otherProps), children);
	        }
	    }]);
	
	    return Button;
	}(_react2.default.Component);
	
	Button.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Button);

/***/ }),
/* 76 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/Layout/Spacer.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _basicClassCreator = __webpack_require__(/*! ../utils/basicClassCreator */ 28);
	
	var _basicClassCreator2 = _interopRequireDefault(_basicClassCreator);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _basicClassCreator2.default)('Spacer', 'mdl-layout-spacer');

/***/ }),
/* 77 */
/*!****************************************!*\
  !*** ./~/react-mdl/lib/Tabs/TabBar.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    activeTab: _react.PropTypes.number,
	    className: _react.PropTypes.string,
	    cssPrefix: _react.PropTypes.string.isRequired,
	    onChange: _react.PropTypes.func
	};
	
	var defaultProps = {
	    activeTab: 0
	};
	
	var TabBar = function (_React$Component) {
	    _inherits(TabBar, _React$Component);
	
	    function TabBar(props) {
	        _classCallCheck(this, TabBar);
	
	        var _this = _possibleConstructorReturn(this, (TabBar.__proto__ || Object.getPrototypeOf(TabBar)).call(this, props));
	
	        _this.handleClickTab = _this.handleClickTab.bind(_this);
	        return _this;
	    }
	
	    _createClass(TabBar, [{
	        key: 'handleClickTab',
	        value: function handleClickTab(tabId) {
	            if (this.props.onChange) {
	                this.props.onChange(tabId);
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            var _props = this.props,
	                activeTab = _props.activeTab,
	                className = _props.className,
	                cssPrefix = _props.cssPrefix,
	                children = _props.children,
	                otherProps = _objectWithoutProperties(_props, ['activeTab', 'className', 'cssPrefix', 'children']);
	
	            var classes = (0, _classnames2.default)(_defineProperty({}, cssPrefix + '__tab-bar', true), className);
	
	            return _react2.default.createElement('div', _extends({ className: classes }, otherProps), _react2.default.Children.map(children, function (child, tabId) {
	                return _react2.default.cloneElement(child, {
	                    cssPrefix: cssPrefix,
	                    tabId: tabId,
	                    active: tabId === activeTab,
	                    onTabClick: _this2.handleClickTab
	                });
	            }));
	        }
	    }]);
	
	    return TabBar;
	}(_react2.default.Component);
	
	TabBar.propTypes = propTypes;
	TabBar.defaultProps = defaultProps;
	
	exports.default = TabBar;

/***/ }),
/* 78 */
/*!***********************************************!*\
  !*** ./~/react-mdl/lib/utils/MDLComponent.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var MDLComponent = function (_Component) {
	    _inherits(MDLComponent, _Component);
	
	    function MDLComponent() {
	        _classCallCheck(this, MDLComponent);
	
	        return _possibleConstructorReturn(this, (MDLComponent.__proto__ || Object.getPrototypeOf(MDLComponent)).apply(this, arguments));
	    }
	
	    _createClass(MDLComponent, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.recursive) {
	                window.componentHandler.upgradeElements((0, _reactDom.findDOMNode)(this));
	            } else {
	                window.componentHandler.upgradeElement((0, _reactDom.findDOMNode)(this));
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            window.componentHandler.downgradeElements((0, _reactDom.findDOMNode)(this));
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react.Children.only(this.props.children);
	        }
	    }]);
	
	    return MDLComponent;
	}(_react.Component);
	
	exports.default = MDLComponent;
	
	MDLComponent.propTypes = {
	    recursive: _react.PropTypes.bool
	};

/***/ }),
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */
/*!**********************************************!*\
  !*** ./~/dialog-polyfill/dialog-polyfill.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	(function () {
	
	  // nb. This is for IE10 and lower _only_.
	  var supportCustomEvent = window.CustomEvent;
	  if (!supportCustomEvent || (typeof supportCustomEvent === 'undefined' ? 'undefined' : _typeof(supportCustomEvent)) === 'object') {
	    supportCustomEvent = function CustomEvent(event, x) {
	      x = x || {};
	      var ev = document.createEvent('CustomEvent');
	      ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);
	      return ev;
	    };
	    supportCustomEvent.prototype = window.Event.prototype;
	  }
	
	  /**
	   * @param {Element} el to check for stacking context
	   * @return {boolean} whether this el or its parents creates a stacking context
	   */
	  function createsStackingContext(el) {
	    while (el && el !== document.body) {
	      var s = window.getComputedStyle(el);
	      var invalid = function invalid(k, ok) {
	        return !(s[k] === undefined || s[k] === ok);
	      };
	      if (s.opacity < 1 || invalid('zIndex', 'auto') || invalid('transform', 'none') || invalid('mixBlendMode', 'normal') || invalid('filter', 'none') || invalid('perspective', 'none') || s['isolation'] === 'isolate' || s.position === 'fixed' || s.webkitOverflowScrolling === 'touch') {
	        return true;
	      }
	      el = el.parentElement;
	    }
	    return false;
	  }
	
	  /**
	   * Finds the nearest <dialog> from the passed element.
	   *
	   * @param {Element} el to search from
	   * @return {HTMLDialogElement} dialog found
	   */
	  function findNearestDialog(el) {
	    while (el) {
	      if (el.localName === 'dialog') {
	        return (/** @type {HTMLDialogElement} */el
	        );
	      }
	      el = el.parentElement;
	    }
	    return null;
	  }
	
	  /**
	   * Blur the specified element, as long as it's not the HTML body element.
	   * This works around an IE9/10 bug - blurring the body causes Windows to
	   * blur the whole application.
	   *
	   * @param {Element} el to blur
	   */
	  function safeBlur(el) {
	    if (el && el.blur && el !== document.body) {
	      el.blur();
	    }
	  }
	
	  /**
	   * @param {!NodeList} nodeList to search
	   * @param {Node} node to find
	   * @return {boolean} whether node is inside nodeList
	   */
	  function inNodeList(nodeList, node) {
	    for (var i = 0; i < nodeList.length; ++i) {
	      if (nodeList[i] === node) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * @param {HTMLFormElement} el to check
	   * @return {boolean} whether this form has method="dialog"
	   */
	  function isFormMethodDialog(el) {
	    if (!el || !el.hasAttribute('method')) {
	      return false;
	    }
	    return el.getAttribute('method').toLowerCase() === 'dialog';
	  }
	
	  /**
	   * @param {!HTMLDialogElement} dialog to upgrade
	   * @constructor
	   */
	  function dialogPolyfillInfo(dialog) {
	    this.dialog_ = dialog;
	    this.replacedStyleTop_ = false;
	    this.openAsModal_ = false;
	
	    // Set a11y role. Browsers that support dialog implicitly know this already.
	    if (!dialog.hasAttribute('role')) {
	      dialog.setAttribute('role', 'dialog');
	    }
	
	    dialog.show = this.show.bind(this);
	    dialog.showModal = this.showModal.bind(this);
	    dialog.close = this.close.bind(this);
	
	    if (!('returnValue' in dialog)) {
	      dialog.returnValue = '';
	    }
	
	    if ('MutationObserver' in window) {
	      var mo = new MutationObserver(this.maybeHideModal.bind(this));
	      mo.observe(dialog, { attributes: true, attributeFilter: ['open'] });
	    } else {
	      // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also
	      // seem to fire even if the element was removed as part of a parent removal. Use the removed
	      // events to force downgrade (useful if removed/immediately added).
	      var removed = false;
	      var cb = function () {
	        removed ? this.downgradeModal() : this.maybeHideModal();
	        removed = false;
	      }.bind(this);
	      var timeout;
	      var delayModel = function delayModel(ev) {
	        if (ev.target !== dialog) {
	          return;
	        } // not for a child element
	        var cand = 'DOMNodeRemoved';
	        removed |= ev.type.substr(0, cand.length) === cand;
	        window.clearTimeout(timeout);
	        timeout = window.setTimeout(cb, 0);
	      };
	      ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function (name) {
	        dialog.addEventListener(name, delayModel);
	      });
	    }
	    // Note that the DOM is observed inside DialogManager while any dialog
	    // is being displayed as a modal, to catch modal removal from the DOM.
	
	    Object.defineProperty(dialog, 'open', {
	      set: this.setOpen.bind(this),
	      get: dialog.hasAttribute.bind(dialog, 'open')
	    });
	
	    this.backdrop_ = document.createElement('div');
	    this.backdrop_.className = 'backdrop';
	    this.backdrop_.addEventListener('click', this.backdropClick_.bind(this));
	  }
	
	  dialogPolyfillInfo.prototype = {
	
	    get dialog() {
	      return this.dialog_;
	    },
	
	    /**
	     * Maybe remove this dialog from the modal top layer. This is called when
	     * a modal dialog may no longer be tenable, e.g., when the dialog is no
	     * longer open or is no longer part of the DOM.
	     */
	    maybeHideModal: function maybeHideModal() {
	      if (this.dialog_.hasAttribute('open') && document.body.contains(this.dialog_)) {
	        return;
	      }
	      this.downgradeModal();
	    },
	
	    /**
	     * Remove this dialog from the modal top layer, leaving it as a non-modal.
	     */
	    downgradeModal: function downgradeModal() {
	      if (!this.openAsModal_) {
	        return;
	      }
	      this.openAsModal_ = false;
	      this.dialog_.style.zIndex = '';
	
	      // This won't match the native <dialog> exactly because if the user set top on a centered
	      // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's
	      // possible to polyfill this perfectly.
	      if (this.replacedStyleTop_) {
	        this.dialog_.style.top = '';
	        this.replacedStyleTop_ = false;
	      }
	
	      // Clear the backdrop and remove from the manager.
	      this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);
	      dialogPolyfill.dm.removeDialog(this);
	    },
	
	    /**
	     * @param {boolean} value whether to open or close this dialog
	     */
	    setOpen: function setOpen(value) {
	      if (value) {
	        this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');
	      } else {
	        this.dialog_.removeAttribute('open');
	        this.maybeHideModal(); // nb. redundant with MutationObserver
	      }
	    },
	
	    /**
	     * Handles clicks on the fake .backdrop element, redirecting them as if
	     * they were on the dialog itself.
	     *
	     * @param {!Event} e to redirect
	     */
	    backdropClick_: function backdropClick_(e) {
	      if (!this.dialog_.hasAttribute('tabindex')) {
	        // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be
	        // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this
	        // would not be needed - clicks would move the implicit cursor there.
	        var fake = document.createElement('div');
	        this.dialog_.insertBefore(fake, this.dialog_.firstChild);
	        fake.tabIndex = -1;
	        fake.focus();
	        this.dialog_.removeChild(fake);
	      } else {
	        this.dialog_.focus();
	      }
	
	      var redirectedEvent = document.createEvent('MouseEvents');
	      redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
	      this.dialog_.dispatchEvent(redirectedEvent);
	      e.stopPropagation();
	    },
	
	    /**
	     * Focuses on the first focusable element within the dialog. This will always blur the current
	     * focus, even if nothing within the dialog is found.
	     */
	    focus_: function focus_() {
	      // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.
	      var target = this.dialog_.querySelector('[autofocus]:not([disabled])');
	      if (!target && this.dialog_.tabIndex >= 0) {
	        target = this.dialog_;
	      }
	      if (!target) {
	        // Note that this is 'any focusable area'. This list is probably not exhaustive, but the
	        // alternative involves stepping through and trying to focus everything.
	        var opts = ['button', 'input', 'keygen', 'select', 'textarea'];
	        var query = opts.map(function (el) {
	          return el + ':not([disabled])';
	        });
	        // TODO(samthor): tabindex values that are not numeric are not focusable.
	        query.push('[tabindex]:not([disabled]):not([tabindex=""])'); // tabindex != "", not disabled
	        target = this.dialog_.querySelector(query.join(', '));
	      }
	      safeBlur(document.activeElement);
	      target && target.focus();
	    },
	
	    /**
	     * Sets the zIndex for the backdrop and dialog.
	     *
	     * @param {number} dialogZ
	     * @param {number} backdropZ
	     */
	    updateZIndex: function updateZIndex(dialogZ, backdropZ) {
	      if (dialogZ < backdropZ) {
	        throw new Error('dialogZ should never be < backdropZ');
	      }
	      this.dialog_.style.zIndex = dialogZ;
	      this.backdrop_.style.zIndex = backdropZ;
	    },
	
	    /**
	     * Shows the dialog. If the dialog is already open, this does nothing.
	     */
	    show: function show() {
	      if (!this.dialog_.open) {
	        this.setOpen(true);
	        this.focus_();
	      }
	    },
	
	    /**
	     * Show this dialog modally.
	     */
	    showModal: function showModal() {
	      if (this.dialog_.hasAttribute('open')) {
	        throw new Error('Failed to execute \'showModal\' on dialog: The element is already open, and therefore cannot be opened modally.');
	      }
	      if (!document.body.contains(this.dialog_)) {
	        throw new Error('Failed to execute \'showModal\' on dialog: The element is not in a Document.');
	      }
	      if (!dialogPolyfill.dm.pushDialog(this)) {
	        throw new Error('Failed to execute \'showModal\' on dialog: There are too many open modal dialogs.');
	      }
	
	      if (createsStackingContext(this.dialog_.parentElement)) {
	        console.warn('A dialog is being shown inside a stacking context. ' + 'This may cause it to be unusable. For more information, see this link: ' + 'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');
	      }
	
	      this.setOpen(true);
	      this.openAsModal_ = true;
	
	      // Optionally center vertically, relative to the current viewport.
	      if (dialogPolyfill.needsCentering(this.dialog_)) {
	        dialogPolyfill.reposition(this.dialog_);
	        this.replacedStyleTop_ = true;
	      } else {
	        this.replacedStyleTop_ = false;
	      }
	
	      // Insert backdrop.
	      this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);
	
	      // Focus on whatever inside the dialog.
	      this.focus_();
	    },
	
	    /**
	     * Closes this HTMLDialogElement. This is optional vs clearing the open
	     * attribute, however this fires a 'close' event.
	     *
	     * @param {string=} opt_returnValue to use as the returnValue
	     */
	    close: function close(opt_returnValue) {
	      if (!this.dialog_.hasAttribute('open')) {
	        throw new Error('Failed to execute \'close\' on dialog: The element does not have an \'open\' attribute, and therefore cannot be closed.');
	      }
	      this.setOpen(false);
	
	      // Leave returnValue untouched in case it was set directly on the element
	      if (opt_returnValue !== undefined) {
	        this.dialog_.returnValue = opt_returnValue;
	      }
	
	      // Triggering "close" event for any attached listeners on the <dialog>.
	      var closeEvent = new supportCustomEvent('close', {
	        bubbles: false,
	        cancelable: false
	      });
	      this.dialog_.dispatchEvent(closeEvent);
	    }
	
	  };
	
	  var dialogPolyfill = {};
	
	  dialogPolyfill.reposition = function (element) {
	    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
	    var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;
	    element.style.top = Math.max(scrollTop, topValue) + 'px';
	  };
	
	  dialogPolyfill.isInlinePositionSetByStylesheet = function (element) {
	    for (var i = 0; i < document.styleSheets.length; ++i) {
	      var styleSheet = document.styleSheets[i];
	      var cssRules = null;
	      // Some browsers throw on cssRules.
	      try {
	        cssRules = styleSheet.cssRules;
	      } catch (e) {}
	      if (!cssRules) {
	        continue;
	      }
	      for (var j = 0; j < cssRules.length; ++j) {
	        var rule = cssRules[j];
	        var selectedNodes = null;
	        // Ignore errors on invalid selector texts.
	        try {
	          selectedNodes = document.querySelectorAll(rule.selectorText);
	        } catch (e) {}
	        if (!selectedNodes || !inNodeList(selectedNodes, element)) {
	          continue;
	        }
	        var cssTop = rule.style.getPropertyValue('top');
	        var cssBottom = rule.style.getPropertyValue('bottom');
	        if (cssTop && cssTop !== 'auto' || cssBottom && cssBottom !== 'auto') {
	          return true;
	        }
	      }
	    }
	    return false;
	  };
	
	  dialogPolyfill.needsCentering = function (dialog) {
	    var computedStyle = window.getComputedStyle(dialog);
	    if (computedStyle.position !== 'absolute') {
	      return false;
	    }
	
	    // We must determine whether the top/bottom specified value is non-auto.  In
	    // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but
	    // Firefox returns the used value. So we do this crazy thing instead: check
	    // the inline style and then go through CSS rules.
	    if (dialog.style.top !== 'auto' && dialog.style.top !== '' || dialog.style.bottom !== 'auto' && dialog.style.bottom !== '') {
	      return false;
	    }
	    return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);
	  };
	
	  /**
	   * @param {!Element} element to force upgrade
	   */
	  dialogPolyfill.forceRegisterDialog = function (element) {
	    if (window.HTMLDialogElement || element.showModal) {
	      console.warn('This browser already supports <dialog>, the polyfill ' + 'may not work correctly', element);
	    }
	    if (element.localName !== 'dialog') {
	      throw new Error('Failed to register dialog: The element is not a dialog.');
	    }
	    new dialogPolyfillInfo( /** @type {!HTMLDialogElement} */element);
	  };
	
	  /**
	   * @param {!Element} element to upgrade, if necessary
	   */
	  dialogPolyfill.registerDialog = function (element) {
	    if (!element.showModal) {
	      dialogPolyfill.forceRegisterDialog(element);
	    }
	  };
	
	  /**
	   * @constructor
	   */
	  dialogPolyfill.DialogManager = function () {
	    /** @type {!Array<!dialogPolyfillInfo>} */
	    this.pendingDialogStack = [];
	
	    var checkDOM = this.checkDOM_.bind(this);
	
	    // The overlay is used to simulate how a modal dialog blocks the document.
	    // The blocking dialog is positioned on top of the overlay, and the rest of
	    // the dialogs on the pending dialog stack are positioned below it. In the
	    // actual implementation, the modal dialog stacking is controlled by the
	    // top layer, where z-index has no effect.
	    this.overlay = document.createElement('div');
	    this.overlay.className = '_dialog_overlay';
	    this.overlay.addEventListener('click', function (e) {
	      this.forwardTab_ = undefined;
	      e.stopPropagation();
	      checkDOM([]); // sanity-check DOM
	    }.bind(this));
	
	    this.handleKey_ = this.handleKey_.bind(this);
	    this.handleFocus_ = this.handleFocus_.bind(this);
	
	    this.zIndexLow_ = 100000;
	    this.zIndexHigh_ = 100000 + 150;
	
	    this.forwardTab_ = undefined;
	
	    if ('MutationObserver' in window) {
	      this.mo_ = new MutationObserver(function (records) {
	        var removed = [];
	        records.forEach(function (rec) {
	          for (var i = 0, c; c = rec.removedNodes[i]; ++i) {
	            if (!(c instanceof Element)) {
	              continue;
	            } else if (c.localName === 'dialog') {
	              removed.push(c);
	            }
	            removed = removed.concat(c.querySelectorAll('dialog'));
	          }
	        });
	        removed.length && checkDOM(removed);
	      });
	    }
	  };
	
	  /**
	   * Called on the first modal dialog being shown. Adds the overlay and related
	   * handlers.
	   */
	  dialogPolyfill.DialogManager.prototype.blockDocument = function () {
	    document.documentElement.addEventListener('focus', this.handleFocus_, true);
	    document.addEventListener('keydown', this.handleKey_);
	    this.mo_ && this.mo_.observe(document, { childList: true, subtree: true });
	  };
	
	  /**
	   * Called on the first modal dialog being removed, i.e., when no more modal
	   * dialogs are visible.
	   */
	  dialogPolyfill.DialogManager.prototype.unblockDocument = function () {
	    document.documentElement.removeEventListener('focus', this.handleFocus_, true);
	    document.removeEventListener('keydown', this.handleKey_);
	    this.mo_ && this.mo_.disconnect();
	  };
	
	  /**
	   * Updates the stacking of all known dialogs.
	   */
	  dialogPolyfill.DialogManager.prototype.updateStacking = function () {
	    var zIndex = this.zIndexHigh_;
	
	    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
	      dpi.updateZIndex(--zIndex, --zIndex);
	      if (i === 0) {
	        this.overlay.style.zIndex = --zIndex;
	      }
	    }
	
	    // Make the overlay a sibling of the dialog itself.
	    var last = this.pendingDialogStack[0];
	    if (last) {
	      var p = last.dialog.parentNode || document.body;
	      p.appendChild(this.overlay);
	    } else if (this.overlay.parentNode) {
	      this.overlay.parentNode.removeChild(this.overlay);
	    }
	  };
	
	  /**
	   * @param {Element} candidate to check if contained or is the top-most modal dialog
	   * @return {boolean} whether candidate is contained in top dialog
	   */
	  dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function (candidate) {
	    while (candidate = findNearestDialog(candidate)) {
	      for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
	        if (dpi.dialog === candidate) {
	          return i === 0; // only valid if top-most
	        }
	      }
	      candidate = candidate.parentElement;
	    }
	    return false;
	  };
	
	  dialogPolyfill.DialogManager.prototype.handleFocus_ = function (event) {
	    if (this.containedByTopDialog_(event.target)) {
	      return;
	    }
	
	    event.preventDefault();
	    event.stopPropagation();
	    safeBlur( /** @type {Element} */event.target);
	
	    if (this.forwardTab_ === undefined) {
	      return;
	    } // move focus only from a tab key
	
	    var dpi = this.pendingDialogStack[0];
	    var dialog = dpi.dialog;
	    var position = dialog.compareDocumentPosition(event.target);
	    if (position & Node.DOCUMENT_POSITION_PRECEDING) {
	      if (this.forwardTab_) {
	        // forward
	        dpi.focus_();
	      } else {
	        // backwards
	        document.documentElement.focus();
	      }
	    } else {
	      // TODO: Focus after the dialog, is ignored.
	    }
	
	    return false;
	  };
	
	  dialogPolyfill.DialogManager.prototype.handleKey_ = function (event) {
	    this.forwardTab_ = undefined;
	    if (event.keyCode === 27) {
	      event.preventDefault();
	      event.stopPropagation();
	      var cancelEvent = new supportCustomEvent('cancel', {
	        bubbles: false,
	        cancelable: true
	      });
	      var dpi = this.pendingDialogStack[0];
	      if (dpi && dpi.dialog.dispatchEvent(cancelEvent)) {
	        dpi.dialog.close();
	      }
	    } else if (event.keyCode === 9) {
	      this.forwardTab_ = !event.shiftKey;
	    }
	  };
	
	  /**
	   * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are
	   * removed and immediately readded don't stay modal, they become normal.
	   *
	   * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed
	   */
	  dialogPolyfill.DialogManager.prototype.checkDOM_ = function (removed) {
	    // This operates on a clone because it may cause it to change. Each change also calls
	    // updateStacking, which only actually needs to happen once. But who removes many modal dialogs
	    // at a time?!
	    var clone = this.pendingDialogStack.slice();
	    clone.forEach(function (dpi) {
	      if (removed.indexOf(dpi.dialog) !== -1) {
	        dpi.downgradeModal();
	      } else {
	        dpi.maybeHideModal();
	      }
	    });
	  };
	
	  /**
	   * @param {!dialogPolyfillInfo} dpi
	   * @return {boolean} whether the dialog was allowed
	   */
	  dialogPolyfill.DialogManager.prototype.pushDialog = function (dpi) {
	    var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;
	    if (this.pendingDialogStack.length >= allowed) {
	      return false;
	    }
	    if (this.pendingDialogStack.unshift(dpi) === 1) {
	      this.blockDocument();
	    }
	    this.updateStacking();
	    return true;
	  };
	
	  /**
	   * @param {!dialogPolyfillInfo} dpi
	   */
	  dialogPolyfill.DialogManager.prototype.removeDialog = function (dpi) {
	    var index = this.pendingDialogStack.indexOf(dpi);
	    if (index === -1) {
	      return;
	    }
	
	    this.pendingDialogStack.splice(index, 1);
	    if (this.pendingDialogStack.length === 0) {
	      this.unblockDocument();
	    }
	    this.updateStacking();
	  };
	
	  dialogPolyfill.dm = new dialogPolyfill.DialogManager();
	  dialogPolyfill.formSubmitter = null;
	  dialogPolyfill.useValue = null;
	
	  /**
	   * Installs global handlers, such as click listers and native method overrides. These are needed
	   * even if a no dialog is registered, as they deal with <form method="dialog">.
	   */
	  if (window.HTMLDialogElement === undefined) {
	    var replacementFormSubmit = function replacementFormSubmit() {
	      if (!isFormMethodDialog(this)) {
	        return nativeFormSubmit.call(this);
	      }
	      var dialog = findNearestDialog(this);
	      dialog && dialog.close();
	    };
	
	    /**
	     * If HTMLFormElement translates method="DIALOG" into 'get', then replace the descriptor with
	     * one that returns the correct value.
	     */
	    var testForm = document.createElement('form');
	    testForm.setAttribute('method', 'dialog');
	    if (testForm.method !== 'dialog') {
	      var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');
	      if (methodDescriptor) {
	        // TODO: older iOS and older PhantomJS fail to return the descriptor here
	        var realGet = methodDescriptor.get;
	        methodDescriptor.get = function () {
	          if (isFormMethodDialog(this)) {
	            return 'dialog';
	          }
	          return realGet.call(this);
	        };
	        var realSet = methodDescriptor.set;
	        methodDescriptor.set = function (v) {
	          if (typeof v === 'string' && v.toLowerCase() === 'dialog') {
	            return this.setAttribute('method', v);
	          }
	          return realSet.call(this, v);
	        };
	        Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);
	      }
	    }
	
	    /**
	     * Global 'click' handler, to capture the <input type="submit"> or <button> element which has
	     * submitted a <form method="dialog">. Needed as Safari and others don't report this inside
	     * document.activeElement.
	     */
	    document.addEventListener('click', function (ev) {
	      dialogPolyfill.formSubmitter = null;
	      dialogPolyfill.useValue = null;
	      if (ev.defaultPrevented) {
	        return;
	      } // e.g. a submit which prevents default submission
	
	      var target = /** @type {Element} */ev.target;
	      if (!target || !isFormMethodDialog(target.form)) {
	        return;
	      }
	
	      var valid = target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1;
	      if (!valid) {
	        if (!(target.localName === 'input' && target.type === 'image')) {
	          return;
	        }
	        // this is a <input type="image">, which can submit forms
	        dialogPolyfill.useValue = ev.offsetX + ',' + ev.offsetY;
	      }
	
	      var dialog = findNearestDialog(target);
	      if (!dialog) {
	        return;
	      }
	
	      dialogPolyfill.formSubmitter = target;
	    }, false);
	
	    /**
	     * Replace the native HTMLFormElement.submit() method, as it won't fire the
	     * submit event and give us a chance to respond.
	     */
	    var nativeFormSubmit = HTMLFormElement.prototype.submit;
	
	    HTMLFormElement.prototype.submit = replacementFormSubmit;
	
	    /**
	     * Global form 'dialog' method handler. Closes a dialog correctly on submit
	     * and possibly sets its return value.
	     */
	    document.addEventListener('submit', function (ev) {
	      var form = /** @type {HTMLFormElement} */ev.target;
	      if (!isFormMethodDialog(form)) {
	        return;
	      }
	      ev.preventDefault();
	
	      var dialog = findNearestDialog(form);
	      if (!dialog) {
	        return;
	      }
	
	      // Forms can only be submitted via .submit() or a click (?), but anyway: sanity-check that
	      // the submitter is correct before using its value as .returnValue.
	      var s = dialogPolyfill.formSubmitter;
	      if (s && s.form === form) {
	        dialog.close(dialogPolyfill.useValue || s.value);
	      } else {
	        dialog.close();
	      }
	      dialogPolyfill.formSubmitter = null;
	    }, true);
	  }
	
	  dialogPolyfill['forceRegisterDialog'] = dialogPolyfill.forceRegisterDialog;
	  dialogPolyfill['registerDialog'] = dialogPolyfill.registerDialog;
	
	  if ("function" === 'function' && 'amd' in __webpack_require__(/*! !webpack amd define */ 427)) {
	    // AMD support
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return dialogPolyfill;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (( false ? 'undefined' : _typeof(module)) === 'object' && _typeof(module['exports']) === 'object') {
	    // CommonJS support
	    module['exports'] = dialogPolyfill;
	  } else {
	    // all others
	    window['dialogPolyfill'] = dialogPolyfill;
	  }
	})();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/module.js */ 38)(module)))

/***/ }),
/* 111 */,
/* 112 */
/*!*************************************!*\
  !*** ./~/fbjs/lib/emptyFunction.js ***!
  \*************************************/
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ }),
/* 113 */
/*!***************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/ExecutionEnvironment.js ***!
  \***************************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	/*jslint evil: true */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ }),
/* 114 */
/*!********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableCellDefault.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	var _joinClasses = __webpack_require__(/*! ./joinClasses */ 35);
	
	var _joinClasses2 = _interopRequireDefault(_joinClasses);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * Copyright Schrodinger, LLC
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * @providesModule FixedDataTableCellDefault
	   * @typechecks
	   */
	
	/**
	 * Component that handles default cell layout and styling.
	 *
	 * All props unless specified below will be set onto the top level `div`
	 * rendered by the cell.
	 *
	 * Example usage via from a `Column`:
	 * ```
	 * const MyColumn = (
	 *   <Column
	 *     cell={({rowIndex, width, height}) => (
	 *       <Cell
	 *         width={width}
	 *         height={height}
	 *         className="my-class">
	 *         Cell number: <span>{rowIndex}</span>
	*        </Cell>
	 *     )}
	 *     width={100}
	 *   />
	 * );
	 * ```
	 */
	var FixedDataTableCellDefault = function (_React$Component) {
	  _inherits(FixedDataTableCellDefault, _React$Component);
	
	  function FixedDataTableCellDefault() {
	    _classCallCheck(this, FixedDataTableCellDefault);
	
	    return _possibleConstructorReturn(this, (FixedDataTableCellDefault.__proto__ || Object.getPrototypeOf(FixedDataTableCellDefault)).apply(this, arguments));
	  }
	
	  _createClass(FixedDataTableCellDefault, [{
	    key: 'render',
	    value: function render() {
	      //Remove some props like columnKey and rowIndex so we don't pass it into the div
	      var _props = this.props,
	          height = _props.height,
	          width = _props.width,
	          style = _props.style,
	          className = _props.className,
	          children = _props.children,
	          columnKey = _props.columnKey,
	          rowIndex = _props.rowIndex,
	          props = _objectWithoutProperties(_props, ['height', 'width', 'style', 'className', 'children', 'columnKey', 'rowIndex']);
	
	      var innerStyle = _extends({
	        height: height,
	        width: width
	      }, style);
	
	      return _React2.default.createElement('div', _extends({}, props, {
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableCellLayout/wrap1'), (0, _cx2.default)('public/fixedDataTableCell/wrap1'), className),
	        style: innerStyle }), _React2.default.createElement('div', {
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableCellLayout/wrap2'), (0, _cx2.default)('public/fixedDataTableCell/wrap2')) }, _React2.default.createElement('div', {
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableCellLayout/wrap3'), (0, _cx2.default)('public/fixedDataTableCell/wrap3')) }, _React2.default.createElement('div', { className: (0, _cx2.default)('public/fixedDataTableCell/cellContent') }, children))));
	    }
	  }]);
	
	  return FixedDataTableCellDefault;
	}(_React2.default.Component);
	
	FixedDataTableCellDefault.propTypes = {
	
	  /**
	   * Outer height of the cell.
	   */
	  height: _propTypes2.default.number,
	
	  /**
	   * Outer width of the cell.
	   */
	  width: _propTypes2.default.number,
	
	  /**
	   * Optional prop that if specified on the `Column` will be passed to the
	   * cell. It can be used to uniquely identify which column is the cell is in.
	   */
	  columnKey: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
	
	  /**
	   * Optional prop that represents the rows index in the table.
	   * For the 'cell' prop of a Column, this parameter will exist for any
	   * cell in a row with a positive index.
	   *
	   * Below that entry point the user is welcome to consume or
	   * pass the prop through at their discretion.
	   */
	  rowIndex: _propTypes2.default.number
	};
	
	module.exports = FixedDataTableCellDefault;

/***/ }),
/* 115 */
/*!***************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableColumn.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * Copyright Schrodinger, LLC
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * @providesModule FixedDataTableColumn
	   * @typechecks
	   */
	
	/**
	 * Component that defines the attributes of table column.
	 */
	var FixedDataTableColumn = function (_React$Component) {
	  _inherits(FixedDataTableColumn, _React$Component);
	
	  function FixedDataTableColumn() {
	    _classCallCheck(this, FixedDataTableColumn);
	
	    return _possibleConstructorReturn(this, (FixedDataTableColumn.__proto__ || Object.getPrototypeOf(FixedDataTableColumn)).apply(this, arguments));
	  }
	
	  _createClass(FixedDataTableColumn, [{
	    key: 'render',
	    value: function render() {
	      if (true) {
	        throw new Error('Component <FixedDataTableColumn /> should never render');
	      }
	      return null;
	    }
	  }]);
	
	  return FixedDataTableColumn;
	}(_React2.default.Component);
	
	FixedDataTableColumn.__TableColumn__ = true;
	FixedDataTableColumn.propTypes = {
	  /**
	   * The horizontal alignment of the table cell content.
	   */
	  align: _propTypes2.default.oneOf(['left', 'center', 'right']),
	
	  /**
	   * Controls if the column is fixed when scrolling in the X axis.
	   */
	  fixed: _propTypes2.default.bool,
	
	  /**
	   * Controls if the column is fixed to the right side of the table when scrolling in the X axis.
	   */
	  fixedRight: _propTypes2.default.bool,
	
	  /**
	   * The header cell for this column.
	   * This can either be a string a React element, or a function that generates
	   * a React Element. Passing in a string will render a default header cell
	   * with that string. By default, the React element passed in can expect to
	   * receive the following props:
	   *
	   * ```
	   * props: {
	   *   columnKey: string // (of the column, if given)
	   *   height: number // (supplied from the Table or rowHeightGetter)
	   *   width: number // (supplied from the Column)
	   * }
	   * ```
	   *
	   * Because you are passing in your own React element, you can feel free to
	   * pass in whatever props you may want or need.
	   *
	   * If you pass in a function, you will receive the same props object as the
	   * first argument.
	   */
	  header: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),
	
	  /**
	   * This is the body cell that will be cloned for this column.
	   * This can either be a string a React element, or a function that generates
	   * a React Element. Passing in a string will render a default header cell
	   * with that string. By default, the React element passed in can expect to
	   * receive the following props:
	   *
	   * ```
	   * props: {
	   *   rowIndex; number // (the row index of the cell)
	   *   columnKey: string // (of the column, if given)
	   *   height: number // (supplied from the Table or rowHeightGetter)
	   *   width: number // (supplied from the Column)
	   * }
	   * ```
	   *
	   * Because you are passing in your own React element, you can feel free to
	   * pass in whatever props you may want or need.
	   *
	   * If you pass in a function, you will receive the same props object as the
	   * first argument.
	   */
	  cell: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),
	
	  /**
	   * This is the footer cell for this column.
	   * This can either be a string a React element, or a function that generates
	   * a React Element. Passing in a string will render a default header cell
	   * with that string. By default, the React element passed in can expect to
	   * receive the following props:
	   *
	   * ```
	   * props: {
	   *   columnKey: string // (of the column, if given)
	   *   height: number // (supplied from the Table or rowHeightGetter)
	   *   width: number // (supplied from the Column)
	   * }
	   * ```
	   *
	   * Because you are passing in your own React element, you can feel free to
	   * pass in whatever props you may want or need.
	   *
	   * If you pass in a function, you will receive the same props object as the
	   * first argument.
	   */
	  footer: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),
	
	  /**
	   * This is used to uniquely identify the column, and is not required unless
	   * you a resizing columns. This will be the key given in the
	   * `onColumnResizeEndCallback` on the Table.
	   */
	  columnKey: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
	
	  /**
	   * The pixel width of the column.
	   */
	  width: _propTypes2.default.number.isRequired,
	
	  /**
	   * If this is a resizable column this is its minimum pixel width.
	   */
	  minWidth: _propTypes2.default.number,
	
	  /**
	   * If this is a resizable column this is its maximum pixel width.
	   */
	  maxWidth: _propTypes2.default.number,
	
	  /**
	   * The grow factor relative to other columns. Same as the flex-grow API
	   * from http://www.w3.org/TR/css3-flexbox/. Basically, take any available
	   * extra width and distribute it proportionally according to all columns'
	   * flexGrow values. Defaults to zero (no-flexing).
	   */
	  flexGrow: _propTypes2.default.number,
	
	  /**
	   * Whether the column can be resized with the
	   * FixedDataTableColumnResizeHandle. Please note that if a column
	   * has a flex grow, once you resize the column this will be set to 0.
	   *
	   * This property only provides the UI for the column resizing. If this
	   * is set to true, you will need to set the onColumnResizeEndCallback table
	   * property and render your columns appropriately.
	   */
	  isResizable: _propTypes2.default.bool,
	
	  /**
	   * Whether the column can be dragged to reorder.
	   */
	  isReorderable: _propTypes2.default.bool,
	
	  /**
	   * Whether cells in this column can be removed from document when outside
	   * of viewport as a result of horizontal scrolling.
	   * Setting this property to true allows the table to not render cells in
	   * particular column that are outside of viewport for visible rows. This
	   * allows to create table with many columns and not have vertical scrolling
	   * performance drop.
	   * Setting the property to false will keep previous behaviour and keep
	   * cell rendered if the row it belongs to is visible.
	   */
	  allowCellsRecycling: _propTypes2.default.bool,
	
	  /**
	   * Flag to enable performance check when rendering. Stops the component from
	   * rendering if none of it's passed in props have changed
	   */
	  pureRendering: _propTypes2.default.bool
	};
	FixedDataTableColumn.defaultProps = {
	  allowCellsRecycling: false,
	  fixed: false,
	  fixedRight: false
	};
	
	module.exports = FixedDataTableColumn;

/***/ }),
/* 116 */
/*!********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableColumnGroup.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	} /**
	   * Copyright Schrodinger, LLC
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * @providesModule FixedDataTableColumnGroup
	   * @typechecks
	   */
	
	/**
	 * Component that defines the attributes of a table column group.
	 */
	var FixedDataTableColumnGroup = function (_React$Component) {
	  _inherits(FixedDataTableColumnGroup, _React$Component);
	
	  function FixedDataTableColumnGroup() {
	    _classCallCheck(this, FixedDataTableColumnGroup);
	
	    return _possibleConstructorReturn(this, (FixedDataTableColumnGroup.__proto__ || Object.getPrototypeOf(FixedDataTableColumnGroup)).apply(this, arguments));
	  }
	
	  _createClass(FixedDataTableColumnGroup, [{
	    key: 'render',
	    value: function render() {
	      if (true) {
	        throw new Error('Component <FixedDataTableColumnGroup /> should never render');
	      }
	      return null;
	    }
	  }]);
	
	  return FixedDataTableColumnGroup;
	}(_React2.default.Component);
	
	FixedDataTableColumnGroup.__TableColumnGroup__ = true;
	FixedDataTableColumnGroup.propTypes = {
	  /**
	   * The horizontal alignment of the table cell content.
	   */
	  align: _propTypes2.default.oneOf(['left', 'center', 'right']),
	
	  /**
	   * Controls if the column group is fixed when scrolling in the X axis.
	   */
	  fixed: _propTypes2.default.bool,
	
	  /**
	   * This is the header cell for this column group.
	   * This can either be a string or a React element. Passing in a string
	   * will render a default footer cell with that string. By default, the React
	   * element passed in can expect to receive the following props:
	   *
	   * ```
	   * props: {
	   *   height: number // (supplied from the groupHeaderHeight)
	   *   width: number // (supplied from the Column)
	   * }
	   * ```
	   *
	   * Because you are passing in your own React element, you can feel free to
	   * pass in whatever props you may want or need.
	   *
	   * You can also pass in a function that returns a react elemnt, with the
	   * props object above passed in as the first parameter.
	   */
	  header: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func])
	
	};
	FixedDataTableColumnGroup.defaultProps = {
	  fixed: false
	};
	
	module.exports = FixedDataTableColumnGroup;

/***/ }),
/* 117 */
/*!***************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableHelper.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableHelper
	 * @typechecks
	 */
	
	'use strict';
	
	var _Locale = __webpack_require__(/*! ./Locale */ 69);
	
	var _Locale2 = _interopRequireDefault(_Locale);
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _FixedDataTableColumnGroup = __webpack_require__(/*! ./FixedDataTableColumnGroup */ 116);
	
	var _FixedDataTableColumnGroup2 = _interopRequireDefault(_FixedDataTableColumnGroup);
	
	var _FixedDataTableColumn = __webpack_require__(/*! ./FixedDataTableColumn */ 115);
	
	var _FixedDataTableColumn2 = _interopRequireDefault(_FixedDataTableColumn);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var DIR_SIGN = _Locale2.default.isRTL() ? -1 : +1;
	// A cell up to 5px outside of the visible area will still be considered visible
	var CELL_VISIBILITY_TOLERANCE = 5; // used for flyouts
	
	function renderToString(value) /*string*/{
	  if (value === null || value === undefined) {
	    return '';
	  } else {
	    return String(value);
	  }
	}
	
	/**
	 * Helper method to execute a callback against all columns given the children
	 * of a table.
	 * @param {?object|array} children
	 *    Children of a table.
	 * @param {function} callback
	 *    Function to excecute for each column. It is passed the column.
	 */
	function forEachColumn(children, callback) {
	  _React2.default.Children.forEach(children, function (child) {
	    if (child.type === _FixedDataTableColumnGroup2.default) {
	      forEachColumn(child.props.children, callback);
	    } else if (child.type === _FixedDataTableColumn2.default) {
	      callback(child);
	    }
	  });
	}
	
	/**
	 * Helper method to map columns to new columns. This takes into account column
	 * groups and will generate a new column group if its columns change.
	 * @param {?object|array} children
	 *    Children of a table.
	 * @param {function} callback
	 *    Function to excecute for each column. It is passed the column and should
	 *    return a result column.
	 */
	function mapColumns(children, callback) {
	  var newChildren = [];
	  _React2.default.Children.forEach(children, function (originalChild) {
	    var newChild = originalChild;
	
	    // The child is either a column group or a column. If it is a column group
	    // we need to iterate over its columns and then potentially generate a
	    // new column group
	    if (originalChild.type === _FixedDataTableColumnGroup2.default) {
	      var haveColumnsChanged = false;
	      var newColumns = [];
	
	      forEachColumn(originalChild.props.children, function (originalcolumn) {
	        var newColumn = callback(originalcolumn);
	        if (newColumn !== originalcolumn) {
	          haveColumnsChanged = true;
	        }
	        newColumns.push(newColumn);
	      });
	
	      // If the column groups columns have changed clone the group and supply
	      // new children
	      if (haveColumnsChanged) {
	        newChild = _React2.default.cloneElement(originalChild, {
	          children: newColumns
	        });
	      }
	    } else if (originalChild.type === _FixedDataTableColumn2.default) {
	      newChild = callback(originalChild);
	    }
	
	    newChildren.push(newChild);
	  });
	
	  return newChildren;
	}
	
	var FixedDataTableHelper = {
	  DIR_SIGN: DIR_SIGN,
	  CELL_VISIBILITY_TOLERANCE: CELL_VISIBILITY_TOLERANCE,
	  renderToString: renderToString,
	  forEachColumn: forEachColumn,
	  mapColumns: mapColumns
	};
	
	module.exports = FixedDataTableHelper;

/***/ }),
/* 118 */
/*!************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableRow.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableRow
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _FixedDataTableCellGroup = __webpack_require__(/*! ./FixedDataTableCellGroup */ 198);
	
	var _FixedDataTableCellGroup2 = _interopRequireDefault(_FixedDataTableCellGroup);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	var _joinClasses = __webpack_require__(/*! ./joinClasses */ 35);
	
	var _joinClasses2 = _interopRequireDefault(_joinClasses);
	
	var _FixedDataTableTranslateDOMPosition = __webpack_require__(/*! ./FixedDataTableTranslateDOMPosition */ 45);
	
	var _FixedDataTableTranslateDOMPosition2 = _interopRequireDefault(_FixedDataTableTranslateDOMPosition);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
	  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	// .fixedDataTableLayout/header border-bottom-width
	var HEADER_BORDER_BOTTOM_WIDTH = 1;
	
	/**
	 * Component that renders the row for <FixedDataTable />.
	 * This component should not be used directly by developer. Instead,
	 * only <FixedDataTable /> should use the component internally.
	 */
	
	var FixedDataTableRowImpl = function (_React$Component) {
	  _inherits(FixedDataTableRowImpl, _React$Component);
	
	  function FixedDataTableRowImpl() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, FixedDataTableRowImpl);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = FixedDataTableRowImpl.__proto__ || Object.getPrototypeOf(FixedDataTableRowImpl)).call.apply(_ref, [this].concat(args))), _this), _this.mouseLeaveIndex = null, _this._getColumnsWidth = function ( /*array*/columns) /*number*/{
	      var width = 0;
	      for (var i = 0; i < columns.length; ++i) {
	        width += columns[i].props.width;
	      }
	      return width;
	    }, _this._getRowExpanded = function ( /*number*/subRowHeight) /*?object*/{
	      if (_this.props.rowExpanded) {
	        var rowExpandedProps = {
	          rowIndex: _this.props.index,
	          height: subRowHeight,
	          width: _this.props.width
	        };
	
	        var rowExpanded;
	        if (_React2.default.isValidElement(_this.props.rowExpanded)) {
	          rowExpanded = _React2.default.cloneElement(_this.props.rowExpanded, rowExpandedProps);
	        } else if (typeof _this.props.rowExpanded === 'function') {
	          rowExpanded = _this.props.rowExpanded(rowExpandedProps);
	        }
	
	        return rowExpanded;
	      }
	    }, _this._renderColumnsLeftShadow = function ( /*number*/left) /*?object*/{
	      var className = (0, _cx2.default)({
	        'fixedDataTableRowLayout/fixedColumnsDivider': left > 0,
	        'fixedDataTableRowLayout/columnsShadow': _this.props.scrollLeft > 0,
	        'public/fixedDataTableRow/fixedColumnsDivider': left > 0,
	        'public/fixedDataTableRow/columnsShadow': _this.props.scrollLeft > 0
	      });
	      var dividerHeight = _this.props.cellGroupWrapperHeight ? _this.props.cellGroupWrapperHeight - HEADER_BORDER_BOTTOM_WIDTH : _this.props.height;
	      var style = {
	        left: left,
	        height: dividerHeight
	      };
	      return _React2.default.createElement('div', { className: className, style: style });
	    }, _this._renderFixedRightColumnsShadow = function ( /*number*/left) /*?object*/{
	      var className = (0, _cx2.default)('fixedDataTableRowLayout/columnsShadow', 'fixedDataTableRowLayout/columnsRightShadow', 'fixedDataTableRowLayout/fixedColumnsDivider', 'public/fixedDataTableRow/columnsShadow', 'public/fixedDataTableRow/columnsRightShadow', 'public/fixedDataTableRow/fixedColumnsDivider');
	      var style = {
	        height: _this.props.height,
	        left: left
	      };
	      return _React2.default.createElement('div', { className: className, style: style });
	    }, _this._renderColumnsRightShadow = function ( /*number*/totalWidth) /*?object*/{
	      if (Math.ceil(_this.props.scrollLeft + _this.props.width) < Math.floor(totalWidth)) {
	        var className = (0, _cx2.default)('fixedDataTableRowLayout/columnsShadow', 'fixedDataTableRowLayout/columnsRightShadow', 'public/fixedDataTableRow/columnsShadow', 'public/fixedDataTableRow/columnsRightShadow');
	        var style = {
	          height: _this.props.height
	        };
	        return _React2.default.createElement('div', { className: className, style: style });
	      }
	    }, _this._onClick = function ( /*object*/event) {
	      _this.props.onClick(event, _this.props.index);
	    }, _this._onDoubleClick = function ( /*object*/event) {
	      _this.props.onDoubleClick(event, _this.props.index);
	    }, _this._onMouseUp = function ( /*object*/event) {
	      _this.props.onMouseUp(event, _this.props.index);
	    }, _this._onMouseDown = function ( /*object*/event) {
	      _this.props.onMouseDown(event, _this.props.index);
	    }, _this._onMouseEnter = function ( /*object*/event) {
	      /**
	       * This is necessary so that onMouseLeave is fired with the initial
	       * row index since this row could be updated with a different index
	       * when scrolling.
	       */
	      _this.mouseLeaveIndex = _this.props.index;
	      if (_this.props.onMouseEnter) {
	        _this.props.onMouseEnter(event, _this.props.index);
	      }
	    }, _this._onMouseLeave = function ( /*object*/event) {
	      if (_this.mouseLeaveIndex === null) {
	        _this.mouseLeaveIndex = _this.props.index;
	      }
	      _this.props.onMouseLeave(event, _this.mouseLeaveIndex);
	      _this.mouseLeaveIndex = null;
	    }, _this._onTouchStart = function ( /*object*/event) {
	      _this.props.onTouchStart(event, _this.props.index);
	    }, _this._onTouchEnd = function ( /*object*/event) {
	      _this.props.onTouchEnd(event, _this.props.index);
	    }, _this._onTouchMove = function ( /*object*/event) {
	      _this.props.onTouchMove(event, _this.props.index);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  /**
	   * The index of a row for which to fire the onMouseLeave event.
	   */
	
	  _createClass(FixedDataTableRowImpl, [{
	    key: 'render',
	    value: function render() /*object*/{
	      var subRowHeight = this.props.subRowHeight || 0;
	      var style = {
	        width: this.props.width,
	        height: this.props.height + subRowHeight
	      };
	      var className = (0, _cx2.default)({
	        'fixedDataTableRowLayout/main': true,
	        'public/fixedDataTableRow/main': true,
	        'public/fixedDataTableRow/highlighted': this.props.index % 2 === 1,
	        'public/fixedDataTableRow/odd': this.props.index % 2 === 1,
	        'public/fixedDataTableRow/even': this.props.index % 2 === 0
	      });
	      var fixedColumnsWidth = this._getColumnsWidth(this.props.fixedColumns);
	      var fixedColumns = _React2.default.createElement(_FixedDataTableCellGroup2.default, {
	        key: 'fixed_cells',
	        isScrolling: this.props.isScrolling,
	        height: this.props.height,
	        cellGroupWrapperHeight: this.props.cellGroupWrapperHeight,
	        left: 0,
	        width: fixedColumnsWidth,
	        zIndex: 2,
	        columns: this.props.fixedColumns,
	        touchEnabled: this.props.touchEnabled,
	        onColumnResize: this.props.onColumnResize,
	        onColumnReorder: this.props.onColumnReorder,
	        onColumnReorderMove: this.props.onColumnReorderMove,
	        onColumnReorderEnd: this.props.onColumnReorderEnd,
	        isColumnReordering: this.props.isColumnReordering,
	        columnReorderingData: this.props.columnReorderingData,
	        rowHeight: this.props.height,
	        rowIndex: this.props.index
	      });
	      var columnsLeftShadow = this._renderColumnsLeftShadow(fixedColumnsWidth);
	      var fixedRightColumnsWidth = this._getColumnsWidth(this.props.fixedRightColumns);
	      var fixedRightColumns = _React2.default.createElement(_FixedDataTableCellGroup2.default, {
	        key: 'fixed_right_cells',
	        isScrolling: this.props.isScrolling,
	        height: this.props.height,
	        cellGroupWrapperHeight: this.props.cellGroupWrapperHeight,
	        offsetLeft: this.props.width - fixedRightColumnsWidth,
	        width: fixedRightColumnsWidth,
	        zIndex: 2,
	        columns: this.props.fixedRightColumns,
	        touchEnabled: this.props.touchEnabled,
	        onColumnResize: this.props.onColumnResize,
	        onColumnReorder: this.props.onColumnReorder,
	        onColumnReorderMove: this.props.onColumnReorderMove,
	        onColumnReorderEnd: this.props.onColumnReorderEnd,
	        isColumnReordering: this.props.isColumnReordering,
	        columnReorderingData: this.props.columnReorderingData,
	        rowHeight: this.props.height,
	        rowIndex: this.props.index
	      });
	      var fixedRightColumnsShdadow = fixedRightColumnsWidth ? this._renderFixedRightColumnsShadow(this.props.width - fixedRightColumnsWidth - 5) : null;
	      var scrollableColumns = _React2.default.createElement(_FixedDataTableCellGroup2.default, {
	        key: 'scrollable_cells',
	        isScrolling: this.props.isScrolling,
	        height: this.props.height,
	        cellGroupWrapperHeight: this.props.cellGroupWrapperHeight,
	        align: 'right',
	        left: this.props.scrollLeft,
	        offsetLeft: fixedColumnsWidth,
	        width: this.props.width - fixedColumnsWidth - fixedRightColumnsWidth,
	        zIndex: 0,
	        columns: this.props.scrollableColumns,
	        touchEnabled: this.props.touchEnabled,
	        onColumnResize: this.props.onColumnResize,
	        onColumnReorder: this.props.onColumnReorder,
	        onColumnReorderMove: this.props.onColumnReorderMove,
	        onColumnReorderEnd: this.props.onColumnReorderEnd,
	        isColumnReordering: this.props.isColumnReordering,
	        columnReorderingData: this.props.columnReorderingData,
	        rowHeight: this.props.height,
	        rowIndex: this.props.index
	      });
	      var scrollableColumnsWidth = this._getColumnsWidth(this.props.scrollableColumns);
	      var columnsRightShadow = this._renderColumnsRightShadow(fixedColumnsWidth + scrollableColumnsWidth);
	      var rowExpanded = this._getRowExpanded(subRowHeight);
	      var rowExpandedStyle = {
	        height: subRowHeight,
	        top: this.props.height,
	        width: this.props.width
	      };
	
	      return _React2.default.createElement('div', {
	        className: (0, _joinClasses2.default)(className, this.props.className),
	        onClick: this.props.onClick ? this._onClick : null,
	        onDoubleClick: this.props.onDoubleClick ? this._onDoubleClick : null,
	        onMouseDown: this.props.onMouseDown ? this._onMouseDown : null,
	        onMouseUp: this.props.onMouseUp ? this._onMouseUp : null,
	        onMouseEnter: this.props.onMouseEnter || this.props.onMouseLeave ? this._onMouseEnter : null,
	        onMouseLeave: this.props.onMouseLeave ? this._onMouseLeave : null,
	        onTouchStart: this.props.onTouchStart ? this._onTouchStart : null,
	        onTouchEnd: this.props.onTouchEnd ? this._onTouchEnd : null,
	        onTouchMove: this.props.onTouchMove ? this._onTouchMove : null,
	        style: style }, _React2.default.createElement('div', { className: (0, _cx2.default)('fixedDataTableRowLayout/body') }, fixedColumns, scrollableColumns, columnsLeftShadow, fixedRightColumns, fixedRightColumnsShdadow), rowExpanded && _React2.default.createElement('div', {
	        className: (0, _cx2.default)('fixedDataTableRowLayout/rowExpanded'),
	        style: rowExpandedStyle }, rowExpanded), columnsRightShadow);
	    }
	  }]);
	
	  return FixedDataTableRowImpl;
	}(_React2.default.Component);
	
	FixedDataTableRowImpl.propTypes = {
	
	  isScrolling: _propTypes2.default.bool,
	
	  /**
	   * Array of <FixedDataTableColumn /> for the fixed columns.
	   */
	  fixedColumns: _propTypes2.default.array.isRequired,
	
	  /**
	   * Array of <FixedDataTableColumn /> for the fixed columns positioned at end of the table.
	   */
	  fixedRightColumns: _propTypes2.default.array.isRequired,
	
	  /**
	   * Height of the row.
	   */
	  height: _propTypes2.default.number.isRequired,
	
	  /**
	   * Height of fixedDataTableCellGroupLayout/cellGroupWrapper.
	   */
	  cellGroupWrapperHeight: _propTypes2.default.number,
	
	  /**
	   * Height of the content to be displayed below the row.
	   */
	  subRowHeight: _propTypes2.default.number,
	
	  /**
	   * the row expanded.
	   */
	  rowExpanded: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.func]),
	
	  /**
	   * The row index.
	   */
	  index: _propTypes2.default.number.isRequired,
	
	  /**
	   * Array of <FixedDataTableColumn /> for the scrollable columns.
	   */
	  scrollableColumns: _propTypes2.default.array.isRequired,
	
	  /**
	   * The distance between the left edge of the table and the leftmost portion
	   * of the row currently visible in the table.
	   */
	  scrollLeft: _propTypes2.default.number.isRequired,
	
	  /**
	   * Width of the row.
	   */
	  width: _propTypes2.default.number.isRequired,
	
	  /**
	   * Fire when a row is clicked.
	   */
	  onClick: _propTypes2.default.func,
	
	  /**
	   * Fire when a row is double clicked.
	   */
	  onDoubleClick: _propTypes2.default.func,
	
	  /**
	   * Callback for when resizer knob (in FixedDataTableCell) is clicked
	   * to initialize resizing. Please note this is only on the cells
	   * in the header.
	   * @param number combinedWidth
	   * @param number leftOffset
	   * @param number cellWidth
	   * @param number|string columnKey
	   * @param object event
	   */
	  onColumnResize: _propTypes2.default.func,
	
	  isColumnReordering: _propTypes2.default.bool,
	  /**
	   * Callback for when reorder handle (in FixedDataTableCell) is clicked
	   * to initialize reordering. Please note this is only on the cells
	   * in the header.
	   * @param number|string columnKey
	   * @param number cellWidth
	   * @param number leftOffset
	   * @param object event
	   */
	  onColumnReorder: _propTypes2.default.func,
	
	  /**
	   * Callback for when a cell is moved while reordering.
	   * @param number distance
	   */
	  onColumnReorderMove: _propTypes2.default.func,
	
	  /**
	   * Callback for when the mouse is released to complete reordering.
	   * @param number distance
	   */
	  onColumnReorderEnd: _propTypes2.default.func,
	
	  touchEnabled: _propTypes2.default.bool
	};
	
	var FixedDataTableRow = function (_React$Component2) {
	  _inherits(FixedDataTableRow, _React$Component2);
	
	  function FixedDataTableRow() {
	    _classCallCheck(this, FixedDataTableRow);
	
	    return _possibleConstructorReturn(this, (FixedDataTableRow.__proto__ || Object.getPrototypeOf(FixedDataTableRow)).apply(this, arguments));
	  }
	
	  _createClass(FixedDataTableRow, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      this._initialRender = true;
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this._initialRender = false;
	    }
	  }, {
	    key: 'render',
	    value: function render() /*object*/{
	      var style = {
	        width: this.props.width,
	        height: this.props.height,
	        zIndex: this.props.zIndex ? this.props.zIndex : 0
	      };
	      (0, _FixedDataTableTranslateDOMPosition2.default)(style, 0, this.props.offsetTop, this._initialRender);
	
	      return _React2.default.createElement('div', {
	        style: style,
	        className: (0, _cx2.default)('fixedDataTableRowLayout/rowWrapper') }, _React2.default.createElement(FixedDataTableRowImpl, _extends({}, this.props, {
	        offsetTop: undefined,
	        zIndex: undefined
	      })));
	    }
	  }]);
	
	  return FixedDataTableRow;
	}(_React2.default.Component);
	
	FixedDataTableRow.propTypes = {
	
	  isScrolling: _propTypes2.default.bool,
	
	  /**
	   * Height of the row.
	   */
	  height: _propTypes2.default.number.isRequired,
	
	  /**
	   * Z-index on which the row will be displayed. Used e.g. for keeping
	   * header and footer in front of other rows.
	   */
	  zIndex: _propTypes2.default.number,
	
	  /**
	   * The vertical position where the row should render itself
	   */
	  offsetTop: _propTypes2.default.number.isRequired,
	
	  /**
	   * Width of the row.
	   */
	  width: _propTypes2.default.number.isRequired
	};
	
	module.exports = FixedDataTableRow;

/***/ }),
/* 119 */
/*!************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/ReactWheelHandler.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * This is utility that handles onWheel events and calls provided wheel
	 * callback with correct frame rate.
	 *
	 * @providesModule ReactWheelHandler
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _emptyFunction = __webpack_require__(/*! ./emptyFunction */ 22);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	var _normalizeWheel = __webpack_require__(/*! ./normalizeWheel */ 219);
	
	var _normalizeWheel2 = _interopRequireDefault(_normalizeWheel);
	
	var _requestAnimationFramePolyfill = __webpack_require__(/*! ./requestAnimationFramePolyfill */ 70);
	
	var _requestAnimationFramePolyfill2 = _interopRequireDefault(_requestAnimationFramePolyfill);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var ReactWheelHandler = function () {
	  /**
	   * onWheel is the callback that will be called with right frame rate if
	   * any wheel events happened
	   * onWheel should is to be called with two arguments: deltaX and deltaY in
	   * this order
	   */
	  function ReactWheelHandler(
	  /*function*/onWheel,
	  /*boolean|function*/handleScrollX,
	  /*boolean|function*/handleScrollY,
	  /*?boolean|?function*/stopPropagation) {
	    _classCallCheck(this, ReactWheelHandler);
	
	    this._animationFrameID = null;
	    this._deltaX = 0;
	    this._deltaY = 0;
	    this._didWheel = this._didWheel.bind(this);
	    if (typeof handleScrollX !== 'function') {
	      handleScrollX = handleScrollX ? _emptyFunction2.default.thatReturnsTrue : _emptyFunction2.default.thatReturnsFalse;
	    }
	
	    if (typeof handleScrollY !== 'function') {
	      handleScrollY = handleScrollY ? _emptyFunction2.default.thatReturnsTrue : _emptyFunction2.default.thatReturnsFalse;
	    }
	
	    if (typeof stopPropagation !== 'function') {
	      stopPropagation = stopPropagation ? _emptyFunction2.default.thatReturnsTrue : _emptyFunction2.default.thatReturnsFalse;
	    }
	
	    this._handleScrollX = handleScrollX;
	    this._handleScrollY = handleScrollY;
	    this._stopPropagation = stopPropagation;
	    this._onWheelCallback = onWheel;
	    this.onWheel = this.onWheel.bind(this);
	  }
	
	  _createClass(ReactWheelHandler, [{
	    key: 'onWheel',
	    value: function onWheel( /*object*/event) {
	      var normalizedEvent = (0, _normalizeWheel2.default)(event);
	      var deltaX = this._deltaX + normalizedEvent.pixelX;
	      var deltaY = this._deltaY + normalizedEvent.pixelY;
	      var handleScrollX = this._handleScrollX(deltaX, deltaY);
	      var handleScrollY = this._handleScrollY(deltaY, deltaX);
	      if (!handleScrollX && !handleScrollY) {
	        return;
	      }
	
	      this._deltaX += handleScrollX ? normalizedEvent.pixelX : 0;
	      this._deltaY += handleScrollY ? normalizedEvent.pixelY : 0;
	      event.preventDefault();
	
	      var changed;
	      if (this._deltaX !== 0 || this._deltaY !== 0) {
	        if (this._stopPropagation()) {
	          event.stopPropagation();
	        }
	        changed = true;
	      }
	
	      if (changed === true && this._animationFrameID === null) {
	        this._animationFrameID = (0, _requestAnimationFramePolyfill2.default)(this._didWheel);
	      }
	    }
	  }, {
	    key: '_didWheel',
	    value: function _didWheel() {
	      this._animationFrameID = null;
	      this._onWheelCallback(this._deltaX, this._deltaY);
	      this._deltaX = 0;
	      this._deltaY = 0;
	    }
	  }]);
	
	  return ReactWheelHandler;
	}();
	
	module.exports = ReactWheelHandler;

/***/ }),
/* 120 */
/*!****************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/getVendorPrefixedName.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 113);
	
	var _ExecutionEnvironment2 = _interopRequireDefault(_ExecutionEnvironment);
	
	var _camelize = __webpack_require__(/*! ./camelize */ 213);
	
	var _camelize2 = _interopRequireDefault(_camelize);
	
	var _invariant = __webpack_require__(/*! ./invariant */ 34);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var memoized = {}; /**
	                    * Copyright Schrodinger, LLC
	                    * All rights reserved.
	                    *
	                    * This source code is licensed under the BSD-style license found in the
	                    * LICENSE file in the root directory of this source tree. An additional grant
	                    * of patent rights can be found in the PATENTS file in the same directory.
	                    *
	                    * @providesModule getVendorPrefixedName
	                    * @typechecks
	                    */
	
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	var prefixRegex = new RegExp('^(' + prefixes.join('|') + ')');
	var testStyle = _ExecutionEnvironment2.default.canUseDOM ? document.createElement('div').style : {};
	
	function getWithPrefix(name) {
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefixedName = prefixes[i] + name;
	    if (prefixedName in testStyle) {
	      return prefixedName;
	    }
	  }
	  return null;
	}
	
	/**
	 * @param {string} property Name of a css property to check for.
	 * @return {?string} property name supported in the browser, or null if not
	 * supported.
	 */
	function getVendorPrefixedName(property) {
	  var name = (0, _camelize2.default)(property);
	  if (memoized[name] === undefined) {
	    var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
	    if (prefixRegex.test(capitalizedName)) {
	      (0, _invariant2.default)(false, 'getVendorPrefixedName must only be called with unprefixed' + 'CSS property names. It was called with %s', property);
	    }
	    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
	  }
	  return memoized[name];
	}
	
	module.exports = getVendorPrefixedName;

/***/ }),
/* 121 */
/*!*******************************************************!*\
  !*** ./~/fixed-data-table-2/internal/shallowEqual.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ }),
/* 122 */
/*!***************************************!*\
  !*** ./~/immutable/dist/immutable.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	(function (global, factory) {
	  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Immutable = factory();
	})(undefined, function () {
	  'use strict';
	  var SLICE$0 = Array.prototype.slice;
	
	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }
	
	  function Iterable(value) {
	    return isIterable(value) ? value : Seq(value);
	  }
	
	  createClass(KeyedIterable, Iterable);
	  function KeyedIterable(value) {
	    return isKeyed(value) ? value : KeyedSeq(value);
	  }
	
	  createClass(IndexedIterable, Iterable);
	  function IndexedIterable(value) {
	    return isIndexed(value) ? value : IndexedSeq(value);
	  }
	
	  createClass(SetIterable, Iterable);
	  function SetIterable(value) {
	    return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	  }
	
	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }
	
	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }
	
	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }
	
	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }
	
	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }
	
	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;
	
	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;
	
	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';
	
	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;
	
	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};
	
	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };
	
	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }
	
	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }
	
	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}
	
	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }
	
	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }
	
	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^321.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }
	
	  function returnTrue() {
	    return true;
	  }
	
	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
	  }
	
	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }
	
	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }
	
	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);
	  }
	
	  /* global Symbol */
	
	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;
	
	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';
	
	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
	
	  function Iterator(next) {
	    this.next = next;
	  }
	
	  Iterator.prototype.toString = function () {
	    return '[Iterator]';
	  };
	
	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;
	
	  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
	    return this.toString();
	  };
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };
	
	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? iteratorResult.value = value : iteratorResult = {
	      value: value, done: false
	    };
	    return iteratorResult;
	  }
	
	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }
	
	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }
	
	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }
	
	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }
	
	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }
	
	  createClass(Seq, Iterable);
	  function Seq(value) {
	    return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
	  }
	
	  Seq.of = function () /*...values*/{
	    return Seq(arguments);
	  };
	
	  Seq.prototype.toSeq = function () {
	    return this;
	  };
	
	  Seq.prototype.toString = function () {
	    return this.__toString('Seq {', '}');
	  };
	
	  Seq.prototype.cacheResult = function () {
	    if (!this._cache && this.__iterateUncached) {
	      this._cache = this.entrySeq().toArray();
	      this.size = this._cache.length;
	    }
	    return this;
	  };
	
	  // abstract __iterateUncached(fn, reverse)
	
	  Seq.prototype.__iterate = function (fn, reverse) {
	    return seqIterate(this, fn, reverse, true);
	  };
	
	  // abstract __iteratorUncached(type, reverse)
	
	  Seq.prototype.__iterator = function (type, reverse) {
	    return seqIterator(this, type, reverse, true);
	  };
	
	  createClass(KeyedSeq, Seq);
	  function KeyedSeq(value) {
	    return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
	  }
	
	  KeyedSeq.prototype.toKeyedSeq = function () {
	    return this;
	  };
	
	  createClass(IndexedSeq, Seq);
	  function IndexedSeq(value) {
	    return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	  }
	
	  IndexedSeq.of = function () /*...values*/{
	    return IndexedSeq(arguments);
	  };
	
	  IndexedSeq.prototype.toIndexedSeq = function () {
	    return this;
	  };
	
	  IndexedSeq.prototype.toString = function () {
	    return this.__toString('Seq [', ']');
	  };
	
	  IndexedSeq.prototype.__iterate = function (fn, reverse) {
	    return seqIterate(this, fn, reverse, false);
	  };
	
	  IndexedSeq.prototype.__iterator = function (type, reverse) {
	    return seqIterator(this, type, reverse, false);
	  };
	
	  createClass(SetSeq, Seq);
	  function SetSeq(value) {
	    return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
	  }
	
	  SetSeq.of = function () /*...values*/{
	    return SetSeq(arguments);
	  };
	
	  SetSeq.prototype.toSetSeq = function () {
	    return this;
	  };
	
	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;
	
	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
	
	  Seq.prototype[IS_SEQ_SENTINEL] = true;
	
	  createClass(ArraySeq, IndexedSeq);
	  function ArraySeq(array) {
	    this._array = array;
	    this.size = array.length;
	  }
	
	  ArraySeq.prototype.get = function (index, notSetValue) {
	    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	  };
	
	  ArraySeq.prototype.__iterate = function (fn, reverse) {
	    var array = this._array;
	    var maxIndex = array.length - 1;
	    for (var ii = 0; ii <= maxIndex; ii++) {
	      if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	        return ii + 1;
	      }
	    }
	    return ii;
	  };
	
	  ArraySeq.prototype.__iterator = function (type, reverse) {
	    var array = this._array;
	    var maxIndex = array.length - 1;
	    var ii = 0;
	    return new Iterator(function () {
	      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
	    });
	  };
	
	  createClass(ObjectSeq, KeyedSeq);
	  function ObjectSeq(object) {
	    var keys = Object.keys(object);
	    this._object = object;
	    this._keys = keys;
	    this.size = keys.length;
	  }
	
	  ObjectSeq.prototype.get = function (key, notSetValue) {
	    if (notSetValue !== undefined && !this.has(key)) {
	      return notSetValue;
	    }
	    return this._object[key];
	  };
	
	  ObjectSeq.prototype.has = function (key) {
	    return this._object.hasOwnProperty(key);
	  };
	
	  ObjectSeq.prototype.__iterate = function (fn, reverse) {
	    var object = this._object;
	    var keys = this._keys;
	    var maxIndex = keys.length - 1;
	    for (var ii = 0; ii <= maxIndex; ii++) {
	      var key = keys[reverse ? maxIndex - ii : ii];
	      if (fn(object[key], key, this) === false) {
	        return ii + 1;
	      }
	    }
	    return ii;
	  };
	
	  ObjectSeq.prototype.__iterator = function (type, reverse) {
	    var object = this._object;
	    var keys = this._keys;
	    var maxIndex = keys.length - 1;
	    var ii = 0;
	    return new Iterator(function () {
	      var key = keys[reverse ? maxIndex - ii : ii];
	      return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
	    });
	  };
	
	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
	
	  createClass(IterableSeq, IndexedSeq);
	  function IterableSeq(iterable) {
	    this._iterable = iterable;
	    this.size = iterable.length || iterable.size;
	  }
	
	  IterableSeq.prototype.__iterateUncached = function (fn, reverse) {
	    if (reverse) {
	      return this.cacheResult().__iterate(fn, reverse);
	    }
	    var iterable = this._iterable;
	    var iterator = getIterator(iterable);
	    var iterations = 0;
	    if (isIterator(iterator)) {
	      var step;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	    }
	    return iterations;
	  };
	
	  IterableSeq.prototype.__iteratorUncached = function (type, reverse) {
	    if (reverse) {
	      return this.cacheResult().__iterator(type, reverse);
	    }
	    var iterable = this._iterable;
	    var iterator = getIterator(iterable);
	    if (!isIterator(iterator)) {
	      return new Iterator(iteratorDone);
	    }
	    var iterations = 0;
	    return new Iterator(function () {
	      var step = iterator.next();
	      return step.done ? step : iteratorValue(type, iterations++, step.value);
	    });
	  };
	
	  createClass(IteratorSeq, IndexedSeq);
	  function IteratorSeq(iterator) {
	    this._iterator = iterator;
	    this._iteratorCache = [];
	  }
	
	  IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {
	    if (reverse) {
	      return this.cacheResult().__iterate(fn, reverse);
	    }
	    var iterator = this._iterator;
	    var cache = this._iteratorCache;
	    var iterations = 0;
	    while (iterations < cache.length) {
	      if (fn(cache[iterations], iterations++, this) === false) {
	        return iterations;
	      }
	    }
	    var step;
	    while (!(step = iterator.next()).done) {
	      var val = step.value;
	      cache[iterations] = val;
	      if (fn(val, iterations++, this) === false) {
	        break;
	      }
	    }
	    return iterations;
	  };
	
	  IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {
	    if (reverse) {
	      return this.cacheResult().__iterator(type, reverse);
	    }
	    var iterator = this._iterator;
	    var cache = this._iteratorCache;
	    var iterations = 0;
	    return new Iterator(function () {
	      if (iterations >= cache.length) {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        cache[iterations] = step.value;
	      }
	      return iteratorValue(type, iterations, cache[iterations++]);
	    });
	  };
	
	  // # pragma Helper functions
	
	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }
	
	  var EMPTY_SEQ;
	
	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }
	
	  function keyedSeqFromValue(value) {
	    var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? new ObjectSeq(value) : undefined;
	    if (!seq) {
	      throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);
	    }
	    return seq;
	  }
	
	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError('Expected Array or iterable object of values: ' + value);
	    }
	    return seq;
	  }
	
	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && new ObjectSeq(value);
	    if (!seq) {
	      throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);
	    }
	    return seq;
	  }
	
	  function maybeIndexedSeqFromValue(value) {
	    return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;
	  }
	
	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }
	
	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function () {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }
	
	  function fromJS(json, converter) {
	    return converter ? fromJSWith(converter, json, '', { '': json }) : fromJSDefault(json);
	  }
	
	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {
	        return fromJSWith(converter, v, k, json);
	      }));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {
	        return fromJSWith(converter, v, k, json);
	      }));
	    }
	    return json;
	  }
	
	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }
	
	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }
	
	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }
	
	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }
	
	    if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
	      return false;
	    }
	
	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }
	
	    var notAssociative = !isAssociative(a);
	
	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function (v, k) {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }
	
	    var flipped = false;
	
	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }
	
	    var allEqual = true;
	    var bSize = b.__iterate(function (v, k) {
	      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });
	
	    return allEqual && a.size === bSize;
	  }
	
	  createClass(Repeat, IndexedSeq);
	
	  function Repeat(value, times) {
	    if (!(this instanceof Repeat)) {
	      return new Repeat(value, times);
	    }
	    this._value = value;
	    this.size = times === undefined ? Infinity : Math.max(0, times);
	    if (this.size === 0) {
	      if (EMPTY_REPEAT) {
	        return EMPTY_REPEAT;
	      }
	      EMPTY_REPEAT = this;
	    }
	  }
	
	  Repeat.prototype.toString = function () {
	    if (this.size === 0) {
	      return 'Repeat []';
	    }
	    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	  };
	
	  Repeat.prototype.get = function (index, notSetValue) {
	    return this.has(index) ? this._value : notSetValue;
	  };
	
	  Repeat.prototype.includes = function (searchValue) {
	    return is(this._value, searchValue);
	  };
	
	  Repeat.prototype.slice = function (begin, end) {
	    var size = this.size;
	    return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	  };
	
	  Repeat.prototype.reverse = function () {
	    return this;
	  };
	
	  Repeat.prototype.indexOf = function (searchValue) {
	    if (is(this._value, searchValue)) {
	      return 0;
	    }
	    return -1;
	  };
	
	  Repeat.prototype.lastIndexOf = function (searchValue) {
	    if (is(this._value, searchValue)) {
	      return this.size;
	    }
	    return -1;
	  };
	
	  Repeat.prototype.__iterate = function (fn, reverse) {
	    for (var ii = 0; ii < this.size; ii++) {
	      if (fn(this._value, ii, this) === false) {
	        return ii + 1;
	      }
	    }
	    return ii;
	  };
	
	  Repeat.prototype.__iterator = function (type, reverse) {
	    var this$0 = this;
	    var ii = 0;
	    return new Iterator(function () {
	      return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
	    });
	  };
	
	  Repeat.prototype.equals = function (other) {
	    return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
	  };
	
	  var EMPTY_REPEAT;
	
	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }
	
	  createClass(Range, IndexedSeq);
	
	  function Range(start, end, step) {
	    if (!(this instanceof Range)) {
	      return new Range(start, end, step);
	    }
	    invariant(step !== 0, 'Cannot step a Range by 0');
	    start = start || 0;
	    if (end === undefined) {
	      end = Infinity;
	    }
	    step = step === undefined ? 1 : Math.abs(step);
	    if (end < start) {
	      step = -step;
	    }
	    this._start = start;
	    this._end = end;
	    this._step = step;
	    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	    if (this.size === 0) {
	      if (EMPTY_RANGE) {
	        return EMPTY_RANGE;
	      }
	      EMPTY_RANGE = this;
	    }
	  }
	
	  Range.prototype.toString = function () {
	    if (this.size === 0) {
	      return 'Range []';
	    }
	    return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
	  };
	
	  Range.prototype.get = function (index, notSetValue) {
	    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
	  };
	
	  Range.prototype.includes = function (searchValue) {
	    var possibleIndex = (searchValue - this._start) / this._step;
	    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
	  };
	
	  Range.prototype.slice = function (begin, end) {
	    if (wholeSlice(begin, end, this.size)) {
	      return this;
	    }
	    begin = resolveBegin(begin, this.size);
	    end = resolveEnd(end, this.size);
	    if (end <= begin) {
	      return new Range(0, 0);
	    }
	    return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	  };
	
	  Range.prototype.indexOf = function (searchValue) {
	    var offsetValue = searchValue - this._start;
	    if (offsetValue % this._step === 0) {
	      var index = offsetValue / this._step;
	      if (index >= 0 && index < this.size) {
	        return index;
	      }
	    }
	    return -1;
	  };
	
	  Range.prototype.lastIndexOf = function (searchValue) {
	    return this.indexOf(searchValue);
	  };
	
	  Range.prototype.__iterate = function (fn, reverse) {
	    var maxIndex = this.size - 1;
	    var step = this._step;
	    var value = reverse ? this._start + maxIndex * step : this._start;
	    for (var ii = 0; ii <= maxIndex; ii++) {
	      if (fn(value, ii, this) === false) {
	        return ii + 1;
	      }
	      value += reverse ? -step : step;
	    }
	    return ii;
	  };
	
	  Range.prototype.__iterator = function (type, reverse) {
	    var maxIndex = this.size - 1;
	    var step = this._step;
	    var value = reverse ? this._start + maxIndex * step : this._start;
	    var ii = 0;
	    return new Iterator(function () {
	      var v = value;
	      value += reverse ? -step : step;
	      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	    });
	  };
	
	  Range.prototype.equals = function (other) {
	    return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
	  };
	
	  var EMPTY_RANGE;
	
	  createClass(Collection, Iterable);
	  function Collection() {
	    throw TypeError('Abstract');
	  }
	
	  createClass(KeyedCollection, Collection);function KeyedCollection() {}
	
	  createClass(IndexedCollection, Collection);function IndexedCollection() {}
	
	  createClass(SetCollection, Collection);function SetCollection() {}
	
	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;
	
	  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
	    a = a | 0; // int
	    b = b | 0; // int
	    var c = a & 0xffff;
	    var d = b & 0xffff;
	    // Shift by 0 fixes the sign on the high part.
	    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
	  };
	
	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;
	  }
	
	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o === 'undefined' ? 'undefined' : _typeof(o);
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }
	
	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }
	
	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }
	
	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }
	
	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }
	
	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }
	
	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }
	
	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function () {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }
	
	    return hash;
	  }
	
	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;
	
	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = function () {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }();
	
	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1:
	          // Element
	          return node.uniqueID;
	        case 9:
	          // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }
	
	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }
	
	  var objHashUID = 0;
	
	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }
	
	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};
	
	  function assertNotInfinite(size) {
	    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
	  }
	
	  createClass(Map, KeyedCollection);
	
	  // @pragma Construction
	
	  function Map(value) {
	    return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
	      var iter = KeyedIterable(value);
	      assertNotInfinite(iter.size);
	      iter.forEach(function (v, k) {
	        return map.set(k, v);
	      });
	    });
	  }
	
	  Map.of = function () {
	    var keyValues = SLICE$0.call(arguments, 0);
	    return emptyMap().withMutations(function (map) {
	      for (var i = 0; i < keyValues.length; i += 2) {
	        if (i + 1 >= keyValues.length) {
	          throw new Error('Missing value for key: ' + keyValues[i]);
	        }
	        map.set(keyValues[i], keyValues[i + 1]);
	      }
	    });
	  };
	
	  Map.prototype.toString = function () {
	    return this.__toString('Map {', '}');
	  };
	
	  // @pragma Access
	
	  Map.prototype.get = function (k, notSetValue) {
	    return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
	  };
	
	  // @pragma Modification
	
	  Map.prototype.set = function (k, v) {
	    return updateMap(this, k, v);
	  };
	
	  Map.prototype.setIn = function (keyPath, v) {
	    return this.updateIn(keyPath, NOT_SET, function () {
	      return v;
	    });
	  };
	
	  Map.prototype.remove = function (k) {
	    return updateMap(this, k, NOT_SET);
	  };
	
	  Map.prototype.deleteIn = function (keyPath) {
	    return this.updateIn(keyPath, function () {
	      return NOT_SET;
	    });
	  };
	
	  Map.prototype.update = function (k, notSetValue, updater) {
	    return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
	  };
	
	  Map.prototype.updateIn = function (keyPath, notSetValue, updater) {
	    if (!updater) {
	      updater = notSetValue;
	      notSetValue = undefined;
	    }
	    var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
	    return updatedValue === NOT_SET ? undefined : updatedValue;
	  };
	
	  Map.prototype.clear = function () {
	    if (this.size === 0) {
	      return this;
	    }
	    if (this.__ownerID) {
	      this.size = 0;
	      this._root = null;
	      this.__hash = undefined;
	      this.__altered = true;
	      return this;
	    }
	    return emptyMap();
	  };
	
	  // @pragma Composition
	
	  Map.prototype.merge = function () /*...iters*/{
	    return mergeIntoMapWith(this, undefined, arguments);
	  };
	
	  Map.prototype.mergeWith = function (merger) {
	    var iters = SLICE$0.call(arguments, 1);
	    return mergeIntoMapWith(this, merger, iters);
	  };
	
	  Map.prototype.mergeIn = function (keyPath) {
	    var iters = SLICE$0.call(arguments, 1);
	    return this.updateIn(keyPath, emptyMap(), function (m) {
	      return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
	    });
	  };
	
	  Map.prototype.mergeDeep = function () /*...iters*/{
	    return mergeIntoMapWith(this, deepMerger, arguments);
	  };
	
	  Map.prototype.mergeDeepWith = function (merger) {
	    var iters = SLICE$0.call(arguments, 1);
	    return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	  };
	
	  Map.prototype.mergeDeepIn = function (keyPath) {
	    var iters = SLICE$0.call(arguments, 1);
	    return this.updateIn(keyPath, emptyMap(), function (m) {
	      return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
	    });
	  };
	
	  Map.prototype.sort = function (comparator) {
	    // Late binding
	    return OrderedMap(sortFactory(this, comparator));
	  };
	
	  Map.prototype.sortBy = function (mapper, comparator) {
	    // Late binding
	    return OrderedMap(sortFactory(this, comparator, mapper));
	  };
	
	  // @pragma Mutability
	
	  Map.prototype.withMutations = function (fn) {
	    var mutable = this.asMutable();
	    fn(mutable);
	    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	  };
	
	  Map.prototype.asMutable = function () {
	    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	  };
	
	  Map.prototype.asImmutable = function () {
	    return this.__ensureOwner();
	  };
	
	  Map.prototype.wasAltered = function () {
	    return this.__altered;
	  };
	
	  Map.prototype.__iterator = function (type, reverse) {
	    return new MapIterator(this, type, reverse);
	  };
	
	  Map.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    var iterations = 0;
	    this._root && this._root.iterate(function (entry) {
	      iterations++;
	      return fn(entry[1], entry[0], this$0);
	    }, reverse);
	    return iterations;
	  };
	
	  Map.prototype.__ensureOwner = function (ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      this.__altered = false;
	      return this;
	    }
	    return makeMap(this.size, this._root, ownerID, this.__hash);
	  };
	
	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }
	
	  Map.isMap = isMap;
	
	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
	
	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;
	
	  // #pragma Trie Nodes
	
	
	  function ArrayMapNode(ownerID, entries) {
	    this.ownerID = ownerID;
	    this.entries = entries;
	  }
	
	  ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
	    var entries = this.entries;
	    for (var ii = 0, len = entries.length; ii < len; ii++) {
	      if (is(key, entries[ii][0])) {
	        return entries[ii][1];
	      }
	    }
	    return notSetValue;
	  };
	
	  ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    var removed = value === NOT_SET;
	
	    var entries = this.entries;
	    var idx = 0;
	    for (var len = entries.length; idx < len; idx++) {
	      if (is(key, entries[idx][0])) {
	        break;
	      }
	    }
	    var exists = idx < len;
	
	    if (exists ? entries[idx][1] === value : removed) {
	      return this;
	    }
	
	    SetRef(didAlter);
	    (removed || !exists) && SetRef(didChangeSize);
	
	    if (removed && entries.length === 1) {
	      return; // undefined
	    }
	
	    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	      return createNodes(ownerID, entries, key, value);
	    }
	
	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newEntries = isEditable ? entries : arrCopy(entries);
	
	    if (exists) {
	      if (removed) {
	        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
	      } else {
	        newEntries[idx] = [key, value];
	      }
	    } else {
	      newEntries.push([key, value]);
	    }
	
	    if (isEditable) {
	      this.entries = newEntries;
	      return this;
	    }
	
	    return new ArrayMapNode(ownerID, newEntries);
	  };
	
	  function BitmapIndexedNode(ownerID, bitmap, nodes) {
	    this.ownerID = ownerID;
	    this.bitmap = bitmap;
	    this.nodes = nodes;
	  }
	
	  BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
	    var bitmap = this.bitmap;
	    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
	  };
	
	  BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var bit = 1 << keyHashFrag;
	    var bitmap = this.bitmap;
	    var exists = (bitmap & bit) !== 0;
	
	    if (!exists && value === NOT_SET) {
	      return this;
	    }
	
	    var idx = popCount(bitmap & bit - 1);
	    var nodes = this.nodes;
	    var node = exists ? nodes[idx] : undefined;
	    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	
	    if (newNode === node) {
	      return this;
	    }
	
	    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	    }
	
	    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	      return nodes[idx ^ 1];
	    }
	
	    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	      return newNode;
	    }
	
	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
	
	    if (isEditable) {
	      this.bitmap = newBitmap;
	      this.nodes = newNodes;
	      return this;
	    }
	
	    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	  };
	
	  function HashArrayMapNode(ownerID, count, nodes) {
	    this.ownerID = ownerID;
	    this.count = count;
	    this.nodes = nodes;
	  }
	
	  HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var node = this.nodes[idx];
	    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	  };
	
	  HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	    var removed = value === NOT_SET;
	    var nodes = this.nodes;
	    var node = nodes[idx];
	
	    if (removed && !node) {
	      return this;
	    }
	
	    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	    if (newNode === node) {
	      return this;
	    }
	
	    var newCount = this.count;
	    if (!node) {
	      newCount++;
	    } else if (!newNode) {
	      newCount--;
	      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	        return packNodes(ownerID, nodes, newCount, idx);
	      }
	    }
	
	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newNodes = setIn(nodes, idx, newNode, isEditable);
	
	    if (isEditable) {
	      this.count = newCount;
	      this.nodes = newNodes;
	      return this;
	    }
	
	    return new HashArrayMapNode(ownerID, newCount, newNodes);
	  };
	
	  function HashCollisionNode(ownerID, keyHash, entries) {
	    this.ownerID = ownerID;
	    this.keyHash = keyHash;
	    this.entries = entries;
	  }
	
	  HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {
	    var entries = this.entries;
	    for (var ii = 0, len = entries.length; ii < len; ii++) {
	      if (is(key, entries[ii][0])) {
	        return entries[ii][1];
	      }
	    }
	    return notSetValue;
	  };
	
	  HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (keyHash === undefined) {
	      keyHash = hash(key);
	    }
	
	    var removed = value === NOT_SET;
	
	    if (keyHash !== this.keyHash) {
	      if (removed) {
	        return this;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	    }
	
	    var entries = this.entries;
	    var idx = 0;
	    for (var len = entries.length; idx < len; idx++) {
	      if (is(key, entries[idx][0])) {
	        break;
	      }
	    }
	    var exists = idx < len;
	
	    if (exists ? entries[idx][1] === value : removed) {
	      return this;
	    }
	
	    SetRef(didAlter);
	    (removed || !exists) && SetRef(didChangeSize);
	
	    if (removed && len === 2) {
	      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	    }
	
	    var isEditable = ownerID && ownerID === this.ownerID;
	    var newEntries = isEditable ? entries : arrCopy(entries);
	
	    if (exists) {
	      if (removed) {
	        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
	      } else {
	        newEntries[idx] = [key, value];
	      }
	    } else {
	      newEntries.push([key, value]);
	    }
	
	    if (isEditable) {
	      this.entries = newEntries;
	      return this;
	    }
	
	    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	  };
	
	  function ValueNode(ownerID, keyHash, entry) {
	    this.ownerID = ownerID;
	    this.keyHash = keyHash;
	    this.entry = entry;
	  }
	
	  ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {
	    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	  };
	
	  ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    var removed = value === NOT_SET;
	    var keyMatch = is(key, this.entry[0]);
	    if (keyMatch ? value === this.entry[1] : removed) {
	      return this;
	    }
	
	    SetRef(didAlter);
	
	    if (removed) {
	      SetRef(didChangeSize);
	      return; // undefined
	    }
	
	    if (keyMatch) {
	      if (ownerID && ownerID === this.ownerID) {
	        this.entry[1] = value;
	        return this;
	      }
	      return new ValueNode(ownerID, this.keyHash, [key, value]);
	    }
	
	    SetRef(didChangeSize);
	    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	  };
	
	  // #pragma Iterators
	
	  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  };
	
	  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  };
	
	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  };
	
	  createClass(MapIterator, Iterator);
	
	  function MapIterator(map, type, reverse) {
	    this._type = type;
	    this._reverse = reverse;
	    this._stack = map._root && mapIteratorFrame(map._root);
	  }
	
	  MapIterator.prototype.next = function () {
	    var type = this._type;
	    var stack = this._stack;
	    while (stack) {
	      var node = stack.node;
	      var index = stack.index++;
	      var maxIndex;
	      if (node.entry) {
	        if (index === 0) {
	          return mapIteratorValue(type, node.entry);
	        }
	      } else if (node.entries) {
	        maxIndex = node.entries.length - 1;
	        if (index <= maxIndex) {
	          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	        }
	      } else {
	        maxIndex = node.nodes.length - 1;
	        if (index <= maxIndex) {
	          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	          if (subNode) {
	            if (subNode.entry) {
	              return mapIteratorValue(type, subNode.entry);
	            }
	            stack = this._stack = mapIteratorFrame(subNode, stack);
	          }
	          continue;
	        }
	      }
	      stack = this._stack = this._stack.__prev;
	    }
	    return iteratorDone();
	  };
	
	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }
	
	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }
	
	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }
	
	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }
	
	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }
	
	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }
	
	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }
	
	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	
	    var newNode;
	    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
	
	    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
	  }
	
	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }
	
	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }
	
	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }
	
	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function (v) {
	          return fromJS(v);
	        });
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }
	
	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;
	  }
	
	  function deepMergerWith(merger) {
	    return function (existing, value, key) {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }
	
	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function (x) {
	      return x.size !== 0;
	    });
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function (collection) {
	      var mergeIntoMap = merger ? function (value, key) {
	        collection.update(key, NOT_SET, function (existing) {
	          return existing === NOT_SET ? value : merger(existing, value, key);
	        });
	      } : function (value, key) {
	        collection.set(key, value);
	      };
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }
	
	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(isNotSet || existing && existing.set, 'invalid keyPath');
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
	    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }
	
	  function popCount(x) {
	    x = x - (x >> 1 & 0x55555555);
	    x = (x & 0x33333333) + (x >> 2 & 0x33333333);
	    x = x + (x >> 4) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }
	
	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }
	
	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }
	
	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }
	
	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
	
	  createClass(List, IndexedCollection);
	
	  // @pragma Construction
	
	  function List(value) {
	    var empty = emptyList();
	    if (value === null || value === undefined) {
	      return empty;
	    }
	    if (isList(value)) {
	      return value;
	    }
	    var iter = IndexedIterable(value);
	    var size = iter.size;
	    if (size === 0) {
	      return empty;
	    }
	    assertNotInfinite(size);
	    if (size > 0 && size < SIZE) {
	      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	    }
	    return empty.withMutations(function (list) {
	      list.setSize(size);
	      iter.forEach(function (v, i) {
	        return list.set(i, v);
	      });
	    });
	  }
	
	  List.of = function () /*...values*/{
	    return this(arguments);
	  };
	
	  List.prototype.toString = function () {
	    return this.__toString('List [', ']');
	  };
	
	  // @pragma Access
	
	  List.prototype.get = function (index, notSetValue) {
	    index = wrapIndex(this, index);
	    if (index >= 0 && index < this.size) {
	      index += this._origin;
	      var node = listNodeFor(this, index);
	      return node && node.array[index & MASK];
	    }
	    return notSetValue;
	  };
	
	  // @pragma Modification
	
	  List.prototype.set = function (index, value) {
	    return updateList(this, index, value);
	  };
	
	  List.prototype.remove = function (index) {
	    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
	  };
	
	  List.prototype.insert = function (index, value) {
	    return this.splice(index, 0, value);
	  };
	
	  List.prototype.clear = function () {
	    if (this.size === 0) {
	      return this;
	    }
	    if (this.__ownerID) {
	      this.size = this._origin = this._capacity = 0;
	      this._level = SHIFT;
	      this._root = this._tail = null;
	      this.__hash = undefined;
	      this.__altered = true;
	      return this;
	    }
	    return emptyList();
	  };
	
	  List.prototype.push = function () /*...values*/{
	    var values = arguments;
	    var oldSize = this.size;
	    return this.withMutations(function (list) {
	      setListBounds(list, 0, oldSize + values.length);
	      for (var ii = 0; ii < values.length; ii++) {
	        list.set(oldSize + ii, values[ii]);
	      }
	    });
	  };
	
	  List.prototype.pop = function () {
	    return setListBounds(this, 0, -1);
	  };
	
	  List.prototype.unshift = function () /*...values*/{
	    var values = arguments;
	    return this.withMutations(function (list) {
	      setListBounds(list, -values.length);
	      for (var ii = 0; ii < values.length; ii++) {
	        list.set(ii, values[ii]);
	      }
	    });
	  };
	
	  List.prototype.shift = function () {
	    return setListBounds(this, 1);
	  };
	
	  // @pragma Composition
	
	  List.prototype.merge = function () /*...iters*/{
	    return mergeIntoListWith(this, undefined, arguments);
	  };
	
	  List.prototype.mergeWith = function (merger) {
	    var iters = SLICE$0.call(arguments, 1);
	    return mergeIntoListWith(this, merger, iters);
	  };
	
	  List.prototype.mergeDeep = function () /*...iters*/{
	    return mergeIntoListWith(this, deepMerger, arguments);
	  };
	
	  List.prototype.mergeDeepWith = function (merger) {
	    var iters = SLICE$0.call(arguments, 1);
	    return mergeIntoListWith(this, deepMergerWith(merger), iters);
	  };
	
	  List.prototype.setSize = function (size) {
	    return setListBounds(this, 0, size);
	  };
	
	  // @pragma Iteration
	
	  List.prototype.slice = function (begin, end) {
	    var size = this.size;
	    if (wholeSlice(begin, end, size)) {
	      return this;
	    }
	    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
	  };
	
	  List.prototype.__iterator = function (type, reverse) {
	    var index = 0;
	    var values = iterateList(this, reverse);
	    return new Iterator(function () {
	      var value = values();
	      return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
	    });
	  };
	
	  List.prototype.__iterate = function (fn, reverse) {
	    var index = 0;
	    var values = iterateList(this, reverse);
	    var value;
	    while ((value = values()) !== DONE) {
	      if (fn(value, index++, this) === false) {
	        break;
	      }
	    }
	    return index;
	  };
	
	  List.prototype.__ensureOwner = function (ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      return this;
	    }
	    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	  };
	
	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }
	
	  List.isList = isList;
	
	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
	
	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;
	
	  function VNode(array, ownerID) {
	    this.array = array;
	    this.ownerID = ownerID;
	  }
	
	  // TODO: seems like these methods are very similar
	
	  VNode.prototype.removeBefore = function (ownerID, level, index) {
	    if (index === level ? 1 << level : 0 || this.array.length === 0) {
	      return this;
	    }
	    var originIndex = index >>> level & MASK;
	    if (originIndex >= this.array.length) {
	      return new VNode([], ownerID);
	    }
	    var removingFirst = originIndex === 0;
	    var newChild;
	    if (level > 0) {
	      var oldChild = this.array[originIndex];
	      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	      if (newChild === oldChild && removingFirst) {
	        return this;
	      }
	    }
	    if (removingFirst && !newChild) {
	      return this;
	    }
	    var editable = editableVNode(this, ownerID);
	    if (!removingFirst) {
	      for (var ii = 0; ii < originIndex; ii++) {
	        editable.array[ii] = undefined;
	      }
	    }
	    if (newChild) {
	      editable.array[originIndex] = newChild;
	    }
	    return editable;
	  };
	
	  VNode.prototype.removeAfter = function (ownerID, level, index) {
	    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	      return this;
	    }
	    var sizeIndex = index - 1 >>> level & MASK;
	    if (sizeIndex >= this.array.length) {
	      return this;
	    }
	
	    var newChild;
	    if (level > 0) {
	      var oldChild = this.array[sizeIndex];
	      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	      if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	        return this;
	      }
	    }
	
	    var editable = editableVNode(this, ownerID);
	    editable.array.splice(sizeIndex + 1);
	    if (newChild) {
	      editable.array[sizeIndex] = newChild;
	    }
	    return editable;
	  };
	
	  var DONE = {};
	
	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;
	
	    return iterateNodeOrLeaf(list._root, list._level, 0);
	
	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
	    }
	
	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function () {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }
	
	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : left - offset >> level;
	      var to = (right - offset >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function () {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
	        } while (true);
	      };
	    }
	  }
	
	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }
	
	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }
	
	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);
	
	    if (index !== index) {
	      return list;
	    }
	
	    if (index >= list.size || index < 0) {
	      return list.withMutations(function (list) {
	        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
	      });
	    }
	
	    index += list._origin;
	
	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }
	
	    if (!didAlter.value) {
	      return list;
	    }
	
	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }
	
	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = index >>> level & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }
	
	    var newNode;
	
	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }
	
	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }
	
	    SetRef(didAlter);
	
	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }
	
	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }
	
	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << list._level + SHIFT) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[rawIndex >>> level & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }
	
	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }
	
	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }
	
	    var newLevel = list._level;
	    var newRoot = list._root;
	
	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }
	
	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);
	
	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << newLevel + SHIFT) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }
	
	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
	
	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = oldTailOffset >>> level & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
	    }
	
	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }
	
	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
	
	      // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;
	
	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = newOrigin >>> newLevel & MASK;
	        if (beginIndex !== newTailOffset >>> newLevel & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }
	
	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }
	
	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }
	
	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function (v) {
	          return fromJS(v);
	        });
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }
	
	  function getTailOffset(size) {
	    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
	  }
	
	  createClass(OrderedMap, Map);
	
	  // @pragma Construction
	
	  function OrderedMap(value) {
	    return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
	      var iter = KeyedIterable(value);
	      assertNotInfinite(iter.size);
	      iter.forEach(function (v, k) {
	        return map.set(k, v);
	      });
	    });
	  }
	
	  OrderedMap.of = function () /*...values*/{
	    return this(arguments);
	  };
	
	  OrderedMap.prototype.toString = function () {
	    return this.__toString('OrderedMap {', '}');
	  };
	
	  // @pragma Access
	
	  OrderedMap.prototype.get = function (k, notSetValue) {
	    var index = this._map.get(k);
	    return index !== undefined ? this._list.get(index)[1] : notSetValue;
	  };
	
	  // @pragma Modification
	
	  OrderedMap.prototype.clear = function () {
	    if (this.size === 0) {
	      return this;
	    }
	    if (this.__ownerID) {
	      this.size = 0;
	      this._map.clear();
	      this._list.clear();
	      return this;
	    }
	    return emptyOrderedMap();
	  };
	
	  OrderedMap.prototype.set = function (k, v) {
	    return updateOrderedMap(this, k, v);
	  };
	
	  OrderedMap.prototype.remove = function (k) {
	    return updateOrderedMap(this, k, NOT_SET);
	  };
	
	  OrderedMap.prototype.wasAltered = function () {
	    return this._map.wasAltered() || this._list.wasAltered();
	  };
	
	  OrderedMap.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    return this._list.__iterate(function (entry) {
	      return entry && fn(entry[1], entry[0], this$0);
	    }, reverse);
	  };
	
	  OrderedMap.prototype.__iterator = function (type, reverse) {
	    return this._list.fromEntrySeq().__iterator(type, reverse);
	  };
	
	  OrderedMap.prototype.__ensureOwner = function (ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    var newMap = this._map.__ensureOwner(ownerID);
	    var newList = this._list.__ensureOwner(ownerID);
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      this._map = newMap;
	      this._list = newList;
	      return this;
	    }
	    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	  };
	
	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }
	
	  OrderedMap.isOrderedMap = isOrderedMap;
	
	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
	
	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }
	
	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }
	
	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) {
	      // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function (entry, idx) {
	          return entry !== undefined && i !== idx;
	        });
	        newMap = newList.toKeyedSeq().map(function (entry) {
	          return entry[0];
	        }).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }
	
	  createClass(ToKeyedSequence, KeyedSeq);
	  function ToKeyedSequence(indexed, useKeys) {
	    this._iter = indexed;
	    this._useKeys = useKeys;
	    this.size = indexed.size;
	  }
	
	  ToKeyedSequence.prototype.get = function (key, notSetValue) {
	    return this._iter.get(key, notSetValue);
	  };
	
	  ToKeyedSequence.prototype.has = function (key) {
	    return this._iter.has(key);
	  };
	
	  ToKeyedSequence.prototype.valueSeq = function () {
	    return this._iter.valueSeq();
	  };
	
	  ToKeyedSequence.prototype.reverse = function () {
	    var this$0 = this;
	    var reversedSequence = reverseFactory(this, true);
	    if (!this._useKeys) {
	      reversedSequence.valueSeq = function () {
	        return this$0._iter.toSeq().reverse();
	      };
	    }
	    return reversedSequence;
	  };
	
	  ToKeyedSequence.prototype.map = function (mapper, context) {
	    var this$0 = this;
	    var mappedSequence = mapFactory(this, mapper, context);
	    if (!this._useKeys) {
	      mappedSequence.valueSeq = function () {
	        return this$0._iter.toSeq().map(mapper, context);
	      };
	    }
	    return mappedSequence;
	  };
	
	  ToKeyedSequence.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    var ii;
	    return this._iter.__iterate(this._useKeys ? function (v, k) {
	      return fn(v, k, this$0);
	    } : (ii = reverse ? resolveSize(this) : 0, function (v) {
	      return fn(v, reverse ? --ii : ii++, this$0);
	    }), reverse);
	  };
	
	  ToKeyedSequence.prototype.__iterator = function (type, reverse) {
	    if (this._useKeys) {
	      return this._iter.__iterator(type, reverse);
	    }
	    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	    var ii = reverse ? resolveSize(this) : 0;
	    return new Iterator(function () {
	      var step = iterator.next();
	      return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	    });
	  };
	
	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
	
	  createClass(ToIndexedSequence, IndexedSeq);
	  function ToIndexedSequence(iter) {
	    this._iter = iter;
	    this.size = iter.size;
	  }
	
	  ToIndexedSequence.prototype.includes = function (value) {
	    return this._iter.includes(value);
	  };
	
	  ToIndexedSequence.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    var iterations = 0;
	    return this._iter.__iterate(function (v) {
	      return fn(v, iterations++, this$0);
	    }, reverse);
	  };
	
	  ToIndexedSequence.prototype.__iterator = function (type, reverse) {
	    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	    var iterations = 0;
	    return new Iterator(function () {
	      var step = iterator.next();
	      return step.done ? step : iteratorValue(type, iterations++, step.value, step);
	    });
	  };
	
	  createClass(ToSetSequence, SetSeq);
	  function ToSetSequence(iter) {
	    this._iter = iter;
	    this.size = iter.size;
	  }
	
	  ToSetSequence.prototype.has = function (key) {
	    return this._iter.includes(key);
	  };
	
	  ToSetSequence.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    return this._iter.__iterate(function (v) {
	      return fn(v, v, this$0);
	    }, reverse);
	  };
	
	  ToSetSequence.prototype.__iterator = function (type, reverse) {
	    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	    return new Iterator(function () {
	      var step = iterator.next();
	      return step.done ? step : iteratorValue(type, step.value, step.value, step);
	    });
	  };
	
	  createClass(FromEntriesSequence, KeyedSeq);
	  function FromEntriesSequence(entries) {
	    this._iter = entries;
	    this.size = entries.size;
	  }
	
	  FromEntriesSequence.prototype.entrySeq = function () {
	    return this._iter.toSeq();
	  };
	
	  FromEntriesSequence.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    return this._iter.__iterate(function (entry) {
	      // Check if entry exists first so array access doesn't throw for holes
	      // in the parent iteration.
	      if (entry) {
	        validateEntry(entry);
	        var indexedIterable = isIterable(entry);
	        return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
	      }
	    }, reverse);
	  };
	
	  FromEntriesSequence.prototype.__iterator = function (type, reverse) {
	    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	    return new Iterator(function () {
	      while (true) {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
	        }
	      }
	    });
	  };
	
	  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
	
	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function () {
	      return iterable;
	    };
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function () {
	        return iterable.reverse();
	      };
	      return reversedSequence;
	    };
	    flipSequence.has = function (key) {
	      return iterable.includes(key);
	    };
	    flipSequence.includes = function (key) {
	      return iterable.has(key);
	    };
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {
	      var this$0 = this;
	      return iterable.__iterate(function (v, k) {
	        return fn(k, v, this$0) !== false;
	      }, reverse);
	    };
	    flipSequence.__iteratorUncached = function (type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function () {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
	    };
	    return flipSequence;
	  }
	
	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function (key) {
	      return iterable.has(key);
	    };
	    mappedSequence.get = function (key, notSetValue) {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {
	      var this$0 = this;
	      return iterable.__iterate(function (v, k, c) {
	        return fn(mapper.call(context, v, k, c), k, this$0) !== false;
	      }, reverse);
	    };
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function () {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
	      });
	    };
	    return mappedSequence;
	  }
	
	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function () {
	      return iterable;
	    };
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function () {
	          return iterable.flip();
	        };
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function (key, notSetValue) {
	      return iterable.get(useKeys ? key : -1 - key, notSetValue);
	    };
	    reversedSequence.has = function (key) {
	      return iterable.has(useKeys ? key : -1 - key);
	    };
	    reversedSequence.includes = function (value) {
	      return iterable.includes(value);
	    };
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {
	      var this$0 = this;
	      return iterable.__iterate(function (v, k) {
	        return fn(v, k, this$0);
	      }, !reverse);
	    };
	    reversedSequence.__iterator = function (type, reverse) {
	      return iterable.__iterator(type, !reverse);
	    };
	    return reversedSequence;
	  }
	
	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function (key) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function (key, notSetValue) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {
	      var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function (v, k, c) {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function () {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    };
	    return filterSequence;
	  }
	
	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function (v, k) {
	      groups.update(grouper.call(context, v, k, iterable), 0, function (a) {
	        return a + 1;
	      });
	    });
	    return groups.asImmutable();
	  }
	
	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function (v, k) {
	      groups.update(grouper.call(context, v, k, iterable), function (a) {
	        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
	      });
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function (arr) {
	      return reify(iterable, coerce(arr));
	    });
	  }
	
	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;
	
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }
	
	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }
	
	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);
	
	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }
	
	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }
	
	    var sliceSeq = makeSequence(iterable);
	
	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
	
	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
	      };
	    }
	
	    sliceSeq.__iterateUncached = function (fn, reverse) {
	      var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function (v, k) {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };
	
	    sliceSeq.__iteratorUncached = function (type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function () {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    };
	
	    return sliceSeq;
	  }
	
	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function (fn, reverse) {
	      var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function (v, k, c) {
	        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
	      });
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function (type, reverse) {
	      var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function () {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }
	
	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {
	      var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function (v, k, c) {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function (type, reverse) {
	      var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function () {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }
	
	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function (v) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function (v) {
	      return v.size !== 0;
	    });
	
	    if (iters.length === 0) {
	      return iterable;
	    }
	
	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }
	
	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(function (sum, seq) {
	      if (sum !== undefined) {
	        var size = seq.size;
	        if (size !== undefined) {
	          return sum + size;
	        }
	      }
	    }, 0);
	    return concatSeq;
	  }
	
	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function (fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {
	        var this$0 = this;
	        iter.__iterate(function (v, k) {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    };
	    flatSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function () {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    };
	    return flatSequence;
	  }
	
	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(function (v, k) {
	      return coerce(mapper.call(context, v, k, iterable));
	    }).flatten(true);
	  }
	
	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 - 1;
	    interposedSequence.__iterateUncached = function (fn, reverse) {
	      var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function (v, k) {
	        return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
	      }, reverse);
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function () {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }
	
	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(function (v, k) {
	      return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
	    }).toArray();
	    entries.sort(function (a, b) {
	      return comparator(a[3], b[3]) || a[2] - b[2];
	    }).forEach(isKeyedIterable ? function (v, i) {
	      entries[i].length = 2;
	    } : function (v, i) {
	      entries[i] = v[1];
	    });
	    return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
	  }
	
	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq().map(function (v, k) {
	        return [v, mapper(v, k, iterable)];
	      }).reduce(function (a, b) {
	        return maxCompare(comparator, a[1], b[1]) ? b : a;
	      });
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function (a, b) {
	        return maxCompare(comparator, a, b) ? b : a;
	      });
	    }
	  }
	
	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
	  }
	
	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function (i) {
	      return i.size;
	    }).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function (fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function (type, reverse) {
	      var iterators = iters.map(function (i) {
	        return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
	      });
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function () {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function (i) {
	            return i.next();
	          });
	          isDone = steps.some(function (s) {
	            return s.done;
	          });
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
	          return s.value;
	        })));
	      });
	    };
	    return zipSequence;
	  }
	
	  // #pragma Helper Functions
	
	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }
	
	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }
	
	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }
	
	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
	  }
	
	  function makeSequence(iterable) {
	    return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
	  }
	
	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }
	
	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }
	
	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }
	
	  createClass(Record, KeyedCollection);
	
	  function Record(defaultValues, name) {
	    var hasInitialized;
	
	    var RecordType = function Record(values) {
	      if (values instanceof RecordType) {
	        return values;
	      }
	      if (!(this instanceof RecordType)) {
	        return new RecordType(values);
	      }
	      if (!hasInitialized) {
	        hasInitialized = true;
	        var keys = Object.keys(defaultValues);
	        setProps(RecordTypePrototype, keys);
	        RecordTypePrototype.size = keys.length;
	        RecordTypePrototype._name = name;
	        RecordTypePrototype._keys = keys;
	        RecordTypePrototype._defaultValues = defaultValues;
	      }
	      this._map = Map(values);
	    };
	
	    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	    RecordTypePrototype.constructor = RecordType;
	
	    return RecordType;
	  }
	
	  Record.prototype.toString = function () {
	    return this.__toString(recordName(this) + ' {', '}');
	  };
	
	  // @pragma Access
	
	  Record.prototype.has = function (k) {
	    return this._defaultValues.hasOwnProperty(k);
	  };
	
	  Record.prototype.get = function (k, notSetValue) {
	    if (!this.has(k)) {
	      return notSetValue;
	    }
	    var defaultVal = this._defaultValues[k];
	    return this._map ? this._map.get(k, defaultVal) : defaultVal;
	  };
	
	  // @pragma Modification
	
	  Record.prototype.clear = function () {
	    if (this.__ownerID) {
	      this._map && this._map.clear();
	      return this;
	    }
	    var RecordType = this.constructor;
	    return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	  };
	
	  Record.prototype.set = function (k, v) {
	    if (!this.has(k)) {
	      throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	    }
	    if (this._map && !this._map.has(k)) {
	      var defaultVal = this._defaultValues[k];
	      if (v === defaultVal) {
	        return this;
	      }
	    }
	    var newMap = this._map && this._map.set(k, v);
	    if (this.__ownerID || newMap === this._map) {
	      return this;
	    }
	    return makeRecord(this, newMap);
	  };
	
	  Record.prototype.remove = function (k) {
	    if (!this.has(k)) {
	      return this;
	    }
	    var newMap = this._map && this._map.remove(k);
	    if (this.__ownerID || newMap === this._map) {
	      return this;
	    }
	    return makeRecord(this, newMap);
	  };
	
	  Record.prototype.wasAltered = function () {
	    return this._map.wasAltered();
	  };
	
	  Record.prototype.__iterator = function (type, reverse) {
	    var this$0 = this;
	    return KeyedIterable(this._defaultValues).map(function (_, k) {
	      return this$0.get(k);
	    }).__iterator(type, reverse);
	  };
	
	  Record.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    return KeyedIterable(this._defaultValues).map(function (_, k) {
	      return this$0.get(k);
	    }).__iterate(fn, reverse);
	  };
	
	  Record.prototype.__ensureOwner = function (ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    var newMap = this._map && this._map.__ensureOwner(ownerID);
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      this._map = newMap;
	      return this;
	    }
	    return makeRecord(this, newMap, ownerID);
	  };
	
	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;
	
	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }
	
	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }
	
	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }
	
	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function get() {
	        return this.get(name);
	      },
	      set: function set(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }
	
	  createClass(Set, SetCollection);
	
	  // @pragma Construction
	
	  function Set(value) {
	    return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
	      var iter = SetIterable(value);
	      assertNotInfinite(iter.size);
	      iter.forEach(function (v) {
	        return set.add(v);
	      });
	    });
	  }
	
	  Set.of = function () /*...values*/{
	    return this(arguments);
	  };
	
	  Set.fromKeys = function (value) {
	    return this(KeyedIterable(value).keySeq());
	  };
	
	  Set.prototype.toString = function () {
	    return this.__toString('Set {', '}');
	  };
	
	  // @pragma Access
	
	  Set.prototype.has = function (value) {
	    return this._map.has(value);
	  };
	
	  // @pragma Modification
	
	  Set.prototype.add = function (value) {
	    return updateSet(this, this._map.set(value, true));
	  };
	
	  Set.prototype.remove = function (value) {
	    return updateSet(this, this._map.remove(value));
	  };
	
	  Set.prototype.clear = function () {
	    return updateSet(this, this._map.clear());
	  };
	
	  // @pragma Composition
	
	  Set.prototype.union = function () {
	    var iters = SLICE$0.call(arguments, 0);
	    iters = iters.filter(function (x) {
	      return x.size !== 0;
	    });
	    if (iters.length === 0) {
	      return this;
	    }
	    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	      return this.constructor(iters[0]);
	    }
	    return this.withMutations(function (set) {
	      for (var ii = 0; ii < iters.length; ii++) {
	        SetIterable(iters[ii]).forEach(function (value) {
	          return set.add(value);
	        });
	      }
	    });
	  };
	
	  Set.prototype.intersect = function () {
	    var iters = SLICE$0.call(arguments, 0);
	    if (iters.length === 0) {
	      return this;
	    }
	    iters = iters.map(function (iter) {
	      return SetIterable(iter);
	    });
	    var originalSet = this;
	    return this.withMutations(function (set) {
	      originalSet.forEach(function (value) {
	        if (!iters.every(function (iter) {
	          return iter.includes(value);
	        })) {
	          set.remove(value);
	        }
	      });
	    });
	  };
	
	  Set.prototype.subtract = function () {
	    var iters = SLICE$0.call(arguments, 0);
	    if (iters.length === 0) {
	      return this;
	    }
	    iters = iters.map(function (iter) {
	      return SetIterable(iter);
	    });
	    var originalSet = this;
	    return this.withMutations(function (set) {
	      originalSet.forEach(function (value) {
	        if (iters.some(function (iter) {
	          return iter.includes(value);
	        })) {
	          set.remove(value);
	        }
	      });
	    });
	  };
	
	  Set.prototype.merge = function () {
	    return this.union.apply(this, arguments);
	  };
	
	  Set.prototype.mergeWith = function (merger) {
	    var iters = SLICE$0.call(arguments, 1);
	    return this.union.apply(this, iters);
	  };
	
	  Set.prototype.sort = function (comparator) {
	    // Late binding
	    return OrderedSet(sortFactory(this, comparator));
	  };
	
	  Set.prototype.sortBy = function (mapper, comparator) {
	    // Late binding
	    return OrderedSet(sortFactory(this, comparator, mapper));
	  };
	
	  Set.prototype.wasAltered = function () {
	    return this._map.wasAltered();
	  };
	
	  Set.prototype.__iterate = function (fn, reverse) {
	    var this$0 = this;
	    return this._map.__iterate(function (_, k) {
	      return fn(k, k, this$0);
	    }, reverse);
	  };
	
	  Set.prototype.__iterator = function (type, reverse) {
	    return this._map.map(function (_, k) {
	      return k;
	    }).__iterator(type, reverse);
	  };
	
	  Set.prototype.__ensureOwner = function (ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    var newMap = this._map.__ensureOwner(ownerID);
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      this._map = newMap;
	      return this;
	    }
	    return this.__make(newMap, ownerID);
	  };
	
	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }
	
	  Set.isSet = isSet;
	
	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
	
	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;
	
	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;
	
	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
	  }
	
	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }
	
	  createClass(OrderedSet, Set);
	
	  // @pragma Construction
	
	  function OrderedSet(value) {
	    return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
	      var iter = SetIterable(value);
	      assertNotInfinite(iter.size);
	      iter.forEach(function (v) {
	        return set.add(v);
	      });
	    });
	  }
	
	  OrderedSet.of = function () /*...values*/{
	    return this(arguments);
	  };
	
	  OrderedSet.fromKeys = function (value) {
	    return this(KeyedIterable(value).keySeq());
	  };
	
	  OrderedSet.prototype.toString = function () {
	    return this.__toString('OrderedSet {', '}');
	  };
	
	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }
	
	  OrderedSet.isOrderedSet = isOrderedSet;
	
	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
	
	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;
	
	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }
	
	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }
	
	  createClass(Stack, IndexedCollection);
	
	  // @pragma Construction
	
	  function Stack(value) {
	    return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
	  }
	
	  Stack.of = function () /*...values*/{
	    return this(arguments);
	  };
	
	  Stack.prototype.toString = function () {
	    return this.__toString('Stack [', ']');
	  };
	
	  // @pragma Access
	
	  Stack.prototype.get = function (index, notSetValue) {
	    var head = this._head;
	    index = wrapIndex(this, index);
	    while (head && index--) {
	      head = head.next;
	    }
	    return head ? head.value : notSetValue;
	  };
	
	  Stack.prototype.peek = function () {
	    return this._head && this._head.value;
	  };
	
	  // @pragma Modification
	
	  Stack.prototype.push = function () /*...values*/{
	    if (arguments.length === 0) {
	      return this;
	    }
	    var newSize = this.size + arguments.length;
	    var head = this._head;
	    for (var ii = arguments.length - 1; ii >= 0; ii--) {
	      head = {
	        value: arguments[ii],
	        next: head
	      };
	    }
	    if (this.__ownerID) {
	      this.size = newSize;
	      this._head = head;
	      this.__hash = undefined;
	      this.__altered = true;
	      return this;
	    }
	    return makeStack(newSize, head);
	  };
	
	  Stack.prototype.pushAll = function (iter) {
	    iter = IndexedIterable(iter);
	    if (iter.size === 0) {
	      return this;
	    }
	    assertNotInfinite(iter.size);
	    var newSize = this.size;
	    var head = this._head;
	    iter.reverse().forEach(function (value) {
	      newSize++;
	      head = {
	        value: value,
	        next: head
	      };
	    });
	    if (this.__ownerID) {
	      this.size = newSize;
	      this._head = head;
	      this.__hash = undefined;
	      this.__altered = true;
	      return this;
	    }
	    return makeStack(newSize, head);
	  };
	
	  Stack.prototype.pop = function () {
	    return this.slice(1);
	  };
	
	  Stack.prototype.unshift = function () /*...values*/{
	    return this.push.apply(this, arguments);
	  };
	
	  Stack.prototype.unshiftAll = function (iter) {
	    return this.pushAll(iter);
	  };
	
	  Stack.prototype.shift = function () {
	    return this.pop.apply(this, arguments);
	  };
	
	  Stack.prototype.clear = function () {
	    if (this.size === 0) {
	      return this;
	    }
	    if (this.__ownerID) {
	      this.size = 0;
	      this._head = undefined;
	      this.__hash = undefined;
	      this.__altered = true;
	      return this;
	    }
	    return emptyStack();
	  };
	
	  Stack.prototype.slice = function (begin, end) {
	    if (wholeSlice(begin, end, this.size)) {
	      return this;
	    }
	    var resolvedBegin = resolveBegin(begin, this.size);
	    var resolvedEnd = resolveEnd(end, this.size);
	    if (resolvedEnd !== this.size) {
	      // super.slice(begin, end);
	      return IndexedCollection.prototype.slice.call(this, begin, end);
	    }
	    var newSize = this.size - resolvedBegin;
	    var head = this._head;
	    while (resolvedBegin--) {
	      head = head.next;
	    }
	    if (this.__ownerID) {
	      this.size = newSize;
	      this._head = head;
	      this.__hash = undefined;
	      this.__altered = true;
	      return this;
	    }
	    return makeStack(newSize, head);
	  };
	
	  // @pragma Mutability
	
	  Stack.prototype.__ensureOwner = function (ownerID) {
	    if (ownerID === this.__ownerID) {
	      return this;
	    }
	    if (!ownerID) {
	      this.__ownerID = ownerID;
	      this.__altered = false;
	      return this;
	    }
	    return makeStack(this.size, this._head, ownerID, this.__hash);
	  };
	
	  // @pragma Iteration
	
	  Stack.prototype.__iterate = function (fn, reverse) {
	    if (reverse) {
	      return this.reverse().__iterate(fn);
	    }
	    var iterations = 0;
	    var node = this._head;
	    while (node) {
	      if (fn(node.value, iterations++, this) === false) {
	        break;
	      }
	      node = node.next;
	    }
	    return iterations;
	  };
	
	  Stack.prototype.__iterator = function (type, reverse) {
	    if (reverse) {
	      return this.reverse().__iterator(type);
	    }
	    var iterations = 0;
	    var node = this._head;
	    return new Iterator(function () {
	      if (node) {
	        var value = node.value;
	        node = node.next;
	        return iteratorValue(type, iterations++, value);
	      }
	      return iteratorDone();
	    });
	  };
	
	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }
	
	  Stack.isStack = isStack;
	
	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
	
	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;
	
	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }
	
	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }
	
	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function keyCopier(key) {
	      ctor.prototype[key] = methods[key];
	    };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }
	
	  Iterable.Iterator = Iterator;
	
	  mixin(Iterable, {
	
	    // ### Conversion to other types
	
	    toArray: function toArray() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function (v, i) {
	        array[i] = v;
	      });
	      return array;
	    },
	
	    toIndexedSeq: function toIndexedSeq() {
	      return new ToIndexedSequence(this);
	    },
	
	    toJS: function toJS() {
	      return this.toSeq().map(function (value) {
	        return value && typeof value.toJS === 'function' ? value.toJS() : value;
	      }).__toJS();
	    },
	
	    toJSON: function toJSON() {
	      return this.toSeq().map(function (value) {
	        return value && typeof value.toJSON === 'function' ? value.toJSON() : value;
	      }).__toJS();
	    },
	
	    toKeyedSeq: function toKeyedSeq() {
	      return new ToKeyedSequence(this, true);
	    },
	
	    toMap: function toMap() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },
	
	    toObject: function toObject() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function (v, k) {
	        object[k] = v;
	      });
	      return object;
	    },
	
	    toOrderedMap: function toOrderedMap() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },
	
	    toOrderedSet: function toOrderedSet() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSet: function toSet() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toSetSeq: function toSetSeq() {
	      return new ToSetSequence(this);
	    },
	
	    toSeq: function toSeq() {
	      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
	    },
	
	    toStack: function toStack() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    toList: function toList() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },
	
	    // ### Common JavaScript methods and properties
	
	    toString: function toString() {
	      return '[Iterable]';
	    },
	
	    __toString: function __toString(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    concat: function concat() {
	      var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },
	
	    includes: function includes(searchValue) {
	      return this.some(function (value) {
	        return is(value, searchValue);
	      });
	    },
	
	    entries: function entries() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },
	
	    every: function every(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function (v, k, c) {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },
	
	    filter: function filter(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },
	
	    find: function find(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },
	
	    forEach: function forEach(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },
	
	    join: function join(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function (v) {
	        isFirst ? isFirst = false : joined += separator;
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },
	
	    keys: function keys() {
	      return this.__iterator(ITERATE_KEYS);
	    },
	
	    map: function map(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },
	
	    reduce: function reduce(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function (v, k, c) {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },
	
	    reduceRight: function reduceRight(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },
	
	    reverse: function reverse() {
	      return reify(this, reverseFactory(this, true));
	    },
	
	    slice: function slice(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },
	
	    some: function some(predicate, context) {
	      return !this.every(not(predicate), context);
	    },
	
	    sort: function sort(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },
	
	    values: function values() {
	      return this.__iterator(ITERATE_VALUES);
	    },
	
	    // ### More sequential methods
	
	    butLast: function butLast() {
	      return this.slice(0, -1);
	    },
	
	    isEmpty: function isEmpty() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function () {
	        return true;
	      });
	    },
	
	    count: function count(predicate, context) {
	      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
	    },
	
	    countBy: function countBy(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },
	
	    equals: function equals(other) {
	      return deepEqual(this, other);
	    },
	
	    entrySeq: function entrySeq() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function () {
	        return iterable.toSeq();
	      };
	      return entriesSequence;
	    },
	
	    filterNot: function filterNot(predicate, context) {
	      return this.filter(not(predicate), context);
	    },
	
	    findEntry: function findEntry(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function (v, k, c) {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },
	
	    findKey: function findKey(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },
	
	    findLast: function findLast(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },
	
	    findLastEntry: function findLastEntry(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },
	
	    findLastKey: function findLastKey(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },
	
	    first: function first() {
	      return this.find(returnTrue);
	    },
	
	    flatMap: function flatMap(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },
	
	    flatten: function flatten(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },
	
	    fromEntrySeq: function fromEntrySeq() {
	      return new FromEntriesSequence(this);
	    },
	
	    get: function get(searchKey, notSetValue) {
	      return this.find(function (_, key) {
	        return is(key, searchKey);
	      }, undefined, notSetValue);
	    },
	
	    getIn: function getIn(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },
	
	    groupBy: function groupBy(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },
	
	    has: function has(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },
	
	    hasIn: function hasIn(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },
	
	    isSubset: function isSubset(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function (value) {
	        return iter.includes(value);
	      });
	    },
	
	    isSuperset: function isSuperset(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },
	
	    keyOf: function keyOf(searchValue) {
	      return this.findKey(function (value) {
	        return is(value, searchValue);
	      });
	    },
	
	    keySeq: function keySeq() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },
	
	    last: function last() {
	      return this.toSeq().reverse().first();
	    },
	
	    lastKeyOf: function lastKeyOf(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },
	
	    max: function max(comparator) {
	      return maxFactory(this, comparator);
	    },
	
	    maxBy: function maxBy(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },
	
	    min: function min(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },
	
	    minBy: function minBy(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },
	
	    rest: function rest() {
	      return this.slice(1);
	    },
	
	    skip: function skip(amount) {
	      return this.slice(Math.max(0, amount));
	    },
	
	    skipLast: function skipLast(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },
	
	    skipWhile: function skipWhile(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },
	
	    skipUntil: function skipUntil(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },
	
	    sortBy: function sortBy(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },
	
	    take: function take(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },
	
	    takeLast: function takeLast(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },
	
	    takeWhile: function takeWhile(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },
	
	    takeUntil: function takeUntil(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },
	
	    valueSeq: function valueSeq() {
	      return this.toIndexedSeq();
	    },
	
	    // ### Hashable Object
	
	    hashCode: function hashCode() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }
	
	    // ### Internal
	
	    // abstract __iterate(fn, reverse)
	
	    // abstract __iterator(type, reverse)
	  });
	
	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
	
	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect = IterablePrototype.toSource = function () {
	    return this.toString();
	  };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;
	
	  mixin(KeyedIterable, {
	
	    // ### More sequential methods
	
	    flip: function flip() {
	      return reify(this, flipFactory(this));
	    },
	
	    mapEntries: function mapEntries(mapper, context) {
	      var this$0 = this;
	      var iterations = 0;
	      return reify(this, this.toSeq().map(function (v, k) {
	        return mapper.call(context, [k, v], iterations++, this$0);
	      }).fromEntrySeq());
	    },
	
	    mapKeys: function mapKeys(mapper, context) {
	      var this$0 = this;
	      return reify(this, this.toSeq().flip().map(function (k, v) {
	        return mapper.call(context, k, v, this$0);
	      }).flip());
	    }
	
	  });
	
	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function (v, k) {
	    return JSON.stringify(k) + ': ' + quoteString(v);
	  };
	
	  mixin(IndexedIterable, {
	
	    // ### Conversion to other types
	
	    toKeyedSeq: function toKeyedSeq() {
	      return new ToKeyedSequence(this, false);
	    },
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    filter: function filter(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },
	
	    findIndex: function findIndex(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    indexOf: function indexOf(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    lastIndexOf: function lastIndexOf(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },
	
	    reverse: function reverse() {
	      return reify(this, reverseFactory(this, false));
	    },
	
	    slice: function slice(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },
	
	    splice: function splice(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || numArgs === 2 && !removeNum) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
	    },
	
	    // ### More collection methods
	
	    findLastIndex: function findLastIndex(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },
	
	    first: function first() {
	      return this.get(0);
	    },
	
	    flatten: function flatten(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },
	
	    get: function get(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
	        return key === index;
	      }, undefined, notSetValue);
	    },
	
	    has: function has(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
	    },
	
	    interpose: function interpose(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },
	
	    interleave: function interleave() /*...iterables*/{
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },
	
	    keySeq: function keySeq() {
	      return Range(0, this.size);
	    },
	
	    last: function last() {
	      return this.get(-1);
	    },
	
	    skipWhile: function skipWhile(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },
	
	    zip: function zip() /*, ...iterables */{
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },
	
	    zipWith: function zipWith(zipper /*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }
	
	  });
	
	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
	
	  mixin(SetIterable, {
	
	    // ### ES6 Collection methods (ES6 Array and Map)
	
	    get: function get(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },
	
	    includes: function includes(value) {
	      return this.has(value);
	    },
	
	    // ### More sequential methods
	
	    keySeq: function keySeq() {
	      return this.valueSeq();
	    }
	
	  });
	
	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;
	
	  // Mixin subclasses
	
	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);
	
	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);
	
	  // #pragma Helper functions
	
	  function keyMapper(v, k) {
	    return k;
	  }
	
	  function entryMapper(v, k) {
	    return [k, v];
	  }
	
	  function not(predicate) {
	    return function () {
	      return !predicate.apply(this, arguments);
	    };
	  }
	
	  function neg(predicate) {
	    return function () {
	      return -predicate.apply(this, arguments);
	    };
	  }
	
	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }
	
	  function defaultZipper() {
	    return arrCopy(arguments);
	  }
	
	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }
	
	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(keyed ? ordered ? function (v, k) {
	      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
	    } : function (v, k) {
	      h = h + hashMerge(hash(v), hash(k)) | 0;
	    } : ordered ? function (v) {
	      h = 31 * h + hash(v) | 0;
	    } : function (v) {
	      h = h + hash(v) | 0;
	    });
	    return murmurHashOfSize(size, h);
	  }
	
	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }
	
	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }
	
	  var Immutable = {
	
	    Iterable: Iterable,
	
	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,
	
	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,
	
	    is: is,
	    fromJS: fromJS
	
	  };
	
	  return Immutable;
	});

/***/ }),
/* 123 */,
/* 124 */
/*!**************************************************!*\
  !*** ./~/prop-types/lib/ReactPropTypesSecret.js ***!
  \**************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ }),
/* 125 */
/*!*************************************!*\
  !*** ./~/react-mdl/lib/Checkbox.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    checked: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    disabled: _react.PropTypes.bool,
	    label: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    ripple: _react.PropTypes.bool
	};
	
	var Checkbox = function (_React$Component) {
	    _inherits(Checkbox, _React$Component);
	
	    function Checkbox() {
	        _classCallCheck(this, Checkbox);
	
	        return _possibleConstructorReturn(this, (Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).apply(this, arguments));
	    }
	
	    _createClass(Checkbox, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps) {
	            if (this.props.disabled !== prevProps.disabled) {
	                var fnName = this.props.disabled ? 'disable' : 'enable';
	                (0, _reactDom.findDOMNode)(this).MaterialCheckbox[fnName]();
	            }
	            if (this.props.checked !== prevProps.checked) {
	                var _fnName = this.props.checked ? 'check' : 'uncheck';
	                (0, _reactDom.findDOMNode)(this).MaterialCheckbox[_fnName]();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                className = _props.className,
	                label = _props.label,
	                ripple = _props.ripple,
	                inputProps = _objectWithoutProperties(_props, ['className', 'label', 'ripple']);
	
	            var classes = (0, _classnames2.default)('mdl-checkbox mdl-js-checkbox', {
	                'mdl-js-ripple-effect': ripple
	            }, className);
	
	            return _react2.default.createElement('label', { className: classes }, _react2.default.createElement('input', _extends({
	                type: 'checkbox',
	                className: 'mdl-checkbox__input'
	            }, inputProps)), label && _react2.default.createElement('span', { className: 'mdl-checkbox__label' }, label));
	        }
	    }]);
	
	    return Checkbox;
	}(_react2.default.Component);
	
	Checkbox.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Checkbox, true);

/***/ }),
/* 126 */
/*!*********************************************!*\
  !*** ./~/react-mdl/lib/Layout/HeaderRow.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Spacer = __webpack_require__(/*! ./Spacer */ 76);
	
	var _Spacer2 = _interopRequireDefault(_Spacer);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var HeaderRow = function HeaderRow(props) {
	    var className = props.className,
	        title = props.title,
	        children = props.children,
	        hideSpacer = props.hideSpacer,
	        otherProps = _objectWithoutProperties(props, ['className', 'title', 'children', 'hideSpacer']);
	
	    var classes = (0, _classnames2.default)('mdl-layout__header-row', className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), title && _react2.default.createElement('span', { className: 'mdl-layout-title' }, title), title && !hideSpacer && _react2.default.createElement(_Spacer2.default, null), children);
	};
	HeaderRow.propTypes = {
	    className: _react.PropTypes.string,
	    title: _react.PropTypes.node,
	    hideSpacer: _react.PropTypes.bool
	};
	
	exports.default = HeaderRow;

/***/ }),
/* 127 */
/*!**********************************************!*\
  !*** ./~/react-mdl/lib/Layout/HeaderTabs.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _TabBar = __webpack_require__(/*! ../Tabs/TabBar */ 77);
	
	var _TabBar2 = _interopRequireDefault(_TabBar);
	
	var _mdlUpgrade = __webpack_require__(/*! ../utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var HeaderTabs = function HeaderTabs(props) {
	    var className = props.className,
	        ripple = props.ripple,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'ripple', 'children']);
	
	    var classes = (0, _classnames2.default)({
	        'mdl-js-ripple-effect': ripple,
	        'mdl-js-ripple-effect--ignore-events': ripple
	    }, className);
	
	    return _react2.default.createElement(_TabBar2.default, _extends({ cssPrefix: 'mdl-layout', className: classes }, otherProps), children);
	};
	HeaderTabs.propTypes = {
	    activeTab: _react.PropTypes.number,
	    className: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    ripple: _react.PropTypes.bool
	};
	
	exports.default = (0, _mdlUpgrade2.default)(HeaderTabs);

/***/ }),
/* 128 */
/*!*************************************************!*\
  !*** ./~/react-mdl/lib/List/ListItemContent.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Icon = __webpack_require__(/*! ../Icon */ 37);
	
	var _Icon2 = _interopRequireDefault(_Icon);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    avatar: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element]),
	    children: _react.PropTypes.node,
	    className: _react.PropTypes.string,
	    icon: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element]),
	    subtitle: _react.PropTypes.node,
	    useBodyClass: _react.PropTypes.bool
	};
	
	function createIcon(type, icon) {
	    if (typeof icon === 'string') {
	        return _react2.default.createElement(_Icon2.default, { className: 'mdl-list__item-' + type, name: icon });
	    }
	    return _react2.default.cloneElement(icon, { className: 'mdl-list__item-' + type });
	}
	
	var ListItemContent = function ListItemContent(props) {
	    var avatar = props.avatar,
	        children = props.children,
	        className = props.className,
	        icon = props.icon,
	        subtitle = props.subtitle,
	        useBodyClass = props.useBodyClass,
	        otherProps = _objectWithoutProperties(props, ['avatar', 'children', 'className', 'icon', 'subtitle', 'useBodyClass']);
	
	    var classes = (0, _classnames2.default)('mdl-list__item-primary-content', className);
	    var subtitleClassName = useBodyClass ? 'mdl-list__item-text-body' : 'mdl-list__item-sub-title';
	
	    var iconElement = null;
	    if (icon) {
	        iconElement = createIcon('icon', icon);
	    } else if (avatar) {
	        iconElement = createIcon('avatar', avatar);
	    }
	
	    return _react2.default.createElement('span', _extends({ className: classes }, otherProps), iconElement, _react2.default.createElement('span', null, children), subtitle && _react2.default.createElement('span', { className: subtitleClassName }, subtitle));
	};
	
	ListItemContent.propTypes = propTypes;
	
	exports.default = ListItemContent;

/***/ }),
/* 129 */
/*!**********************************!*\
  !*** ./~/react-mdl/lib/Radio.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    checked: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    disabled: _react.PropTypes.bool,
	    name: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    ripple: _react.PropTypes.bool,
	    value: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]).isRequired
	};
	
	var Radio = function (_React$Component) {
	    _inherits(Radio, _React$Component);
	
	    function Radio() {
	        _classCallCheck(this, Radio);
	
	        return _possibleConstructorReturn(this, (Radio.__proto__ || Object.getPrototypeOf(Radio)).apply(this, arguments));
	    }
	
	    _createClass(Radio, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps) {
	            if (this.props.disabled !== prevProps.disabled) {
	                var fnName = this.props.disabled ? 'disable' : 'enable';
	                (0, _reactDom.findDOMNode)(this).MaterialRadio[fnName]();
	            }
	            if (this.props.checked !== prevProps.checked) {
	                var _fnName = this.props.checked ? 'check' : 'uncheck';
	                (0, _reactDom.findDOMNode)(this).MaterialRadio[_fnName]();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                children = _props.children,
	                className = _props.className,
	                name = _props.name,
	                ripple = _props.ripple,
	                value = _props.value,
	                inputProps = _objectWithoutProperties(_props, ['children', 'className', 'name', 'ripple', 'value']);
	
	            var classes = (0, _classnames2.default)('mdl-radio mdl-js-radio', {
	                'mdl-js-ripple-effect': ripple
	            }, className);
	
	            return _react2.default.createElement('label', { className: classes }, _react2.default.createElement('input', _extends({
	                type: 'radio',
	                className: 'mdl-radio__button',
	                value: value,
	                name: name
	            }, inputProps)), _react2.default.createElement('span', { className: 'mdl-radio__label' }, children));
	        }
	    }]);
	
	    return Radio;
	}(_react2.default.Component);
	
	Radio.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Radio, true);

/***/ }),
/* 130 */
/*!*************************************!*\
  !*** ./~/react-mdl/lib/Tabs/Tab.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    active: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element, _react.PropTypes.func]),
	    cssPrefix: _react.PropTypes.string,
	    onTabClick: _react.PropTypes.func,
	    style: _react.PropTypes.object,
	    tabId: _react.PropTypes.number
	};
	
	var defaultProps = {
	    style: {}
	};
	
	var Tab = function Tab(props) {
	    var _classNames;
	
	    var active = props.active,
	        className = props.className,
	        component = props.component,
	        children = props.children,
	        cssPrefix = props.cssPrefix,
	        onTabClick = props.onTabClick,
	        style = props.style,
	        tabId = props.tabId,
	        otherProps = _objectWithoutProperties(props, ['active', 'className', 'component', 'children', 'cssPrefix', 'onTabClick', 'style', 'tabId']);
	
	    var classes = (0, _classnames2.default)((_classNames = {}, _defineProperty(_classNames, cssPrefix + '__tab', true), _defineProperty(_classNames, 'is-active', active), _classNames), className);
	
	    style.cursor = 'pointer';
	
	    return _react2.default.createElement(component || 'a', _extends({
	        className: classes,
	        onClick: function onClick() {
	            return onTabClick(tabId);
	        },
	        style: style
	    }, otherProps), children);
	};
	
	Tab.propTypes = propTypes;
	Tab.defaultProps = defaultProps;
	
	exports.default = Tab;

/***/ }),
/* 131 */
/*!************************************!*\
  !*** ./~/react-mdl/lib/Tooltip.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _MDLComponent = __webpack_require__(/*! ./utils/MDLComponent */ 78);
	
	var _MDLComponent2 = _interopRequireDefault(_MDLComponent);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var Tooltip = function Tooltip(props) {
	    var label = props.label,
	        large = props.large,
	        children = props.children,
	        position = props.position,
	        otherProps = _objectWithoutProperties(props, ['label', 'large', 'children', 'position']);
	
	    var id = Math.random().toString(36).substr(2);
	
	    var newLabel = typeof label === 'string' ? _react2.default.createElement('span', null, label) : label;
	
	    var element = void 0;
	    if (typeof children === 'string') {
	        element = _react2.default.createElement('span', null, children);
	    } else {
	        element = _react2.default.Children.only(children);
	    }
	
	    return _react2.default.createElement('div', _extends({ style: { display: 'inline-block' } }, otherProps), _react2.default.cloneElement(element, { id: id }), _react2.default.createElement(_MDLComponent2.default, null, _react2.default.cloneElement(newLabel, {
	        htmlFor: id,
	        className: (0, _classnames2.default)('mdl-tooltip', _defineProperty({
	            'mdl-tooltip--large': large
	        }, 'mdl-tooltip--' + position, typeof position !== 'undefined'))
	    })));
	};
	
	Tooltip.propTypes = {
	    children: _react.PropTypes.node.isRequired,
	    label: _react.PropTypes.node.isRequired,
	    large: _react.PropTypes.bool,
	    position: _react.PropTypes.oneOf(['left', 'right', 'top', 'bottom'])
	};
	
	exports.default = Tooltip;

/***/ }),
/* 132 */
/*!************************************!*\
  !*** ./~/swiper/dist/js/swiper.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery, __webpack_provided_window_dot_jQuery) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Swiper 3.4.2
	 * Most modern mobile touch slider and framework with hardware accelerated transitions
	 * 
	 * http://www.idangero.us/swiper/
	 * 
	 * Copyright 2017, Vladimir Kharlampidi
	 * The iDangero.us
	 * http://www.idangero.us/
	 * 
	 * Licensed under MIT
	 * 
	 * Released on: March 10, 2017
	 */
	(function () {
	    'use strict';
	
	    var $;
	
	    /*===========================
	    Swiper
	    ===========================*/
	    var Swiper = function Swiper(container, params) {
	        if (!(this instanceof Swiper)) return new Swiper(container, params);
	
	        var defaults = {
	            direction: 'horizontal',
	            touchEventsTarget: 'container',
	            initialSlide: 0,
	            speed: 300,
	            // autoplay
	            autoplay: false,
	            autoplayDisableOnInteraction: true,
	            autoplayStopOnLast: false,
	            // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
	            iOSEdgeSwipeDetection: false,
	            iOSEdgeSwipeThreshold: 20,
	            // Free mode
	            freeMode: false,
	            freeModeMomentum: true,
	            freeModeMomentumRatio: 1,
	            freeModeMomentumBounce: true,
	            freeModeMomentumBounceRatio: 1,
	            freeModeMomentumVelocityRatio: 1,
	            freeModeSticky: false,
	            freeModeMinimumVelocity: 0.02,
	            // Autoheight
	            autoHeight: false,
	            // Set wrapper width
	            setWrapperSize: false,
	            // Virtual Translate
	            virtualTranslate: false,
	            // Effects
	            effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
	            coverflow: {
	                rotate: 50,
	                stretch: 0,
	                depth: 100,
	                modifier: 1,
	                slideShadows: true
	            },
	            flip: {
	                slideShadows: true,
	                limitRotation: true
	            },
	            cube: {
	                slideShadows: true,
	                shadow: true,
	                shadowOffset: 20,
	                shadowScale: 0.94
	            },
	            fade: {
	                crossFade: false
	            },
	            // Parallax
	            parallax: false,
	            // Zoom
	            zoom: false,
	            zoomMax: 3,
	            zoomMin: 1,
	            zoomToggle: true,
	            // Scrollbar
	            scrollbar: null,
	            scrollbarHide: true,
	            scrollbarDraggable: false,
	            scrollbarSnapOnRelease: false,
	            // Keyboard Mousewheel
	            keyboardControl: false,
	            mousewheelControl: false,
	            mousewheelReleaseOnEdges: false,
	            mousewheelInvert: false,
	            mousewheelForceToAxis: false,
	            mousewheelSensitivity: 1,
	            mousewheelEventsTarged: 'container',
	            // Hash Navigation
	            hashnav: false,
	            hashnavWatchState: false,
	            // History
	            history: false,
	            // Commong Nav State
	            replaceState: false,
	            // Breakpoints
	            breakpoints: undefined,
	            // Slides grid
	            spaceBetween: 0,
	            slidesPerView: 1,
	            slidesPerColumn: 1,
	            slidesPerColumnFill: 'column',
	            slidesPerGroup: 1,
	            centeredSlides: false,
	            slidesOffsetBefore: 0, // in px
	            slidesOffsetAfter: 0, // in px
	            // Round length
	            roundLengths: false,
	            // Touches
	            touchRatio: 1,
	            touchAngle: 45,
	            simulateTouch: true,
	            shortSwipes: true,
	            longSwipes: true,
	            longSwipesRatio: 0.5,
	            longSwipesMs: 300,
	            followFinger: true,
	            onlyExternal: false,
	            threshold: 0,
	            touchMoveStopPropagation: true,
	            touchReleaseOnEdges: false,
	            // Unique Navigation Elements
	            uniqueNavElements: true,
	            // Pagination
	            pagination: null,
	            paginationElement: 'span',
	            paginationClickable: false,
	            paginationHide: false,
	            paginationBulletRender: null,
	            paginationProgressRender: null,
	            paginationFractionRender: null,
	            paginationCustomRender: null,
	            paginationType: 'bullets', // 'bullets' or 'progress' or 'fraction' or 'custom'
	            // Resistance
	            resistance: true,
	            resistanceRatio: 0.85,
	            // Next/prev buttons
	            nextButton: null,
	            prevButton: null,
	            // Progress
	            watchSlidesProgress: false,
	            watchSlidesVisibility: false,
	            // Cursor
	            grabCursor: false,
	            // Clicks
	            preventClicks: true,
	            preventClicksPropagation: true,
	            slideToClickedSlide: false,
	            // Lazy Loading
	            lazyLoading: false,
	            lazyLoadingInPrevNext: false,
	            lazyLoadingInPrevNextAmount: 1,
	            lazyLoadingOnTransitionStart: false,
	            // Images
	            preloadImages: true,
	            updateOnImagesReady: true,
	            // loop
	            loop: false,
	            loopAdditionalSlides: 0,
	            loopedSlides: null,
	            // Control
	            control: undefined,
	            controlInverse: false,
	            controlBy: 'slide', //or 'container'
	            normalizeSlideIndex: true,
	            // Swiping/no swiping
	            allowSwipeToPrev: true,
	            allowSwipeToNext: true,
	            swipeHandler: null, //'.swipe-handler',
	            noSwiping: true,
	            noSwipingClass: 'swiper-no-swiping',
	            // Passive Listeners
	            passiveListeners: true,
	            // NS
	            containerModifierClass: 'swiper-container-', // NEW
	            slideClass: 'swiper-slide',
	            slideActiveClass: 'swiper-slide-active',
	            slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
	            slideVisibleClass: 'swiper-slide-visible',
	            slideDuplicateClass: 'swiper-slide-duplicate',
	            slideNextClass: 'swiper-slide-next',
	            slideDuplicateNextClass: 'swiper-slide-duplicate-next',
	            slidePrevClass: 'swiper-slide-prev',
	            slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
	            wrapperClass: 'swiper-wrapper',
	            bulletClass: 'swiper-pagination-bullet',
	            bulletActiveClass: 'swiper-pagination-bullet-active',
	            buttonDisabledClass: 'swiper-button-disabled',
	            paginationCurrentClass: 'swiper-pagination-current',
	            paginationTotalClass: 'swiper-pagination-total',
	            paginationHiddenClass: 'swiper-pagination-hidden',
	            paginationProgressbarClass: 'swiper-pagination-progressbar',
	            paginationClickableClass: 'swiper-pagination-clickable', // NEW
	            paginationModifierClass: 'swiper-pagination-', // NEW
	            lazyLoadingClass: 'swiper-lazy',
	            lazyStatusLoadingClass: 'swiper-lazy-loading',
	            lazyStatusLoadedClass: 'swiper-lazy-loaded',
	            lazyPreloaderClass: 'swiper-lazy-preloader',
	            notificationClass: 'swiper-notification',
	            preloaderClass: 'preloader',
	            zoomContainerClass: 'swiper-zoom-container',
	
	            // Observer
	            observer: false,
	            observeParents: false,
	            // Accessibility
	            a11y: false,
	            prevSlideMessage: 'Previous slide',
	            nextSlideMessage: 'Next slide',
	            firstSlideMessage: 'This is the first slide',
	            lastSlideMessage: 'This is the last slide',
	            paginationBulletMessage: 'Go to slide {{index}}',
	            // Callbacks
	            runCallbacksOnInit: true
	            /*
	            Callbacks:
	            onInit: function (swiper)
	            onDestroy: function (swiper)
	            onBeforeResize: function (swiper)
	            onAfterResize: function (swiper)
	            onClick: function (swiper, e)
	            onTap: function (swiper, e)
	            onDoubleTap: function (swiper, e)
	            onSliderMove: function (swiper, e)
	            onSlideChangeStart: function (swiper)
	            onSlideChangeEnd: function (swiper)
	            onTransitionStart: function (swiper)
	            onTransitionEnd: function (swiper)
	            onImagesReady: function (swiper)
	            onProgress: function (swiper, progress)
	            onTouchStart: function (swiper, e)
	            onTouchMove: function (swiper, e)
	            onTouchMoveOpposite: function (swiper, e)
	            onTouchEnd: function (swiper, e)
	            onReachBeginning: function (swiper)
	            onReachEnd: function (swiper)
	            onSetTransition: function (swiper, duration)
	            onSetTranslate: function (swiper, translate)
	            onAutoplayStart: function (swiper)
	            onAutoplayStop: function (swiper),
	            onLazyImageLoad: function (swiper, slide, image)
	            onLazyImageReady: function (swiper, slide, image)
	            onKeyPress: function (swiper, keyCode)
	            */
	
	        };
	        var initialVirtualTranslate = params && params.virtualTranslate;
	
	        params = params || {};
	        var originalParams = {};
	        for (var param in params) {
	            if (_typeof(params[param]) === 'object' && params[param] !== null && !(params[param].nodeType || params[param] === window || params[param] === document || typeof Dom7 !== 'undefined' && params[param] instanceof Dom7 || typeof jQuery !== 'undefined' && params[param] instanceof jQuery)) {
	                originalParams[param] = {};
	                for (var deepParam in params[param]) {
	                    originalParams[param][deepParam] = params[param][deepParam];
	                }
	            } else {
	                originalParams[param] = params[param];
	            }
	        }
	        for (var def in defaults) {
	            if (typeof params[def] === 'undefined') {
	                params[def] = defaults[def];
	            } else if (_typeof(params[def]) === 'object') {
	                for (var deepDef in defaults[def]) {
	                    if (typeof params[def][deepDef] === 'undefined') {
	                        params[def][deepDef] = defaults[def][deepDef];
	                    }
	                }
	            }
	        }
	
	        // Swiper
	        var s = this;
	
	        // Params
	        s.params = params;
	        s.originalParams = originalParams;
	
	        // Classname
	        s.classNames = [];
	        /*=========================
	          Dom Library and plugins
	          ===========================*/
	        if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined') {
	            $ = Dom7;
	        }
	        if (typeof $ === 'undefined') {
	            if (typeof Dom7 === 'undefined') {
	                $ = window.Dom7 || window.Zepto || __webpack_provided_window_dot_jQuery;
	            } else {
	                $ = Dom7;
	            }
	            if (!$) return;
	        }
	        // Export it to Swiper instance
	        s.$ = $;
	
	        /*=========================
	          Breakpoints
	          ===========================*/
	        s.currentBreakpoint = undefined;
	        s.getActiveBreakpoint = function () {
	            //Get breakpoint for window width
	            if (!s.params.breakpoints) return false;
	            var breakpoint = false;
	            var points = [],
	                point;
	            for (point in s.params.breakpoints) {
	                if (s.params.breakpoints.hasOwnProperty(point)) {
	                    points.push(point);
	                }
	            }
	            points.sort(function (a, b) {
	                return parseInt(a, 10) > parseInt(b, 10);
	            });
	            for (var i = 0; i < points.length; i++) {
	                point = points[i];
	                if (point >= window.innerWidth && !breakpoint) {
	                    breakpoint = point;
	                }
	            }
	            return breakpoint || 'max';
	        };
	        s.setBreakpoint = function () {
	            //Set breakpoint for window width and update parameters
	            var breakpoint = s.getActiveBreakpoint();
	            if (breakpoint && s.currentBreakpoint !== breakpoint) {
	                var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
	                var needsReLoop = s.params.loop && breakPointsParams.slidesPerView !== s.params.slidesPerView;
	                for (var param in breakPointsParams) {
	                    s.params[param] = breakPointsParams[param];
	                }
	                s.currentBreakpoint = breakpoint;
	                if (needsReLoop && s.destroyLoop) {
	                    s.reLoop(true);
	                }
	            }
	        };
	        // Set breakpoint on load
	        if (s.params.breakpoints) {
	            s.setBreakpoint();
	        }
	
	        /*=========================
	          Preparation - Define Container, Wrapper and Pagination
	          ===========================*/
	        s.container = $(container);
	        if (s.container.length === 0) return;
	        if (s.container.length > 1) {
	            var swipers = [];
	            s.container.each(function () {
	                var container = this;
	                swipers.push(new Swiper(this, params));
	            });
	            return swipers;
	        }
	
	        // Save instance in container HTML Element and in data
	        s.container[0].swiper = s;
	        s.container.data('swiper', s);
	
	        s.classNames.push(s.params.containerModifierClass + s.params.direction);
	
	        if (s.params.freeMode) {
	            s.classNames.push(s.params.containerModifierClass + 'free-mode');
	        }
	        if (!s.support.flexbox) {
	            s.classNames.push(s.params.containerModifierClass + 'no-flexbox');
	            s.params.slidesPerColumn = 1;
	        }
	        if (s.params.autoHeight) {
	            s.classNames.push(s.params.containerModifierClass + 'autoheight');
	        }
	        // Enable slides progress when required
	        if (s.params.parallax || s.params.watchSlidesVisibility) {
	            s.params.watchSlidesProgress = true;
	        }
	        // Max resistance when touchReleaseOnEdges
	        if (s.params.touchReleaseOnEdges) {
	            s.params.resistanceRatio = 0;
	        }
	        // Coverflow / 3D
	        if (['cube', 'coverflow', 'flip'].indexOf(s.params.effect) >= 0) {
	            if (s.support.transforms3d) {
	                s.params.watchSlidesProgress = true;
	                s.classNames.push(s.params.containerModifierClass + '3d');
	            } else {
	                s.params.effect = 'slide';
	            }
	        }
	        if (s.params.effect !== 'slide') {
	            s.classNames.push(s.params.containerModifierClass + s.params.effect);
	        }
	        if (s.params.effect === 'cube') {
	            s.params.resistanceRatio = 0;
	            s.params.slidesPerView = 1;
	            s.params.slidesPerColumn = 1;
	            s.params.slidesPerGroup = 1;
	            s.params.centeredSlides = false;
	            s.params.spaceBetween = 0;
	            s.params.virtualTranslate = true;
	        }
	        if (s.params.effect === 'fade' || s.params.effect === 'flip') {
	            s.params.slidesPerView = 1;
	            s.params.slidesPerColumn = 1;
	            s.params.slidesPerGroup = 1;
	            s.params.watchSlidesProgress = true;
	            s.params.spaceBetween = 0;
	            if (typeof initialVirtualTranslate === 'undefined') {
	                s.params.virtualTranslate = true;
	            }
	        }
	
	        // Grab Cursor
	        if (s.params.grabCursor && s.support.touch) {
	            s.params.grabCursor = false;
	        }
	
	        // Wrapper
	        s.wrapper = s.container.children('.' + s.params.wrapperClass);
	
	        // Pagination
	        if (s.params.pagination) {
	            s.paginationContainer = $(s.params.pagination);
	            if (s.params.uniqueNavElements && typeof s.params.pagination === 'string' && s.paginationContainer.length > 1 && s.container.find(s.params.pagination).length === 1) {
	                s.paginationContainer = s.container.find(s.params.pagination);
	            }
	
	            if (s.params.paginationType === 'bullets' && s.params.paginationClickable) {
	                s.paginationContainer.addClass(s.params.paginationModifierClass + 'clickable');
	            } else {
	                s.params.paginationClickable = false;
	            }
	            s.paginationContainer.addClass(s.params.paginationModifierClass + s.params.paginationType);
	        }
	        // Next/Prev Buttons
	        if (s.params.nextButton || s.params.prevButton) {
	            if (s.params.nextButton) {
	                s.nextButton = $(s.params.nextButton);
	                if (s.params.uniqueNavElements && typeof s.params.nextButton === 'string' && s.nextButton.length > 1 && s.container.find(s.params.nextButton).length === 1) {
	                    s.nextButton = s.container.find(s.params.nextButton);
	                }
	            }
	            if (s.params.prevButton) {
	                s.prevButton = $(s.params.prevButton);
	                if (s.params.uniqueNavElements && typeof s.params.prevButton === 'string' && s.prevButton.length > 1 && s.container.find(s.params.prevButton).length === 1) {
	                    s.prevButton = s.container.find(s.params.prevButton);
	                }
	            }
	        }
	
	        // Is Horizontal
	        s.isHorizontal = function () {
	            return s.params.direction === 'horizontal';
	        };
	        // s.isH = isH;
	
	        // RTL
	        s.rtl = s.isHorizontal() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
	        if (s.rtl) {
	            s.classNames.push(s.params.containerModifierClass + 'rtl');
	        }
	
	        // Wrong RTL support
	        if (s.rtl) {
	            s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
	        }
	
	        // Columns
	        if (s.params.slidesPerColumn > 1) {
	            s.classNames.push(s.params.containerModifierClass + 'multirow');
	        }
	
	        // Check for Android
	        if (s.device.android) {
	            s.classNames.push(s.params.containerModifierClass + 'android');
	        }
	
	        // Add classes
	        s.container.addClass(s.classNames.join(' '));
	
	        // Translate
	        s.translate = 0;
	
	        // Progress
	        s.progress = 0;
	
	        // Velocity
	        s.velocity = 0;
	
	        /*=========================
	          Locks, unlocks
	          ===========================*/
	        s.lockSwipeToNext = function () {
	            s.params.allowSwipeToNext = false;
	            if (s.params.allowSwipeToPrev === false && s.params.grabCursor) {
	                s.unsetGrabCursor();
	            }
	        };
	        s.lockSwipeToPrev = function () {
	            s.params.allowSwipeToPrev = false;
	            if (s.params.allowSwipeToNext === false && s.params.grabCursor) {
	                s.unsetGrabCursor();
	            }
	        };
	        s.lockSwipes = function () {
	            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
	            if (s.params.grabCursor) s.unsetGrabCursor();
	        };
	        s.unlockSwipeToNext = function () {
	            s.params.allowSwipeToNext = true;
	            if (s.params.allowSwipeToPrev === true && s.params.grabCursor) {
	                s.setGrabCursor();
	            }
	        };
	        s.unlockSwipeToPrev = function () {
	            s.params.allowSwipeToPrev = true;
	            if (s.params.allowSwipeToNext === true && s.params.grabCursor) {
	                s.setGrabCursor();
	            }
	        };
	        s.unlockSwipes = function () {
	            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
	            if (s.params.grabCursor) s.setGrabCursor();
	        };
	
	        /*=========================
	          Round helper
	          ===========================*/
	        function round(a) {
	            return Math.floor(a);
	        }
	        /*=========================
	          Set grab cursor
	          ===========================*/
	        s.setGrabCursor = function (moving) {
	            s.container[0].style.cursor = 'move';
	            s.container[0].style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
	            s.container[0].style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
	            s.container[0].style.cursor = moving ? 'grabbing' : 'grab';
	        };
	        s.unsetGrabCursor = function () {
	            s.container[0].style.cursor = '';
	        };
	        if (s.params.grabCursor) {
	            s.setGrabCursor();
	        }
	        /*=========================
	          Update on Images Ready
	          ===========================*/
	        s.imagesToLoad = [];
	        s.imagesLoaded = 0;
	
	        s.loadImage = function (imgElement, src, srcset, sizes, checkForComplete, callback) {
	            var image;
	            function onReady() {
	                if (callback) callback();
	            }
	            if (!imgElement.complete || !checkForComplete) {
	                if (src) {
	                    image = new window.Image();
	                    image.onload = onReady;
	                    image.onerror = onReady;
	                    if (sizes) {
	                        image.sizes = sizes;
	                    }
	                    if (srcset) {
	                        image.srcset = srcset;
	                    }
	                    if (src) {
	                        image.src = src;
	                    }
	                } else {
	                    onReady();
	                }
	            } else {
	                //image already loaded...
	                onReady();
	            }
	        };
	        s.preloadImages = function () {
	            s.imagesToLoad = s.container.find('img');
	            function _onReady() {
	                if (typeof s === 'undefined' || s === null || !s) return;
	                if (s.imagesLoaded !== undefined) s.imagesLoaded++;
	                if (s.imagesLoaded === s.imagesToLoad.length) {
	                    if (s.params.updateOnImagesReady) s.update();
	                    s.emit('onImagesReady', s);
	                }
	            }
	            for (var i = 0; i < s.imagesToLoad.length; i++) {
	                s.loadImage(s.imagesToLoad[i], s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src'), s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset'), s.imagesToLoad[i].sizes || s.imagesToLoad[i].getAttribute('sizes'), true, _onReady);
	            }
	        };
	
	        /*=========================
	          Autoplay
	          ===========================*/
	        s.autoplayTimeoutId = undefined;
	        s.autoplaying = false;
	        s.autoplayPaused = false;
	        function autoplay() {
	            var autoplayDelay = s.params.autoplay;
	            var activeSlide = s.slides.eq(s.activeIndex);
	            if (activeSlide.attr('data-swiper-autoplay')) {
	                autoplayDelay = activeSlide.attr('data-swiper-autoplay') || s.params.autoplay;
	            }
	            s.autoplayTimeoutId = setTimeout(function () {
	                if (s.params.loop) {
	                    s.fixLoop();
	                    s._slideNext();
	                    s.emit('onAutoplay', s);
	                } else {
	                    if (!s.isEnd) {
	                        s._slideNext();
	                        s.emit('onAutoplay', s);
	                    } else {
	                        if (!params.autoplayStopOnLast) {
	                            s._slideTo(0);
	                            s.emit('onAutoplay', s);
	                        } else {
	                            s.stopAutoplay();
	                        }
	                    }
	                }
	            }, autoplayDelay);
	        }
	        s.startAutoplay = function () {
	            if (typeof s.autoplayTimeoutId !== 'undefined') return false;
	            if (!s.params.autoplay) return false;
	            if (s.autoplaying) return false;
	            s.autoplaying = true;
	            s.emit('onAutoplayStart', s);
	            autoplay();
	        };
	        s.stopAutoplay = function (internal) {
	            if (!s.autoplayTimeoutId) return;
	            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
	            s.autoplaying = false;
	            s.autoplayTimeoutId = undefined;
	            s.emit('onAutoplayStop', s);
	        };
	        s.pauseAutoplay = function (speed) {
	            if (s.autoplayPaused) return;
	            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
	            s.autoplayPaused = true;
	            if (speed === 0) {
	                s.autoplayPaused = false;
	                autoplay();
	            } else {
	                s.wrapper.transitionEnd(function () {
	                    if (!s) return;
	                    s.autoplayPaused = false;
	                    if (!s.autoplaying) {
	                        s.stopAutoplay();
	                    } else {
	                        autoplay();
	                    }
	                });
	            }
	        };
	        /*=========================
	          Min/Max Translate
	          ===========================*/
	        s.minTranslate = function () {
	            return -s.snapGrid[0];
	        };
	        s.maxTranslate = function () {
	            return -s.snapGrid[s.snapGrid.length - 1];
	        };
	        /*=========================
	          Slider/slides sizes
	          ===========================*/
	        s.updateAutoHeight = function () {
	            var activeSlides = [];
	            var newHeight = 0;
	            var i;
	
	            // Find slides currently in view
	            if (s.params.slidesPerView !== 'auto' && s.params.slidesPerView > 1) {
	                for (i = 0; i < Math.ceil(s.params.slidesPerView); i++) {
	                    var index = s.activeIndex + i;
	                    if (index > s.slides.length) break;
	                    activeSlides.push(s.slides.eq(index)[0]);
	                }
	            } else {
	                activeSlides.push(s.slides.eq(s.activeIndex)[0]);
	            }
	
	            // Find new height from heighest slide in view
	            for (i = 0; i < activeSlides.length; i++) {
	                if (typeof activeSlides[i] !== 'undefined') {
	                    var height = activeSlides[i].offsetHeight;
	                    newHeight = height > newHeight ? height : newHeight;
	                }
	            }
	
	            // Update Height
	            if (newHeight) s.wrapper.css('height', newHeight + 'px');
	        };
	        s.updateContainerSize = function () {
	            var width, height;
	            if (typeof s.params.width !== 'undefined') {
	                width = s.params.width;
	            } else {
	                width = s.container[0].clientWidth;
	            }
	            if (typeof s.params.height !== 'undefined') {
	                height = s.params.height;
	            } else {
	                height = s.container[0].clientHeight;
	            }
	            if (width === 0 && s.isHorizontal() || height === 0 && !s.isHorizontal()) {
	                return;
	            }
	
	            //Subtract paddings
	            width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
	            height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);
	
	            // Store values
	            s.width = width;
	            s.height = height;
	            s.size = s.isHorizontal() ? s.width : s.height;
	        };
	
	        s.updateSlidesSize = function () {
	            s.slides = s.wrapper.children('.' + s.params.slideClass);
	            s.snapGrid = [];
	            s.slidesGrid = [];
	            s.slidesSizesGrid = [];
	
	            var spaceBetween = s.params.spaceBetween,
	                slidePosition = -s.params.slidesOffsetBefore,
	                i,
	                prevSlideSize = 0,
	                index = 0;
	            if (typeof s.size === 'undefined') return;
	            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	                spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
	            }
	
	            s.virtualSize = -spaceBetween;
	            // reset margins
	            if (s.rtl) s.slides.css({ marginLeft: '', marginTop: '' });else s.slides.css({ marginRight: '', marginBottom: '' });
	
	            var slidesNumberEvenToRows;
	            if (s.params.slidesPerColumn > 1) {
	                if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
	                    slidesNumberEvenToRows = s.slides.length;
	                } else {
	                    slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
	                }
	                if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
	                    slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
	                }
	            }
	
	            // Calc slides
	            var slideSize;
	            var slidesPerColumn = s.params.slidesPerColumn;
	            var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
	            var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
	            for (i = 0; i < s.slides.length; i++) {
	                slideSize = 0;
	                var slide = s.slides.eq(i);
	                if (s.params.slidesPerColumn > 1) {
	                    // Set slides order
	                    var newSlideOrderIndex;
	                    var column, row;
	                    if (s.params.slidesPerColumnFill === 'column') {
	                        column = Math.floor(i / slidesPerColumn);
	                        row = i - column * slidesPerColumn;
	                        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
	                            if (++row >= slidesPerColumn) {
	                                row = 0;
	                                column++;
	                            }
	                        }
	                        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
	                        slide.css({
	                            '-webkit-box-ordinal-group': newSlideOrderIndex,
	                            '-moz-box-ordinal-group': newSlideOrderIndex,
	                            '-ms-flex-order': newSlideOrderIndex,
	                            '-webkit-order': newSlideOrderIndex,
	                            'order': newSlideOrderIndex
	                        });
	                    } else {
	                        row = Math.floor(i / slidesPerRow);
	                        column = i - row * slidesPerRow;
	                    }
	                    slide.css('margin-' + (s.isHorizontal() ? 'top' : 'left'), row !== 0 && s.params.spaceBetween && s.params.spaceBetween + 'px').attr('data-swiper-column', column).attr('data-swiper-row', row);
	                }
	                if (slide.css('display') === 'none') continue;
	                if (s.params.slidesPerView === 'auto') {
	                    slideSize = s.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
	                    if (s.params.roundLengths) slideSize = round(slideSize);
	                } else {
	                    slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
	                    if (s.params.roundLengths) slideSize = round(slideSize);
	
	                    if (s.isHorizontal()) {
	                        s.slides[i].style.width = slideSize + 'px';
	                    } else {
	                        s.slides[i].style.height = slideSize + 'px';
	                    }
	                }
	                s.slides[i].swiperSlideSize = slideSize;
	                s.slidesSizesGrid.push(slideSize);
	
	                if (s.params.centeredSlides) {
	                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
	                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
	                    if (i === 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
	                    if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
	                    if (index % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
	                    s.slidesGrid.push(slidePosition);
	                } else {
	                    if (index % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
	                    s.slidesGrid.push(slidePosition);
	                    slidePosition = slidePosition + slideSize + spaceBetween;
	                }
	
	                s.virtualSize += slideSize + spaceBetween;
	
	                prevSlideSize = slideSize;
	
	                index++;
	            }
	            s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
	            var newSlidesGrid;
	
	            if (s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
	                s.wrapper.css({ width: s.virtualSize + s.params.spaceBetween + 'px' });
	            }
	            if (!s.support.flexbox || s.params.setWrapperSize) {
	                if (s.isHorizontal()) s.wrapper.css({ width: s.virtualSize + s.params.spaceBetween + 'px' });else s.wrapper.css({ height: s.virtualSize + s.params.spaceBetween + 'px' });
	            }
	
	            if (s.params.slidesPerColumn > 1) {
	                s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
	                s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
	                if (s.isHorizontal()) s.wrapper.css({ width: s.virtualSize + s.params.spaceBetween + 'px' });else s.wrapper.css({ height: s.virtualSize + s.params.spaceBetween + 'px' });
	                if (s.params.centeredSlides) {
	                    newSlidesGrid = [];
	                    for (i = 0; i < s.snapGrid.length; i++) {
	                        if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0]) newSlidesGrid.push(s.snapGrid[i]);
	                    }
	                    s.snapGrid = newSlidesGrid;
	                }
	            }
	
	            // Remove last grid elements depending on width
	            if (!s.params.centeredSlides) {
	                newSlidesGrid = [];
	                for (i = 0; i < s.snapGrid.length; i++) {
	                    if (s.snapGrid[i] <= s.virtualSize - s.size) {
	                        newSlidesGrid.push(s.snapGrid[i]);
	                    }
	                }
	                s.snapGrid = newSlidesGrid;
	                if (Math.floor(s.virtualSize - s.size) - Math.floor(s.snapGrid[s.snapGrid.length - 1]) > 1) {
	                    s.snapGrid.push(s.virtualSize - s.size);
	                }
	            }
	            if (s.snapGrid.length === 0) s.snapGrid = [0];
	
	            if (s.params.spaceBetween !== 0) {
	                if (s.isHorizontal()) {
	                    if (s.rtl) s.slides.css({ marginLeft: spaceBetween + 'px' });else s.slides.css({ marginRight: spaceBetween + 'px' });
	                } else s.slides.css({ marginBottom: spaceBetween + 'px' });
	            }
	            if (s.params.watchSlidesProgress) {
	                s.updateSlidesOffset();
	            }
	        };
	        s.updateSlidesOffset = function () {
	            for (var i = 0; i < s.slides.length; i++) {
	                s.slides[i].swiperSlideOffset = s.isHorizontal() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
	            }
	        };
	
	        /*=========================
	          Dynamic Slides Per View
	          ===========================*/
	        s.currentSlidesPerView = function () {
	            var spv = 1,
	                i,
	                j;
	            if (s.params.centeredSlides) {
	                var size = s.slides[s.activeIndex].swiperSlideSize;
	                var breakLoop;
	                for (i = s.activeIndex + 1; i < s.slides.length; i++) {
	                    if (s.slides[i] && !breakLoop) {
	                        size += s.slides[i].swiperSlideSize;
	                        spv++;
	                        if (size > s.size) breakLoop = true;
	                    }
	                }
	                for (j = s.activeIndex - 1; j >= 0; j--) {
	                    if (s.slides[j] && !breakLoop) {
	                        size += s.slides[j].swiperSlideSize;
	                        spv++;
	                        if (size > s.size) breakLoop = true;
	                    }
	                }
	            } else {
	                for (i = s.activeIndex + 1; i < s.slides.length; i++) {
	                    if (s.slidesGrid[i] - s.slidesGrid[s.activeIndex] < s.size) {
	                        spv++;
	                    }
	                }
	            }
	            return spv;
	        };
	        /*=========================
	          Slider/slides progress
	          ===========================*/
	        s.updateSlidesProgress = function (translate) {
	            if (typeof translate === 'undefined') {
	                translate = s.translate || 0;
	            }
	            if (s.slides.length === 0) return;
	            if (typeof s.slides[0].swiperSlideOffset === 'undefined') s.updateSlidesOffset();
	
	            var offsetCenter = -translate;
	            if (s.rtl) offsetCenter = translate;
	
	            // Visible Slides
	            s.slides.removeClass(s.params.slideVisibleClass);
	            for (var i = 0; i < s.slides.length; i++) {
	                var slide = s.slides[i];
	                var slideProgress = (offsetCenter + (s.params.centeredSlides ? s.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
	                if (s.params.watchSlidesVisibility) {
	                    var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
	                    var slideAfter = slideBefore + s.slidesSizesGrid[i];
	                    var isVisible = slideBefore >= 0 && slideBefore < s.size || slideAfter > 0 && slideAfter <= s.size || slideBefore <= 0 && slideAfter >= s.size;
	                    if (isVisible) {
	                        s.slides.eq(i).addClass(s.params.slideVisibleClass);
	                    }
	                }
	                slide.progress = s.rtl ? -slideProgress : slideProgress;
	            }
	        };
	        s.updateProgress = function (translate) {
	            if (typeof translate === 'undefined') {
	                translate = s.translate || 0;
	            }
	            var translatesDiff = s.maxTranslate() - s.minTranslate();
	            var wasBeginning = s.isBeginning;
	            var wasEnd = s.isEnd;
	            if (translatesDiff === 0) {
	                s.progress = 0;
	                s.isBeginning = s.isEnd = true;
	            } else {
	                s.progress = (translate - s.minTranslate()) / translatesDiff;
	                s.isBeginning = s.progress <= 0;
	                s.isEnd = s.progress >= 1;
	            }
	            if (s.isBeginning && !wasBeginning) s.emit('onReachBeginning', s);
	            if (s.isEnd && !wasEnd) s.emit('onReachEnd', s);
	
	            if (s.params.watchSlidesProgress) s.updateSlidesProgress(translate);
	            s.emit('onProgress', s, s.progress);
	        };
	        s.updateActiveIndex = function () {
	            var translate = s.rtl ? s.translate : -s.translate;
	            var newActiveIndex, i, snapIndex;
	            for (i = 0; i < s.slidesGrid.length; i++) {
	                if (typeof s.slidesGrid[i + 1] !== 'undefined') {
	                    if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
	                        newActiveIndex = i;
	                    } else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
	                        newActiveIndex = i + 1;
	                    }
	                } else {
	                    if (translate >= s.slidesGrid[i]) {
	                        newActiveIndex = i;
	                    }
	                }
	            }
	            // Normalize slideIndex
	            if (s.params.normalizeSlideIndex) {
	                if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined') newActiveIndex = 0;
	            }
	            // for (i = 0; i < s.slidesGrid.length; i++) {
	            // if (- translate >= s.slidesGrid[i]) {
	            // newActiveIndex = i;
	            // }
	            // }
	            snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
	            if (snapIndex >= s.snapGrid.length) snapIndex = s.snapGrid.length - 1;
	
	            if (newActiveIndex === s.activeIndex) {
	                return;
	            }
	            s.snapIndex = snapIndex;
	            s.previousIndex = s.activeIndex;
	            s.activeIndex = newActiveIndex;
	            s.updateClasses();
	            s.updateRealIndex();
	        };
	        s.updateRealIndex = function () {
	            s.realIndex = parseInt(s.slides.eq(s.activeIndex).attr('data-swiper-slide-index') || s.activeIndex, 10);
	        };
	
	        /*=========================
	          Classes
	          ===========================*/
	        s.updateClasses = function () {
	            s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass + ' ' + s.params.slideDuplicateActiveClass + ' ' + s.params.slideDuplicateNextClass + ' ' + s.params.slideDuplicatePrevClass);
	            var activeSlide = s.slides.eq(s.activeIndex);
	            // Active classes
	            activeSlide.addClass(s.params.slideActiveClass);
	            if (params.loop) {
	                // Duplicate to all looped slides
	                if (activeSlide.hasClass(s.params.slideDuplicateClass)) {
	                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
	                } else {
	                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
	                }
	            }
	            // Next Slide
	            var nextSlide = activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
	            if (s.params.loop && nextSlide.length === 0) {
	                nextSlide = s.slides.eq(0);
	                nextSlide.addClass(s.params.slideNextClass);
	            }
	            // Prev Slide
	            var prevSlide = activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
	            if (s.params.loop && prevSlide.length === 0) {
	                prevSlide = s.slides.eq(-1);
	                prevSlide.addClass(s.params.slidePrevClass);
	            }
	            if (params.loop) {
	                // Duplicate to all looped slides
	                if (nextSlide.hasClass(s.params.slideDuplicateClass)) {
	                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
	                } else {
	                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
	                }
	                if (prevSlide.hasClass(s.params.slideDuplicateClass)) {
	                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
	                } else {
	                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
	                }
	            }
	
	            // Pagination
	            if (s.paginationContainer && s.paginationContainer.length > 0) {
	                // Current/Total
	                var current,
	                    total = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
	                if (s.params.loop) {
	                    current = Math.ceil((s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup);
	                    if (current > s.slides.length - 1 - s.loopedSlides * 2) {
	                        current = current - (s.slides.length - s.loopedSlides * 2);
	                    }
	                    if (current > total - 1) current = current - total;
	                    if (current < 0 && s.params.paginationType !== 'bullets') current = total + current;
	                } else {
	                    if (typeof s.snapIndex !== 'undefined') {
	                        current = s.snapIndex;
	                    } else {
	                        current = s.activeIndex || 0;
	                    }
	                }
	                // Types
	                if (s.params.paginationType === 'bullets' && s.bullets && s.bullets.length > 0) {
	                    s.bullets.removeClass(s.params.bulletActiveClass);
	                    if (s.paginationContainer.length > 1) {
	                        s.bullets.each(function () {
	                            if ($(this).index() === current) $(this).addClass(s.params.bulletActiveClass);
	                        });
	                    } else {
	                        s.bullets.eq(current).addClass(s.params.bulletActiveClass);
	                    }
	                }
	                if (s.params.paginationType === 'fraction') {
	                    s.paginationContainer.find('.' + s.params.paginationCurrentClass).text(current + 1);
	                    s.paginationContainer.find('.' + s.params.paginationTotalClass).text(total);
	                }
	                if (s.params.paginationType === 'progress') {
	                    var scale = (current + 1) / total,
	                        scaleX = scale,
	                        scaleY = 1;
	                    if (!s.isHorizontal()) {
	                        scaleY = scale;
	                        scaleX = 1;
	                    }
	                    s.paginationContainer.find('.' + s.params.paginationProgressbarClass).transform('translate3d(0,0,0) scaleX(' + scaleX + ') scaleY(' + scaleY + ')').transition(s.params.speed);
	                }
	                if (s.params.paginationType === 'custom' && s.params.paginationCustomRender) {
	                    s.paginationContainer.html(s.params.paginationCustomRender(s, current + 1, total));
	                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
	                }
	            }
	
	            // Next/active buttons
	            if (!s.params.loop) {
	                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
	                    if (s.isBeginning) {
	                        s.prevButton.addClass(s.params.buttonDisabledClass);
	                        if (s.params.a11y && s.a11y) s.a11y.disable(s.prevButton);
	                    } else {
	                        s.prevButton.removeClass(s.params.buttonDisabledClass);
	                        if (s.params.a11y && s.a11y) s.a11y.enable(s.prevButton);
	                    }
	                }
	                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
	                    if (s.isEnd) {
	                        s.nextButton.addClass(s.params.buttonDisabledClass);
	                        if (s.params.a11y && s.a11y) s.a11y.disable(s.nextButton);
	                    } else {
	                        s.nextButton.removeClass(s.params.buttonDisabledClass);
	                        if (s.params.a11y && s.a11y) s.a11y.enable(s.nextButton);
	                    }
	                }
	            }
	        };
	
	        /*=========================
	          Pagination
	          ===========================*/
	        s.updatePagination = function () {
	            if (!s.params.pagination) return;
	            if (s.paginationContainer && s.paginationContainer.length > 0) {
	                var paginationHTML = '';
	                if (s.params.paginationType === 'bullets') {
	                    var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
	                    for (var i = 0; i < numberOfBullets; i++) {
	                        if (s.params.paginationBulletRender) {
	                            paginationHTML += s.params.paginationBulletRender(s, i, s.params.bulletClass);
	                        } else {
	                            paginationHTML += '<' + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
	                        }
	                    }
	                    s.paginationContainer.html(paginationHTML);
	                    s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
	                    if (s.params.paginationClickable && s.params.a11y && s.a11y) {
	                        s.a11y.initPagination();
	                    }
	                }
	                if (s.params.paginationType === 'fraction') {
	                    if (s.params.paginationFractionRender) {
	                        paginationHTML = s.params.paginationFractionRender(s, s.params.paginationCurrentClass, s.params.paginationTotalClass);
	                    } else {
	                        paginationHTML = '<span class="' + s.params.paginationCurrentClass + '"></span>' + ' / ' + '<span class="' + s.params.paginationTotalClass + '"></span>';
	                    }
	                    s.paginationContainer.html(paginationHTML);
	                }
	                if (s.params.paginationType === 'progress') {
	                    if (s.params.paginationProgressRender) {
	                        paginationHTML = s.params.paginationProgressRender(s, s.params.paginationProgressbarClass);
	                    } else {
	                        paginationHTML = '<span class="' + s.params.paginationProgressbarClass + '"></span>';
	                    }
	                    s.paginationContainer.html(paginationHTML);
	                }
	                if (s.params.paginationType !== 'custom') {
	                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
	                }
	            }
	        };
	        /*=========================
	          Common update method
	          ===========================*/
	        s.update = function (updateTranslate) {
	            if (!s) return;
	            s.updateContainerSize();
	            s.updateSlidesSize();
	            s.updateProgress();
	            s.updatePagination();
	            s.updateClasses();
	            if (s.params.scrollbar && s.scrollbar) {
	                s.scrollbar.set();
	            }
	            var newTranslate;
	            function forceSetTranslate() {
	                var translate = s.rtl ? -s.translate : s.translate;
	                newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
	                s.setWrapperTranslate(newTranslate);
	                s.updateActiveIndex();
	                s.updateClasses();
	            }
	            if (updateTranslate) {
	                var translated;
	                if (s.controller && s.controller.spline) {
	                    s.controller.spline = undefined;
	                }
	                if (s.params.freeMode) {
	                    forceSetTranslate();
	                    if (s.params.autoHeight) {
	                        s.updateAutoHeight();
	                    }
	                } else {
	                    if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
	                        translated = s.slideTo(s.slides.length - 1, 0, false, true);
	                    } else {
	                        translated = s.slideTo(s.activeIndex, 0, false, true);
	                    }
	                    if (!translated) {
	                        forceSetTranslate();
	                    }
	                }
	            } else if (s.params.autoHeight) {
	                s.updateAutoHeight();
	            }
	        };
	
	        /*=========================
	          Resize Handler
	          ===========================*/
	        s.onResize = function (forceUpdatePagination) {
	            if (s.params.onBeforeResize) s.params.onBeforeResize(s);
	            //Breakpoints
	            if (s.params.breakpoints) {
	                s.setBreakpoint();
	            }
	
	            // Disable locks on resize
	            var allowSwipeToPrev = s.params.allowSwipeToPrev;
	            var allowSwipeToNext = s.params.allowSwipeToNext;
	            s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;
	
	            s.updateContainerSize();
	            s.updateSlidesSize();
	            if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination) s.updatePagination();
	            if (s.params.scrollbar && s.scrollbar) {
	                s.scrollbar.set();
	            }
	            if (s.controller && s.controller.spline) {
	                s.controller.spline = undefined;
	            }
	            var slideChangedBySlideTo = false;
	            if (s.params.freeMode) {
	                var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
	                s.setWrapperTranslate(newTranslate);
	                s.updateActiveIndex();
	                s.updateClasses();
	
	                if (s.params.autoHeight) {
	                    s.updateAutoHeight();
	                }
	            } else {
	                s.updateClasses();
	                if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
	                    slideChangedBySlideTo = s.slideTo(s.slides.length - 1, 0, false, true);
	                } else {
	                    slideChangedBySlideTo = s.slideTo(s.activeIndex, 0, false, true);
	                }
	            }
	            if (s.params.lazyLoading && !slideChangedBySlideTo && s.lazy) {
	                s.lazy.load();
	            }
	            // Return locks after resize
	            s.params.allowSwipeToPrev = allowSwipeToPrev;
	            s.params.allowSwipeToNext = allowSwipeToNext;
	            if (s.params.onAfterResize) s.params.onAfterResize(s);
	        };
	
	        /*=========================
	          Events
	          ===========================*/
	
	        //Define Touch Events
	        s.touchEventsDesktop = { start: 'mousedown', move: 'mousemove', end: 'mouseup' };
	        if (window.navigator.pointerEnabled) s.touchEventsDesktop = { start: 'pointerdown', move: 'pointermove', end: 'pointerup' };else if (window.navigator.msPointerEnabled) s.touchEventsDesktop = { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' };
	        s.touchEvents = {
	            start: s.support.touch || !s.params.simulateTouch ? 'touchstart' : s.touchEventsDesktop.start,
	            move: s.support.touch || !s.params.simulateTouch ? 'touchmove' : s.touchEventsDesktop.move,
	            end: s.support.touch || !s.params.simulateTouch ? 'touchend' : s.touchEventsDesktop.end
	        };
	
	        // WP8 Touch Events Fix
	        if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
	            (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
	        }
	
	        // Attach/detach events
	        s.initEvents = function (detach) {
	            var actionDom = detach ? 'off' : 'on';
	            var action = detach ? 'removeEventListener' : 'addEventListener';
	            var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
	            var target = s.support.touch ? touchEventsTarget : document;
	
	            var moveCapture = s.params.nested ? true : false;
	
	            //Touch Events
	            if (s.browser.ie) {
	                touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
	                target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
	                target[action](s.touchEvents.end, s.onTouchEnd, false);
	            } else {
	                if (s.support.touch) {
	                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? { passive: true, capture: false } : false;
	                    touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, passiveListener);
	                    touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
	                    touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, passiveListener);
	                }
	                if (params.simulateTouch && !s.device.ios && !s.device.android || params.simulateTouch && !s.support.touch && s.device.ios) {
	                    touchEventsTarget[action]('mousedown', s.onTouchStart, false);
	                    document[action]('mousemove', s.onTouchMove, moveCapture);
	                    document[action]('mouseup', s.onTouchEnd, false);
	                }
	            }
	            window[action]('resize', s.onResize);
	
	            // Next, Prev, Index
	            if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
	                s.nextButton[actionDom]('click', s.onClickNext);
	                if (s.params.a11y && s.a11y) s.nextButton[actionDom]('keydown', s.a11y.onEnterKey);
	            }
	            if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
	                s.prevButton[actionDom]('click', s.onClickPrev);
	                if (s.params.a11y && s.a11y) s.prevButton[actionDom]('keydown', s.a11y.onEnterKey);
	            }
	            if (s.params.pagination && s.params.paginationClickable) {
	                s.paginationContainer[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
	                if (s.params.a11y && s.a11y) s.paginationContainer[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
	            }
	
	            // Prevent Links Clicks
	            if (s.params.preventClicks || s.params.preventClicksPropagation) touchEventsTarget[action]('click', s.preventClicks, true);
	        };
	        s.attachEvents = function () {
	            s.initEvents();
	        };
	        s.detachEvents = function () {
	            s.initEvents(true);
	        };
	
	        /*=========================
	          Handle Clicks
	          ===========================*/
	        // Prevent Clicks
	        s.allowClick = true;
	        s.preventClicks = function (e) {
	            if (!s.allowClick) {
	                if (s.params.preventClicks) e.preventDefault();
	                if (s.params.preventClicksPropagation && s.animating) {
	                    e.stopPropagation();
	                    e.stopImmediatePropagation();
	                }
	            }
	        };
	        // Clicks
	        s.onClickNext = function (e) {
	            e.preventDefault();
	            if (s.isEnd && !s.params.loop) return;
	            s.slideNext();
	        };
	        s.onClickPrev = function (e) {
	            e.preventDefault();
	            if (s.isBeginning && !s.params.loop) return;
	            s.slidePrev();
	        };
	        s.onClickIndex = function (e) {
	            e.preventDefault();
	            var index = $(this).index() * s.params.slidesPerGroup;
	            if (s.params.loop) index = index + s.loopedSlides;
	            s.slideTo(index);
	        };
	
	        /*=========================
	          Handle Touches
	          ===========================*/
	        function findElementInEvent(e, selector) {
	            var el = $(e.target);
	            if (!el.is(selector)) {
	                if (typeof selector === 'string') {
	                    el = el.parents(selector);
	                } else if (selector.nodeType) {
	                    var found;
	                    el.parents().each(function (index, _el) {
	                        if (_el === selector) found = selector;
	                    });
	                    if (!found) return undefined;else return selector;
	                }
	            }
	            if (el.length === 0) {
	                return undefined;
	            }
	            return el[0];
	        }
	        s.updateClickedSlide = function (e) {
	            var slide = findElementInEvent(e, '.' + s.params.slideClass);
	            var slideFound = false;
	            if (slide) {
	                for (var i = 0; i < s.slides.length; i++) {
	                    if (s.slides[i] === slide) slideFound = true;
	                }
	            }
	
	            if (slide && slideFound) {
	                s.clickedSlide = slide;
	                s.clickedIndex = $(slide).index();
	            } else {
	                s.clickedSlide = undefined;
	                s.clickedIndex = undefined;
	                return;
	            }
	            if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
	                var slideToIndex = s.clickedIndex,
	                    realIndex,
	                    duplicatedSlides,
	                    slidesPerView = s.params.slidesPerView === 'auto' ? s.currentSlidesPerView() : s.params.slidesPerView;
	                if (s.params.loop) {
	                    if (s.animating) return;
	                    realIndex = parseInt($(s.clickedSlide).attr('data-swiper-slide-index'), 10);
	                    if (s.params.centeredSlides) {
	                        if (slideToIndex < s.loopedSlides - slidesPerView / 2 || slideToIndex > s.slides.length - s.loopedSlides + slidesPerView / 2) {
	                            s.fixLoop();
	                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
	                            setTimeout(function () {
	                                s.slideTo(slideToIndex);
	                            }, 0);
	                        } else {
	                            s.slideTo(slideToIndex);
	                        }
	                    } else {
	                        if (slideToIndex > s.slides.length - slidesPerView) {
	                            s.fixLoop();
	                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
	                            setTimeout(function () {
	                                s.slideTo(slideToIndex);
	                            }, 0);
	                        } else {
	                            s.slideTo(slideToIndex);
	                        }
	                    }
	                } else {
	                    s.slideTo(slideToIndex);
	                }
	            }
	        };
	
	        var isTouched,
	            isMoved,
	            allowTouchCallbacks,
	            touchStartTime,
	            isScrolling,
	            currentTranslate,
	            startTranslate,
	            allowThresholdMove,
	
	        // Form elements to match
	        formElements = 'input, select, textarea, button, video',
	
	        // Last click time
	        lastClickTime = Date.now(),
	            clickTimeout,
	
	        //Velocities
	        velocities = [],
	            allowMomentumBounce;
	
	        // Animating Flag
	        s.animating = false;
	
	        // Touches information
	        s.touches = {
	            startX: 0,
	            startY: 0,
	            currentX: 0,
	            currentY: 0,
	            diff: 0
	        };
	
	        // Touch handlers
	        var isTouchEvent, startMoving;
	        s.onTouchStart = function (e) {
	            if (e.originalEvent) e = e.originalEvent;
	            isTouchEvent = e.type === 'touchstart';
	            if (!isTouchEvent && 'which' in e && e.which === 3) return;
	            if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
	                s.allowClick = true;
	                return;
	            }
	            if (s.params.swipeHandler) {
	                if (!findElementInEvent(e, s.params.swipeHandler)) return;
	            }
	
	            var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	            var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	
	            // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
	            if (s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
	                return;
	            }
	
	            isTouched = true;
	            isMoved = false;
	            allowTouchCallbacks = true;
	            isScrolling = undefined;
	            startMoving = undefined;
	            s.touches.startX = startX;
	            s.touches.startY = startY;
	            touchStartTime = Date.now();
	            s.allowClick = true;
	            s.updateContainerSize();
	            s.swipeDirection = undefined;
	            if (s.params.threshold > 0) allowThresholdMove = false;
	            if (e.type !== 'touchstart') {
	                var preventDefault = true;
	                if ($(e.target).is(formElements)) preventDefault = false;
	                if (document.activeElement && $(document.activeElement).is(formElements)) {
	                    document.activeElement.blur();
	                }
	                if (preventDefault) {
	                    e.preventDefault();
	                }
	            }
	            s.emit('onTouchStart', s, e);
	        };
	
	        s.onTouchMove = function (e) {
	            if (e.originalEvent) e = e.originalEvent;
	            if (isTouchEvent && e.type === 'mousemove') return;
	            if (e.preventedByNestedSwiper) {
	                s.touches.startX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	                s.touches.startY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	                return;
	            }
	            if (s.params.onlyExternal) {
	                // isMoved = true;
	                s.allowClick = false;
	                if (isTouched) {
	                    s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	                    s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	                    touchStartTime = Date.now();
	                }
	                return;
	            }
	            if (isTouchEvent && s.params.touchReleaseOnEdges && !s.params.loop) {
	                if (!s.isHorizontal()) {
	                    // Vertical
	                    if (s.touches.currentY < s.touches.startY && s.translate <= s.maxTranslate() || s.touches.currentY > s.touches.startY && s.translate >= s.minTranslate()) {
	                        return;
	                    }
	                } else {
	                    if (s.touches.currentX < s.touches.startX && s.translate <= s.maxTranslate() || s.touches.currentX > s.touches.startX && s.translate >= s.minTranslate()) {
	                        return;
	                    }
	                }
	            }
	            if (isTouchEvent && document.activeElement) {
	                if (e.target === document.activeElement && $(e.target).is(formElements)) {
	                    isMoved = true;
	                    s.allowClick = false;
	                    return;
	                }
	            }
	            if (allowTouchCallbacks) {
	                s.emit('onTouchMove', s, e);
	            }
	            if (e.targetTouches && e.targetTouches.length > 1) return;
	
	            s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	            s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	
	            if (typeof isScrolling === 'undefined') {
	                var touchAngle;
	                if (s.isHorizontal() && s.touches.currentY === s.touches.startY || !s.isHorizontal() && s.touches.currentX === s.touches.startX) {
	                    isScrolling = false;
	                } else {
	                    touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
	                    isScrolling = s.isHorizontal() ? touchAngle > s.params.touchAngle : 90 - touchAngle > s.params.touchAngle;
	                }
	            }
	            if (isScrolling) {
	                s.emit('onTouchMoveOpposite', s, e);
	            }
	            if (typeof startMoving === 'undefined') {
	                if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
	                    startMoving = true;
	                }
	            }
	            if (!isTouched) return;
	            if (isScrolling) {
	                isTouched = false;
	                return;
	            }
	            if (!startMoving) {
	                return;
	            }
	            s.allowClick = false;
	            s.emit('onSliderMove', s, e);
	            e.preventDefault();
	            if (s.params.touchMoveStopPropagation && !s.params.nested) {
	                e.stopPropagation();
	            }
	
	            if (!isMoved) {
	                if (params.loop) {
	                    s.fixLoop();
	                }
	                startTranslate = s.getWrapperTranslate();
	                s.setWrapperTransition(0);
	                if (s.animating) {
	                    s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
	                }
	                if (s.params.autoplay && s.autoplaying) {
	                    if (s.params.autoplayDisableOnInteraction) {
	                        s.stopAutoplay();
	                    } else {
	                        s.pauseAutoplay();
	                    }
	                }
	                allowMomentumBounce = false;
	                //Grab Cursor
	                if (s.params.grabCursor && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
	                    s.setGrabCursor(true);
	                }
	            }
	            isMoved = true;
	
	            var diff = s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
	
	            diff = diff * s.params.touchRatio;
	            if (s.rtl) diff = -diff;
	
	            s.swipeDirection = diff > 0 ? 'prev' : 'next';
	            currentTranslate = diff + startTranslate;
	
	            var disableParentSwiper = true;
	            if (diff > 0 && currentTranslate > s.minTranslate()) {
	                disableParentSwiper = false;
	                if (s.params.resistance) currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
	            } else if (diff < 0 && currentTranslate < s.maxTranslate()) {
	                disableParentSwiper = false;
	                if (s.params.resistance) currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
	            }
	
	            if (disableParentSwiper) {
	                e.preventedByNestedSwiper = true;
	            }
	
	            // Directions locks
	            if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
	                currentTranslate = startTranslate;
	            }
	            if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
	                currentTranslate = startTranslate;
	            }
	
	            // Threshold
	            if (s.params.threshold > 0) {
	                if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
	                    if (!allowThresholdMove) {
	                        allowThresholdMove = true;
	                        s.touches.startX = s.touches.currentX;
	                        s.touches.startY = s.touches.currentY;
	                        currentTranslate = startTranslate;
	                        s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
	                        return;
	                    }
	                } else {
	                    currentTranslate = startTranslate;
	                    return;
	                }
	            }
	
	            if (!s.params.followFinger) return;
	
	            // Update active index in free mode
	            if (s.params.freeMode || s.params.watchSlidesProgress) {
	                s.updateActiveIndex();
	            }
	            if (s.params.freeMode) {
	                //Velocity
	                if (velocities.length === 0) {
	                    velocities.push({
	                        position: s.touches[s.isHorizontal() ? 'startX' : 'startY'],
	                        time: touchStartTime
	                    });
	                }
	                velocities.push({
	                    position: s.touches[s.isHorizontal() ? 'currentX' : 'currentY'],
	                    time: new window.Date().getTime()
	                });
	            }
	            // Update progress
	            s.updateProgress(currentTranslate);
	            // Update translate
	            s.setWrapperTranslate(currentTranslate);
	        };
	        s.onTouchEnd = function (e) {
	            if (e.originalEvent) e = e.originalEvent;
	            if (allowTouchCallbacks) {
	                s.emit('onTouchEnd', s, e);
	            }
	            allowTouchCallbacks = false;
	            if (!isTouched) return;
	            //Return Grab Cursor
	            if (s.params.grabCursor && isMoved && isTouched && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
	                s.setGrabCursor(false);
	            }
	
	            // Time diff
	            var touchEndTime = Date.now();
	            var timeDiff = touchEndTime - touchStartTime;
	
	            // Tap, doubleTap, Click
	            if (s.allowClick) {
	                s.updateClickedSlide(e);
	                s.emit('onTap', s, e);
	                if (timeDiff < 300 && touchEndTime - lastClickTime > 300) {
	                    if (clickTimeout) clearTimeout(clickTimeout);
	                    clickTimeout = setTimeout(function () {
	                        if (!s) return;
	                        if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
	                            s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
	                        }
	                        s.emit('onClick', s, e);
	                    }, 300);
	                }
	                if (timeDiff < 300 && touchEndTime - lastClickTime < 300) {
	                    if (clickTimeout) clearTimeout(clickTimeout);
	                    s.emit('onDoubleTap', s, e);
	                }
	            }
	
	            lastClickTime = Date.now();
	            setTimeout(function () {
	                if (s) s.allowClick = true;
	            }, 0);
	
	            if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
	                isTouched = isMoved = false;
	                return;
	            }
	            isTouched = isMoved = false;
	
	            var currentPos;
	            if (s.params.followFinger) {
	                currentPos = s.rtl ? s.translate : -s.translate;
	            } else {
	                currentPos = -currentTranslate;
	            }
	            if (s.params.freeMode) {
	                if (currentPos < -s.minTranslate()) {
	                    s.slideTo(s.activeIndex);
	                    return;
	                } else if (currentPos > -s.maxTranslate()) {
	                    if (s.slides.length < s.snapGrid.length) {
	                        s.slideTo(s.snapGrid.length - 1);
	                    } else {
	                        s.slideTo(s.slides.length - 1);
	                    }
	                    return;
	                }
	
	                if (s.params.freeModeMomentum) {
	                    if (velocities.length > 1) {
	                        var lastMoveEvent = velocities.pop(),
	                            velocityEvent = velocities.pop();
	
	                        var distance = lastMoveEvent.position - velocityEvent.position;
	                        var time = lastMoveEvent.time - velocityEvent.time;
	                        s.velocity = distance / time;
	                        s.velocity = s.velocity / 2;
	                        if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
	                            s.velocity = 0;
	                        }
	                        // this implies that the user stopped moving a finger then released.
	                        // There would be no events with distance zero, so the last event is stale.
	                        if (time > 150 || new window.Date().getTime() - lastMoveEvent.time > 300) {
	                            s.velocity = 0;
	                        }
	                    } else {
	                        s.velocity = 0;
	                    }
	                    s.velocity = s.velocity * s.params.freeModeMomentumVelocityRatio;
	
	                    velocities.length = 0;
	                    var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
	                    var momentumDistance = s.velocity * momentumDuration;
	
	                    var newPosition = s.translate + momentumDistance;
	                    if (s.rtl) newPosition = -newPosition;
	                    var doBounce = false;
	                    var afterBouncePosition;
	                    var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
	                    if (newPosition < s.maxTranslate()) {
	                        if (s.params.freeModeMomentumBounce) {
	                            if (newPosition + s.maxTranslate() < -bounceAmount) {
	                                newPosition = s.maxTranslate() - bounceAmount;
	                            }
	                            afterBouncePosition = s.maxTranslate();
	                            doBounce = true;
	                            allowMomentumBounce = true;
	                        } else {
	                            newPosition = s.maxTranslate();
	                        }
	                    } else if (newPosition > s.minTranslate()) {
	                        if (s.params.freeModeMomentumBounce) {
	                            if (newPosition - s.minTranslate() > bounceAmount) {
	                                newPosition = s.minTranslate() + bounceAmount;
	                            }
	                            afterBouncePosition = s.minTranslate();
	                            doBounce = true;
	                            allowMomentumBounce = true;
	                        } else {
	                            newPosition = s.minTranslate();
	                        }
	                    } else if (s.params.freeModeSticky) {
	                        var j = 0,
	                            nextSlide;
	                        for (j = 0; j < s.snapGrid.length; j += 1) {
	                            if (s.snapGrid[j] > -newPosition) {
	                                nextSlide = j;
	                                break;
	                            }
	                        }
	                        if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
	                            newPosition = s.snapGrid[nextSlide];
	                        } else {
	                            newPosition = s.snapGrid[nextSlide - 1];
	                        }
	                        if (!s.rtl) newPosition = -newPosition;
	                    }
	                    //Fix duration
	                    if (s.velocity !== 0) {
	                        if (s.rtl) {
	                            momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
	                        } else {
	                            momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
	                        }
	                    } else if (s.params.freeModeSticky) {
	                        s.slideReset();
	                        return;
	                    }
	
	                    if (s.params.freeModeMomentumBounce && doBounce) {
	                        s.updateProgress(afterBouncePosition);
	                        s.setWrapperTransition(momentumDuration);
	                        s.setWrapperTranslate(newPosition);
	                        s.onTransitionStart();
	                        s.animating = true;
	                        s.wrapper.transitionEnd(function () {
	                            if (!s || !allowMomentumBounce) return;
	                            s.emit('onMomentumBounce', s);
	
	                            s.setWrapperTransition(s.params.speed);
	                            s.setWrapperTranslate(afterBouncePosition);
	                            s.wrapper.transitionEnd(function () {
	                                if (!s) return;
	                                s.onTransitionEnd();
	                            });
	                        });
	                    } else if (s.velocity) {
	                        s.updateProgress(newPosition);
	                        s.setWrapperTransition(momentumDuration);
	                        s.setWrapperTranslate(newPosition);
	                        s.onTransitionStart();
	                        if (!s.animating) {
	                            s.animating = true;
	                            s.wrapper.transitionEnd(function () {
	                                if (!s) return;
	                                s.onTransitionEnd();
	                            });
	                        }
	                    } else {
	                        s.updateProgress(newPosition);
	                    }
	
	                    s.updateActiveIndex();
	                }
	                if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
	                    s.updateProgress();
	                    s.updateActiveIndex();
	                }
	                return;
	            }
	
	            // Find current slide
	            var i,
	                stopIndex = 0,
	                groupSize = s.slidesSizesGrid[0];
	            for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
	                if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
	                    if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
	                        stopIndex = i;
	                        groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
	                    }
	                } else {
	                    if (currentPos >= s.slidesGrid[i]) {
	                        stopIndex = i;
	                        groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
	                    }
	                }
	            }
	
	            // Find current slide size
	            var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
	
	            if (timeDiff > s.params.longSwipesMs) {
	                // Long touches
	                if (!s.params.longSwipes) {
	                    s.slideTo(s.activeIndex);
	                    return;
	                }
	                if (s.swipeDirection === 'next') {
	                    if (ratio >= s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);
	                }
	                if (s.swipeDirection === 'prev') {
	                    if (ratio > 1 - s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);
	                }
	            } else {
	                // Short swipes
	                if (!s.params.shortSwipes) {
	                    s.slideTo(s.activeIndex);
	                    return;
	                }
	                if (s.swipeDirection === 'next') {
	                    s.slideTo(stopIndex + s.params.slidesPerGroup);
	                }
	                if (s.swipeDirection === 'prev') {
	                    s.slideTo(stopIndex);
	                }
	            }
	        };
	        /*=========================
	          Transitions
	          ===========================*/
	        s._slideTo = function (slideIndex, speed) {
	            return s.slideTo(slideIndex, speed, true, true);
	        };
	        s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
	            if (typeof runCallbacks === 'undefined') runCallbacks = true;
	            if (typeof slideIndex === 'undefined') slideIndex = 0;
	            if (slideIndex < 0) slideIndex = 0;
	            s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
	            if (s.snapIndex >= s.snapGrid.length) s.snapIndex = s.snapGrid.length - 1;
	
	            var translate = -s.snapGrid[s.snapIndex];
	            // Stop autoplay
	            if (s.params.autoplay && s.autoplaying) {
	                if (internal || !s.params.autoplayDisableOnInteraction) {
	                    s.pauseAutoplay(speed);
	                } else {
	                    s.stopAutoplay();
	                }
	            }
	            // Update progress
	            s.updateProgress(translate);
	
	            // Normalize slideIndex
	            if (s.params.normalizeSlideIndex) {
	                for (var i = 0; i < s.slidesGrid.length; i++) {
	                    if (-Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
	                        slideIndex = i;
	                    }
	                }
	            }
	
	            // Directions locks
	            if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
	                return false;
	            }
	            if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
	                if ((s.activeIndex || 0) !== slideIndex) return false;
	            }
	
	            // Update Index
	            if (typeof speed === 'undefined') speed = s.params.speed;
	            s.previousIndex = s.activeIndex || 0;
	            s.activeIndex = slideIndex;
	            s.updateRealIndex();
	            if (s.rtl && -translate === s.translate || !s.rtl && translate === s.translate) {
	                // Update Height
	                if (s.params.autoHeight) {
	                    s.updateAutoHeight();
	                }
	                s.updateClasses();
	                if (s.params.effect !== 'slide') {
	                    s.setWrapperTranslate(translate);
	                }
	                return false;
	            }
	            s.updateClasses();
	            s.onTransitionStart(runCallbacks);
	
	            if (speed === 0 || s.browser.lteIE9) {
	                s.setWrapperTranslate(translate);
	                s.setWrapperTransition(0);
	                s.onTransitionEnd(runCallbacks);
	            } else {
	                s.setWrapperTranslate(translate);
	                s.setWrapperTransition(speed);
	                if (!s.animating) {
	                    s.animating = true;
	                    s.wrapper.transitionEnd(function () {
	                        if (!s) return;
	                        s.onTransitionEnd(runCallbacks);
	                    });
	                }
	            }
	
	            return true;
	        };
	
	        s.onTransitionStart = function (runCallbacks) {
	            if (typeof runCallbacks === 'undefined') runCallbacks = true;
	            if (s.params.autoHeight) {
	                s.updateAutoHeight();
	            }
	            if (s.lazy) s.lazy.onTransitionStart();
	            if (runCallbacks) {
	                s.emit('onTransitionStart', s);
	                if (s.activeIndex !== s.previousIndex) {
	                    s.emit('onSlideChangeStart', s);
	                    if (s.activeIndex > s.previousIndex) {
	                        s.emit('onSlideNextStart', s);
	                    } else {
	                        s.emit('onSlidePrevStart', s);
	                    }
	                }
	            }
	        };
	        s.onTransitionEnd = function (runCallbacks) {
	            s.animating = false;
	            s.setWrapperTransition(0);
	            if (typeof runCallbacks === 'undefined') runCallbacks = true;
	            if (s.lazy) s.lazy.onTransitionEnd();
	            if (runCallbacks) {
	                s.emit('onTransitionEnd', s);
	                if (s.activeIndex !== s.previousIndex) {
	                    s.emit('onSlideChangeEnd', s);
	                    if (s.activeIndex > s.previousIndex) {
	                        s.emit('onSlideNextEnd', s);
	                    } else {
	                        s.emit('onSlidePrevEnd', s);
	                    }
	                }
	            }
	            if (s.params.history && s.history) {
	                s.history.setHistory(s.params.history, s.activeIndex);
	            }
	            if (s.params.hashnav && s.hashnav) {
	                s.hashnav.setHash();
	            }
	        };
	        s.slideNext = function (runCallbacks, speed, internal) {
	            if (s.params.loop) {
	                if (s.animating) return false;
	                s.fixLoop();
	                var clientLeft = s.container[0].clientLeft;
	                return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
	            } else return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
	        };
	        s._slideNext = function (speed) {
	            return s.slideNext(true, speed, true);
	        };
	        s.slidePrev = function (runCallbacks, speed, internal) {
	            if (s.params.loop) {
	                if (s.animating) return false;
	                s.fixLoop();
	                var clientLeft = s.container[0].clientLeft;
	                return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
	            } else return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
	        };
	        s._slidePrev = function (speed) {
	            return s.slidePrev(true, speed, true);
	        };
	        s.slideReset = function (runCallbacks, speed, internal) {
	            return s.slideTo(s.activeIndex, speed, runCallbacks);
	        };
	
	        s.disableTouchControl = function () {
	            s.params.onlyExternal = true;
	            return true;
	        };
	        s.enableTouchControl = function () {
	            s.params.onlyExternal = false;
	            return true;
	        };
	
	        /*=========================
	          Translate/transition helpers
	          ===========================*/
	        s.setWrapperTransition = function (duration, byController) {
	            s.wrapper.transition(duration);
	            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
	                s.effects[s.params.effect].setTransition(duration);
	            }
	            if (s.params.parallax && s.parallax) {
	                s.parallax.setTransition(duration);
	            }
	            if (s.params.scrollbar && s.scrollbar) {
	                s.scrollbar.setTransition(duration);
	            }
	            if (s.params.control && s.controller) {
	                s.controller.setTransition(duration, byController);
	            }
	            s.emit('onSetTransition', s, duration);
	        };
	        s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
	            var x = 0,
	                y = 0,
	                z = 0;
	            if (s.isHorizontal()) {
	                x = s.rtl ? -translate : translate;
	            } else {
	                y = translate;
	            }
	
	            if (s.params.roundLengths) {
	                x = round(x);
	                y = round(y);
	            }
	
	            if (!s.params.virtualTranslate) {
	                if (s.support.transforms3d) s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
	            }
	
	            s.translate = s.isHorizontal() ? x : y;
	
	            // Check if we need to update progress
	            var progress;
	            var translatesDiff = s.maxTranslate() - s.minTranslate();
	            if (translatesDiff === 0) {
	                progress = 0;
	            } else {
	                progress = (translate - s.minTranslate()) / translatesDiff;
	            }
	            if (progress !== s.progress) {
	                s.updateProgress(translate);
	            }
	
	            if (updateActiveIndex) s.updateActiveIndex();
	            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
	                s.effects[s.params.effect].setTranslate(s.translate);
	            }
	            if (s.params.parallax && s.parallax) {
	                s.parallax.setTranslate(s.translate);
	            }
	            if (s.params.scrollbar && s.scrollbar) {
	                s.scrollbar.setTranslate(s.translate);
	            }
	            if (s.params.control && s.controller) {
	                s.controller.setTranslate(s.translate, byController);
	            }
	            s.emit('onSetTranslate', s, s.translate);
	        };
	
	        s.getTranslate = function (el, axis) {
	            var matrix, curTransform, curStyle, transformMatrix;
	
	            // automatic axis detection
	            if (typeof axis === 'undefined') {
	                axis = 'x';
	            }
	
	            if (s.params.virtualTranslate) {
	                return s.rtl ? -s.translate : s.translate;
	            }
	
	            curStyle = window.getComputedStyle(el, null);
	            if (window.WebKitCSSMatrix) {
	                curTransform = curStyle.transform || curStyle.webkitTransform;
	                if (curTransform.split(',').length > 6) {
	                    curTransform = curTransform.split(', ').map(function (a) {
	                        return a.replace(',', '.');
	                    }).join(', ');
	                }
	                // Some old versions of Webkit choke when 'none' is passed; pass
	                // empty string instead in this case
	                transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
	            } else {
	                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	                matrix = transformMatrix.toString().split(',');
	            }
	
	            if (axis === 'x') {
	                //Latest Chrome and webkits Fix
	                if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
	                //Crazy IE10 Matrix
	                else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
	                    //Normal Browsers
	                    else curTransform = parseFloat(matrix[4]);
	            }
	            if (axis === 'y') {
	                //Latest Chrome and webkits Fix
	                if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
	                //Crazy IE10 Matrix
	                else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
	                    //Normal Browsers
	                    else curTransform = parseFloat(matrix[5]);
	            }
	            if (s.rtl && curTransform) curTransform = -curTransform;
	            return curTransform || 0;
	        };
	        s.getWrapperTranslate = function (axis) {
	            if (typeof axis === 'undefined') {
	                axis = s.isHorizontal() ? 'x' : 'y';
	            }
	            return s.getTranslate(s.wrapper[0], axis);
	        };
	
	        /*=========================
	          Observer
	          ===========================*/
	        s.observers = [];
	        function initObserver(target, options) {
	            options = options || {};
	            // create an observer instance
	            var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
	            var observer = new ObserverFunc(function (mutations) {
	                mutations.forEach(function (mutation) {
	                    s.onResize(true);
	                    s.emit('onObserverUpdate', s, mutation);
	                });
	            });
	
	            observer.observe(target, {
	                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	                childList: typeof options.childList === 'undefined' ? true : options.childList,
	                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
	            });
	
	            s.observers.push(observer);
	        }
	        s.initObservers = function () {
	            if (s.params.observeParents) {
	                var containerParents = s.container.parents();
	                for (var i = 0; i < containerParents.length; i++) {
	                    initObserver(containerParents[i]);
	                }
	            }
	
	            // Observe container
	            initObserver(s.container[0], { childList: false });
	
	            // Observe wrapper
	            initObserver(s.wrapper[0], { attributes: false });
	        };
	        s.disconnectObservers = function () {
	            for (var i = 0; i < s.observers.length; i++) {
	                s.observers[i].disconnect();
	            }
	            s.observers = [];
	        };
	        /*=========================
	          Loop
	          ===========================*/
	        // Create looped slides
	        s.createLoop = function () {
	            // Remove duplicated slides
	            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
	
	            var slides = s.wrapper.children('.' + s.params.slideClass);
	
	            if (s.params.slidesPerView === 'auto' && !s.params.loopedSlides) s.params.loopedSlides = slides.length;
	
	            s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
	            s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
	            if (s.loopedSlides > slides.length) {
	                s.loopedSlides = slides.length;
	            }
	
	            var prependSlides = [],
	                appendSlides = [],
	                i;
	            slides.each(function (index, el) {
	                var slide = $(this);
	                if (index < s.loopedSlides) appendSlides.push(el);
	                if (index < slides.length && index >= slides.length - s.loopedSlides) prependSlides.push(el);
	                slide.attr('data-swiper-slide-index', index);
	            });
	            for (i = 0; i < appendSlides.length; i++) {
	                s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
	            }
	            for (i = prependSlides.length - 1; i >= 0; i--) {
	                s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
	            }
	        };
	        s.destroyLoop = function () {
	            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
	            s.slides.removeAttr('data-swiper-slide-index');
	        };
	        s.reLoop = function (updatePosition) {
	            var oldIndex = s.activeIndex - s.loopedSlides;
	            s.destroyLoop();
	            s.createLoop();
	            s.updateSlidesSize();
	            if (updatePosition) {
	                s.slideTo(oldIndex + s.loopedSlides, 0, false);
	            }
	        };
	        s.fixLoop = function () {
	            var newIndex;
	            //Fix For Negative Oversliding
	            if (s.activeIndex < s.loopedSlides) {
	                newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
	                newIndex = newIndex + s.loopedSlides;
	                s.slideTo(newIndex, 0, false, true);
	            }
	            //Fix For Positive Oversliding
	            else if (s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2 || s.activeIndex > s.slides.length - s.params.slidesPerView * 2) {
	                    newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
	                    newIndex = newIndex + s.loopedSlides;
	                    s.slideTo(newIndex, 0, false, true);
	                }
	        };
	        /*=========================
	          Append/Prepend/Remove Slides
	          ===========================*/
	        s.appendSlide = function (slides) {
	            if (s.params.loop) {
	                s.destroyLoop();
	            }
	            if ((typeof slides === 'undefined' ? 'undefined' : _typeof(slides)) === 'object' && slides.length) {
	                for (var i = 0; i < slides.length; i++) {
	                    if (slides[i]) s.wrapper.append(slides[i]);
	                }
	            } else {
	                s.wrapper.append(slides);
	            }
	            if (s.params.loop) {
	                s.createLoop();
	            }
	            if (!(s.params.observer && s.support.observer)) {
	                s.update(true);
	            }
	        };
	        s.prependSlide = function (slides) {
	            if (s.params.loop) {
	                s.destroyLoop();
	            }
	            var newActiveIndex = s.activeIndex + 1;
	            if ((typeof slides === 'undefined' ? 'undefined' : _typeof(slides)) === 'object' && slides.length) {
	                for (var i = 0; i < slides.length; i++) {
	                    if (slides[i]) s.wrapper.prepend(slides[i]);
	                }
	                newActiveIndex = s.activeIndex + slides.length;
	            } else {
	                s.wrapper.prepend(slides);
	            }
	            if (s.params.loop) {
	                s.createLoop();
	            }
	            if (!(s.params.observer && s.support.observer)) {
	                s.update(true);
	            }
	            s.slideTo(newActiveIndex, 0, false);
	        };
	        s.removeSlide = function (slidesIndexes) {
	            if (s.params.loop) {
	                s.destroyLoop();
	                s.slides = s.wrapper.children('.' + s.params.slideClass);
	            }
	            var newActiveIndex = s.activeIndex,
	                indexToRemove;
	            if ((typeof slidesIndexes === 'undefined' ? 'undefined' : _typeof(slidesIndexes)) === 'object' && slidesIndexes.length) {
	                for (var i = 0; i < slidesIndexes.length; i++) {
	                    indexToRemove = slidesIndexes[i];
	                    if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
	                    if (indexToRemove < newActiveIndex) newActiveIndex--;
	                }
	                newActiveIndex = Math.max(newActiveIndex, 0);
	            } else {
	                indexToRemove = slidesIndexes;
	                if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
	                if (indexToRemove < newActiveIndex) newActiveIndex--;
	                newActiveIndex = Math.max(newActiveIndex, 0);
	            }
	
	            if (s.params.loop) {
	                s.createLoop();
	            }
	
	            if (!(s.params.observer && s.support.observer)) {
	                s.update(true);
	            }
	            if (s.params.loop) {
	                s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
	            } else {
	                s.slideTo(newActiveIndex, 0, false);
	            }
	        };
	        s.removeAllSlides = function () {
	            var slidesIndexes = [];
	            for (var i = 0; i < s.slides.length; i++) {
	                slidesIndexes.push(i);
	            }
	            s.removeSlide(slidesIndexes);
	        };
	
	        /*=========================
	          Effects
	          ===========================*/
	        s.effects = {
	            fade: {
	                setTranslate: function setTranslate() {
	                    for (var i = 0; i < s.slides.length; i++) {
	                        var slide = s.slides.eq(i);
	                        var offset = slide[0].swiperSlideOffset;
	                        var tx = -offset;
	                        if (!s.params.virtualTranslate) tx = tx - s.translate;
	                        var ty = 0;
	                        if (!s.isHorizontal()) {
	                            ty = tx;
	                            tx = 0;
	                        }
	                        var slideOpacity = s.params.fade.crossFade ? Math.max(1 - Math.abs(slide[0].progress), 0) : 1 + Math.min(Math.max(slide[0].progress, -1), 0);
	                        slide.css({
	                            opacity: slideOpacity
	                        }).transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
	                    }
	                },
	                setTransition: function setTransition(duration) {
	                    s.slides.transition(duration);
	                    if (s.params.virtualTranslate && duration !== 0) {
	                        var eventTriggered = false;
	                        s.slides.transitionEnd(function () {
	                            if (eventTriggered) return;
	                            if (!s) return;
	                            eventTriggered = true;
	                            s.animating = false;
	                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
	                            for (var i = 0; i < triggerEvents.length; i++) {
	                                s.wrapper.trigger(triggerEvents[i]);
	                            }
	                        });
	                    }
	                }
	            },
	            flip: {
	                setTranslate: function setTranslate() {
	                    for (var i = 0; i < s.slides.length; i++) {
	                        var slide = s.slides.eq(i);
	                        var progress = slide[0].progress;
	                        if (s.params.flip.limitRotation) {
	                            progress = Math.max(Math.min(slide[0].progress, 1), -1);
	                        }
	                        var offset = slide[0].swiperSlideOffset;
	                        var rotate = -180 * progress,
	                            rotateY = rotate,
	                            rotateX = 0,
	                            tx = -offset,
	                            ty = 0;
	                        if (!s.isHorizontal()) {
	                            ty = tx;
	                            tx = 0;
	                            rotateX = -rotateY;
	                            rotateY = 0;
	                        } else if (s.rtl) {
	                            rotateY = -rotateY;
	                        }
	
	                        slide[0].style.zIndex = -Math.abs(Math.round(progress)) + s.slides.length;
	
	                        if (s.params.flip.slideShadows) {
	                            //Set shadows
	                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
	                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
	                            if (shadowBefore.length === 0) {
	                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
	                                slide.append(shadowBefore);
	                            }
	                            if (shadowAfter.length === 0) {
	                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
	                                slide.append(shadowAfter);
	                            }
	                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
	                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
	                        }
	
	                        slide.transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px) rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)');
	                    }
	                },
	                setTransition: function setTransition(duration) {
	                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	                    if (s.params.virtualTranslate && duration !== 0) {
	                        var eventTriggered = false;
	                        s.slides.eq(s.activeIndex).transitionEnd(function () {
	                            if (eventTriggered) return;
	                            if (!s) return;
	                            if (!$(this).hasClass(s.params.slideActiveClass)) return;
	                            eventTriggered = true;
	                            s.animating = false;
	                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
	                            for (var i = 0; i < triggerEvents.length; i++) {
	                                s.wrapper.trigger(triggerEvents[i]);
	                            }
	                        });
	                    }
	                }
	            },
	            cube: {
	                setTranslate: function setTranslate() {
	                    var wrapperRotate = 0,
	                        cubeShadow;
	                    if (s.params.cube.shadow) {
	                        if (s.isHorizontal()) {
	                            cubeShadow = s.wrapper.find('.swiper-cube-shadow');
	                            if (cubeShadow.length === 0) {
	                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
	                                s.wrapper.append(cubeShadow);
	                            }
	                            cubeShadow.css({ height: s.width + 'px' });
	                        } else {
	                            cubeShadow = s.container.find('.swiper-cube-shadow');
	                            if (cubeShadow.length === 0) {
	                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
	                                s.container.append(cubeShadow);
	                            }
	                        }
	                    }
	                    for (var i = 0; i < s.slides.length; i++) {
	                        var slide = s.slides.eq(i);
	                        var slideAngle = i * 90;
	                        var round = Math.floor(slideAngle / 360);
	                        if (s.rtl) {
	                            slideAngle = -slideAngle;
	                            round = Math.floor(-slideAngle / 360);
	                        }
	                        var progress = Math.max(Math.min(slide[0].progress, 1), -1);
	                        var tx = 0,
	                            ty = 0,
	                            tz = 0;
	                        if (i % 4 === 0) {
	                            tx = -round * 4 * s.size;
	                            tz = 0;
	                        } else if ((i - 1) % 4 === 0) {
	                            tx = 0;
	                            tz = -round * 4 * s.size;
	                        } else if ((i - 2) % 4 === 0) {
	                            tx = s.size + round * 4 * s.size;
	                            tz = s.size;
	                        } else if ((i - 3) % 4 === 0) {
	                            tx = -s.size;
	                            tz = 3 * s.size + s.size * 4 * round;
	                        }
	                        if (s.rtl) {
	                            tx = -tx;
	                        }
	
	                        if (!s.isHorizontal()) {
	                            ty = tx;
	                            tx = 0;
	                        }
	
	                        var transform = 'rotateX(' + (s.isHorizontal() ? 0 : -slideAngle) + 'deg) rotateY(' + (s.isHorizontal() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
	                        if (progress <= 1 && progress > -1) {
	                            wrapperRotate = i * 90 + progress * 90;
	                            if (s.rtl) wrapperRotate = -i * 90 - progress * 90;
	                        }
	                        slide.transform(transform);
	                        if (s.params.cube.slideShadows) {
	                            //Set shadows
	                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
	                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
	                            if (shadowBefore.length === 0) {
	                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
	                                slide.append(shadowBefore);
	                            }
	                            if (shadowAfter.length === 0) {
	                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
	                                slide.append(shadowAfter);
	                            }
	                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
	                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
	                        }
	                    }
	                    s.wrapper.css({
	                        '-webkit-transform-origin': '50% 50% -' + s.size / 2 + 'px',
	                        '-moz-transform-origin': '50% 50% -' + s.size / 2 + 'px',
	                        '-ms-transform-origin': '50% 50% -' + s.size / 2 + 'px',
	                        'transform-origin': '50% 50% -' + s.size / 2 + 'px'
	                    });
	
	                    if (s.params.cube.shadow) {
	                        if (s.isHorizontal()) {
	                            cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + -s.width / 2 + 'px) rotateX(90deg) rotateZ(0deg) scale(' + s.params.cube.shadowScale + ')');
	                        } else {
	                            var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
	                            var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
	                            var scale1 = s.params.cube.shadowScale,
	                                scale2 = s.params.cube.shadowScale / multiplier,
	                                offset = s.params.cube.shadowOffset;
	                            cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + -s.height / 2 / scale2 + 'px) rotateX(-90deg)');
	                        }
	                    }
	                    var zFactor = s.isSafari || s.isUiWebView ? -s.size / 2 : 0;
	                    s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (s.isHorizontal() ? 0 : wrapperRotate) + 'deg) rotateY(' + (s.isHorizontal() ? -wrapperRotate : 0) + 'deg)');
	                },
	                setTransition: function setTransition(duration) {
	                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	                    if (s.params.cube.shadow && !s.isHorizontal()) {
	                        s.container.find('.swiper-cube-shadow').transition(duration);
	                    }
	                }
	            },
	            coverflow: {
	                setTranslate: function setTranslate() {
	                    var transform = s.translate;
	                    var center = s.isHorizontal() ? -transform + s.width / 2 : -transform + s.height / 2;
	                    var rotate = s.isHorizontal() ? s.params.coverflow.rotate : -s.params.coverflow.rotate;
	                    var translate = s.params.coverflow.depth;
	                    //Each slide offset from center
	                    for (var i = 0, length = s.slides.length; i < length; i++) {
	                        var slide = s.slides.eq(i);
	                        var slideSize = s.slidesSizesGrid[i];
	                        var slideOffset = slide[0].swiperSlideOffset;
	                        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;
	
	                        var rotateY = s.isHorizontal() ? rotate * offsetMultiplier : 0;
	                        var rotateX = s.isHorizontal() ? 0 : rotate * offsetMultiplier;
	                        // var rotateZ = 0
	                        var translateZ = -translate * Math.abs(offsetMultiplier);
	
	                        var translateY = s.isHorizontal() ? 0 : s.params.coverflow.stretch * offsetMultiplier;
	                        var translateX = s.isHorizontal() ? s.params.coverflow.stretch * offsetMultiplier : 0;
	
	                        //Fix for ultra small values
	                        if (Math.abs(translateX) < 0.001) translateX = 0;
	                        if (Math.abs(translateY) < 0.001) translateY = 0;
	                        if (Math.abs(translateZ) < 0.001) translateZ = 0;
	                        if (Math.abs(rotateY) < 0.001) rotateY = 0;
	                        if (Math.abs(rotateX) < 0.001) rotateX = 0;
	
	                        var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
	
	                        slide.transform(slideTransform);
	                        slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
	                        if (s.params.coverflow.slideShadows) {
	                            //Set shadows
	                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
	                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
	                            if (shadowBefore.length === 0) {
	                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
	                                slide.append(shadowBefore);
	                            }
	                            if (shadowAfter.length === 0) {
	                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
	                                slide.append(shadowAfter);
	                            }
	                            if (shadowBefore.length) shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
	                            if (shadowAfter.length) shadowAfter[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
	                        }
	                    }
	
	                    //Set correct perspective for IE10
	                    if (s.browser.ie) {
	                        var ws = s.wrapper[0].style;
	                        ws.perspectiveOrigin = center + 'px 50%';
	                    }
	                },
	                setTransition: function setTransition(duration) {
	                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	                }
	            }
	        };
	
	        /*=========================
	          Images Lazy Loading
	          ===========================*/
	        s.lazy = {
	            initialImageLoaded: false,
	            loadImageInSlide: function loadImageInSlide(index, loadInDuplicate) {
	                if (typeof index === 'undefined') return;
	                if (typeof loadInDuplicate === 'undefined') loadInDuplicate = true;
	                if (s.slides.length === 0) return;
	
	                var slide = s.slides.eq(index);
	                var img = slide.find('.' + s.params.lazyLoadingClass + ':not(.' + s.params.lazyStatusLoadedClass + '):not(.' + s.params.lazyStatusLoadingClass + ')');
	                if (slide.hasClass(s.params.lazyLoadingClass) && !slide.hasClass(s.params.lazyStatusLoadedClass) && !slide.hasClass(s.params.lazyStatusLoadingClass)) {
	                    img = img.add(slide[0]);
	                }
	                if (img.length === 0) return;
	
	                img.each(function () {
	                    var _img = $(this);
	                    _img.addClass(s.params.lazyStatusLoadingClass);
	                    var background = _img.attr('data-background');
	                    var src = _img.attr('data-src'),
	                        srcset = _img.attr('data-srcset'),
	                        sizes = _img.attr('data-sizes');
	                    s.loadImage(_img[0], src || background, srcset, sizes, false, function () {
	                        if (typeof s === 'undefined' || s === null || !s) return;
	                        if (background) {
	                            _img.css('background-image', 'url("' + background + '")');
	                            _img.removeAttr('data-background');
	                        } else {
	                            if (srcset) {
	                                _img.attr('srcset', srcset);
	                                _img.removeAttr('data-srcset');
	                            }
	                            if (sizes) {
	                                _img.attr('sizes', sizes);
	                                _img.removeAttr('data-sizes');
	                            }
	                            if (src) {
	                                _img.attr('src', src);
	                                _img.removeAttr('data-src');
	                            }
	                        }
	
	                        _img.addClass(s.params.lazyStatusLoadedClass).removeClass(s.params.lazyStatusLoadingClass);
	                        slide.find('.' + s.params.lazyPreloaderClass + ', .' + s.params.preloaderClass).remove();
	                        if (s.params.loop && loadInDuplicate) {
	                            var slideOriginalIndex = slide.attr('data-swiper-slide-index');
	                            if (slide.hasClass(s.params.slideDuplicateClass)) {
	                                var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
	                                s.lazy.loadImageInSlide(originalSlide.index(), false);
	                            } else {
	                                var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
	                                s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
	                            }
	                        }
	                        s.emit('onLazyImageReady', s, slide[0], _img[0]);
	                    });
	
	                    s.emit('onLazyImageLoad', s, slide[0], _img[0]);
	                });
	            },
	            load: function load() {
	                var i;
	                var slidesPerView = s.params.slidesPerView;
	                if (slidesPerView === 'auto') {
	                    slidesPerView = 0;
	                }
	                if (!s.lazy.initialImageLoaded) s.lazy.initialImageLoaded = true;
	                if (s.params.watchSlidesVisibility) {
	                    s.wrapper.children('.' + s.params.slideVisibleClass).each(function () {
	                        s.lazy.loadImageInSlide($(this).index());
	                    });
	                } else {
	                    if (slidesPerView > 1) {
	                        for (i = s.activeIndex; i < s.activeIndex + slidesPerView; i++) {
	                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
	                        }
	                    } else {
	                        s.lazy.loadImageInSlide(s.activeIndex);
	                    }
	                }
	                if (s.params.lazyLoadingInPrevNext) {
	                    if (slidesPerView > 1 || s.params.lazyLoadingInPrevNextAmount && s.params.lazyLoadingInPrevNextAmount > 1) {
	                        var amount = s.params.lazyLoadingInPrevNextAmount;
	                        var spv = slidesPerView;
	                        var maxIndex = Math.min(s.activeIndex + spv + Math.max(amount, spv), s.slides.length);
	                        var minIndex = Math.max(s.activeIndex - Math.max(spv, amount), 0);
	                        // Next Slides
	                        for (i = s.activeIndex + slidesPerView; i < maxIndex; i++) {
	                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
	                        }
	                        // Prev Slides
	                        for (i = minIndex; i < s.activeIndex; i++) {
	                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
	                        }
	                    } else {
	                        var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
	                        if (nextSlide.length > 0) s.lazy.loadImageInSlide(nextSlide.index());
	
	                        var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
	                        if (prevSlide.length > 0) s.lazy.loadImageInSlide(prevSlide.index());
	                    }
	                }
	            },
	            onTransitionStart: function onTransitionStart() {
	                if (s.params.lazyLoading) {
	                    if (s.params.lazyLoadingOnTransitionStart || !s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded) {
	                        s.lazy.load();
	                    }
	                }
	            },
	            onTransitionEnd: function onTransitionEnd() {
	                if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
	                    s.lazy.load();
	                }
	            }
	        };
	
	        /*=========================
	          Scrollbar
	          ===========================*/
	        s.scrollbar = {
	            isTouched: false,
	            setDragPosition: function setDragPosition(e) {
	                var sb = s.scrollbar;
	                var x = 0,
	                    y = 0;
	                var translate;
	                var pointerPosition = s.isHorizontal() ? e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX || e.clientX : e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY || e.clientY;
	                var position = pointerPosition - sb.track.offset()[s.isHorizontal() ? 'left' : 'top'] - sb.dragSize / 2;
	                var positionMin = -s.minTranslate() * sb.moveDivider;
	                var positionMax = -s.maxTranslate() * sb.moveDivider;
	                if (position < positionMin) {
	                    position = positionMin;
	                } else if (position > positionMax) {
	                    position = positionMax;
	                }
	                position = -position / sb.moveDivider;
	                s.updateProgress(position);
	                s.setWrapperTranslate(position, true);
	            },
	            dragStart: function dragStart(e) {
	                var sb = s.scrollbar;
	                sb.isTouched = true;
	                e.preventDefault();
	                e.stopPropagation();
	
	                sb.setDragPosition(e);
	                clearTimeout(sb.dragTimeout);
	
	                sb.track.transition(0);
	                if (s.params.scrollbarHide) {
	                    sb.track.css('opacity', 1);
	                }
	                s.wrapper.transition(100);
	                sb.drag.transition(100);
	                s.emit('onScrollbarDragStart', s);
	            },
	            dragMove: function dragMove(e) {
	                var sb = s.scrollbar;
	                if (!sb.isTouched) return;
	                if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	                sb.setDragPosition(e);
	                s.wrapper.transition(0);
	                sb.track.transition(0);
	                sb.drag.transition(0);
	                s.emit('onScrollbarDragMove', s);
	            },
	            dragEnd: function dragEnd(e) {
	                var sb = s.scrollbar;
	                if (!sb.isTouched) return;
	                sb.isTouched = false;
	                if (s.params.scrollbarHide) {
	                    clearTimeout(sb.dragTimeout);
	                    sb.dragTimeout = setTimeout(function () {
	                        sb.track.css('opacity', 0);
	                        sb.track.transition(400);
	                    }, 1000);
	                }
	                s.emit('onScrollbarDragEnd', s);
	                if (s.params.scrollbarSnapOnRelease) {
	                    s.slideReset();
	                }
	            },
	            draggableEvents: function () {
	                if (s.params.simulateTouch === false && !s.support.touch) return s.touchEventsDesktop;else return s.touchEvents;
	            }(),
	            enableDraggable: function enableDraggable() {
	                var sb = s.scrollbar;
	                var target = s.support.touch ? sb.track : document;
	                $(sb.track).on(sb.draggableEvents.start, sb.dragStart);
	                $(target).on(sb.draggableEvents.move, sb.dragMove);
	                $(target).on(sb.draggableEvents.end, sb.dragEnd);
	            },
	            disableDraggable: function disableDraggable() {
	                var sb = s.scrollbar;
	                var target = s.support.touch ? sb.track : document;
	                $(sb.track).off(sb.draggableEvents.start, sb.dragStart);
	                $(target).off(sb.draggableEvents.move, sb.dragMove);
	                $(target).off(sb.draggableEvents.end, sb.dragEnd);
	            },
	            set: function set() {
	                if (!s.params.scrollbar) return;
	                var sb = s.scrollbar;
	                sb.track = $(s.params.scrollbar);
	                if (s.params.uniqueNavElements && typeof s.params.scrollbar === 'string' && sb.track.length > 1 && s.container.find(s.params.scrollbar).length === 1) {
	                    sb.track = s.container.find(s.params.scrollbar);
	                }
	                sb.drag = sb.track.find('.swiper-scrollbar-drag');
	                if (sb.drag.length === 0) {
	                    sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
	                    sb.track.append(sb.drag);
	                }
	                sb.drag[0].style.width = '';
	                sb.drag[0].style.height = '';
	                sb.trackSize = s.isHorizontal() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;
	
	                sb.divider = s.size / s.virtualSize;
	                sb.moveDivider = sb.divider * (sb.trackSize / s.size);
	                sb.dragSize = sb.trackSize * sb.divider;
	
	                if (s.isHorizontal()) {
	                    sb.drag[0].style.width = sb.dragSize + 'px';
	                } else {
	                    sb.drag[0].style.height = sb.dragSize + 'px';
	                }
	
	                if (sb.divider >= 1) {
	                    sb.track[0].style.display = 'none';
	                } else {
	                    sb.track[0].style.display = '';
	                }
	                if (s.params.scrollbarHide) {
	                    sb.track[0].style.opacity = 0;
	                }
	            },
	            setTranslate: function setTranslate() {
	                if (!s.params.scrollbar) return;
	                var diff;
	                var sb = s.scrollbar;
	                var translate = s.translate || 0;
	                var newPos;
	
	                var newSize = sb.dragSize;
	                newPos = (sb.trackSize - sb.dragSize) * s.progress;
	                if (s.rtl && s.isHorizontal()) {
	                    newPos = -newPos;
	                    if (newPos > 0) {
	                        newSize = sb.dragSize - newPos;
	                        newPos = 0;
	                    } else if (-newPos + sb.dragSize > sb.trackSize) {
	                        newSize = sb.trackSize + newPos;
	                    }
	                } else {
	                    if (newPos < 0) {
	                        newSize = sb.dragSize + newPos;
	                        newPos = 0;
	                    } else if (newPos + sb.dragSize > sb.trackSize) {
	                        newSize = sb.trackSize - newPos;
	                    }
	                }
	                if (s.isHorizontal()) {
	                    if (s.support.transforms3d) {
	                        sb.drag.transform('translate3d(' + newPos + 'px, 0, 0)');
	                    } else {
	                        sb.drag.transform('translateX(' + newPos + 'px)');
	                    }
	                    sb.drag[0].style.width = newSize + 'px';
	                } else {
	                    if (s.support.transforms3d) {
	                        sb.drag.transform('translate3d(0px, ' + newPos + 'px, 0)');
	                    } else {
	                        sb.drag.transform('translateY(' + newPos + 'px)');
	                    }
	                    sb.drag[0].style.height = newSize + 'px';
	                }
	                if (s.params.scrollbarHide) {
	                    clearTimeout(sb.timeout);
	                    sb.track[0].style.opacity = 1;
	                    sb.timeout = setTimeout(function () {
	                        sb.track[0].style.opacity = 0;
	                        sb.track.transition(400);
	                    }, 1000);
	                }
	            },
	            setTransition: function setTransition(duration) {
	                if (!s.params.scrollbar) return;
	                s.scrollbar.drag.transition(duration);
	            }
	        };
	
	        /*=========================
	          Controller
	          ===========================*/
	        s.controller = {
	            LinearSpline: function LinearSpline(x, y) {
	                var binarySearch = function () {
	                    var maxIndex, minIndex, guess;
	                    return function (array, val) {
	                        minIndex = -1;
	                        maxIndex = array.length;
	                        while (maxIndex - minIndex > 1) {
	                            if (array[guess = maxIndex + minIndex >> 1] <= val) {
	                                minIndex = guess;
	                            } else {
	                                maxIndex = guess;
	                            }
	                        }return maxIndex;
	                    };
	                }();
	                this.x = x;
	                this.y = y;
	                this.lastIndex = x.length - 1;
	                // Given an x value (x2), return the expected y2 value:
	                // (x1,y1) is the known point before given value,
	                // (x3,y3) is the known point after given value.
	                var i1, i3;
	                var l = this.x.length;
	
	                this.interpolate = function (x2) {
	                    if (!x2) return 0;
	
	                    // Get the indexes of x1 and x3 (the array indexes before and after given x2):
	                    i3 = binarySearch(this.x, x2);
	                    i1 = i3 - 1;
	
	                    // We have our indexes i1 & i3, so we can calculate already:
	                    // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
	                    return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
	                };
	            },
	            //xxx: for now i will just save one spline function to to
	            getInterpolateFunction: function getInterpolateFunction(c) {
	                if (!s.controller.spline) s.controller.spline = s.params.loop ? new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) : new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
	            },
	            setTranslate: function setTranslate(translate, byController) {
	                var controlled = s.params.control;
	                var multiplier, controlledTranslate;
	                function setControlledTranslate(c) {
	                    // this will create an Interpolate function based on the snapGrids
	                    // x is the Grid of the scrolled scroller and y will be the controlled scroller
	                    // it makes sense to create this only once and recall it for the interpolation
	                    // the function does a lot of value caching for performance
	                    translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
	                    if (s.params.controlBy === 'slide') {
	                        s.controller.getInterpolateFunction(c);
	                        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
	                        // but it did not work out
	                        controlledTranslate = -s.controller.spline.interpolate(-translate);
	                    }
	
	                    if (!controlledTranslate || s.params.controlBy === 'container') {
	                        multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
	                        controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
	                    }
	
	                    if (s.params.controlInverse) {
	                        controlledTranslate = c.maxTranslate() - controlledTranslate;
	                    }
	                    c.updateProgress(controlledTranslate);
	                    c.setWrapperTranslate(controlledTranslate, false, s);
	                    c.updateActiveIndex();
	                }
	                if (Array.isArray(controlled)) {
	                    for (var i = 0; i < controlled.length; i++) {
	                        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	                            setControlledTranslate(controlled[i]);
	                        }
	                    }
	                } else if (controlled instanceof Swiper && byController !== controlled) {
	
	                    setControlledTranslate(controlled);
	                }
	            },
	            setTransition: function setTransition(duration, byController) {
	                var controlled = s.params.control;
	                var i;
	                function setControlledTransition(c) {
	                    c.setWrapperTransition(duration, s);
	                    if (duration !== 0) {
	                        c.onTransitionStart();
	                        c.wrapper.transitionEnd(function () {
	                            if (!controlled) return;
	                            if (c.params.loop && s.params.controlBy === 'slide') {
	                                c.fixLoop();
	                            }
	                            c.onTransitionEnd();
	                        });
	                    }
	                }
	                if (Array.isArray(controlled)) {
	                    for (i = 0; i < controlled.length; i++) {
	                        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	                            setControlledTransition(controlled[i]);
	                        }
	                    }
	                } else if (controlled instanceof Swiper && byController !== controlled) {
	                    setControlledTransition(controlled);
	                }
	            }
	        };
	
	        /*=========================
	          Hash Navigation
	          ===========================*/
	        s.hashnav = {
	            onHashCange: function onHashCange(e, a) {
	                var newHash = document.location.hash.replace('#', '');
	                var activeSlideHash = s.slides.eq(s.activeIndex).attr('data-hash');
	                if (newHash !== activeSlideHash) {
	                    s.slideTo(s.wrapper.children('.' + s.params.slideClass + '[data-hash="' + newHash + '"]').index());
	                }
	            },
	            attachEvents: function attachEvents(detach) {
	                var action = detach ? 'off' : 'on';
	                $(window)[action]('hashchange', s.hashnav.onHashCange);
	            },
	            setHash: function setHash() {
	                if (!s.hashnav.initialized || !s.params.hashnav) return;
	                if (s.params.replaceState && window.history && window.history.replaceState) {
	                    window.history.replaceState(null, null, '#' + s.slides.eq(s.activeIndex).attr('data-hash') || '');
	                } else {
	                    var slide = s.slides.eq(s.activeIndex);
	                    var hash = slide.attr('data-hash') || slide.attr('data-history');
	                    document.location.hash = hash || '';
	                }
	            },
	            init: function init() {
	                if (!s.params.hashnav || s.params.history) return;
	                s.hashnav.initialized = true;
	                var hash = document.location.hash.replace('#', '');
	                if (hash) {
	                    var speed = 0;
	                    for (var i = 0, length = s.slides.length; i < length; i++) {
	                        var slide = s.slides.eq(i);
	                        var slideHash = slide.attr('data-hash') || slide.attr('data-history');
	                        if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
	                            var index = slide.index();
	                            s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
	                        }
	                    }
	                }
	                if (s.params.hashnavWatchState) s.hashnav.attachEvents();
	            },
	            destroy: function destroy() {
	                if (s.params.hashnavWatchState) s.hashnav.attachEvents(true);
	            }
	        };
	
	        /*=========================
	          History Api with fallback to Hashnav
	          ===========================*/
	        s.history = {
	            init: function init() {
	                if (!s.params.history) return;
	                if (!window.history || !window.history.pushState) {
	                    s.params.history = false;
	                    s.params.hashnav = true;
	                    return;
	                }
	                s.history.initialized = true;
	                this.paths = this.getPathValues();
	                if (!this.paths.key && !this.paths.value) return;
	                this.scrollToSlide(0, this.paths.value, s.params.runCallbacksOnInit);
	                if (!s.params.replaceState) {
	                    window.addEventListener('popstate', this.setHistoryPopState);
	                }
	            },
	            setHistoryPopState: function setHistoryPopState() {
	                s.history.paths = s.history.getPathValues();
	                s.history.scrollToSlide(s.params.speed, s.history.paths.value, false);
	            },
	            getPathValues: function getPathValues() {
	                var pathArray = window.location.pathname.slice(1).split('/');
	                var total = pathArray.length;
	                var key = pathArray[total - 2];
	                var value = pathArray[total - 1];
	                return { key: key, value: value };
	            },
	            setHistory: function setHistory(key, index) {
	                if (!s.history.initialized || !s.params.history) return;
	                var slide = s.slides.eq(index);
	                var value = this.slugify(slide.attr('data-history'));
	                if (!window.location.pathname.includes(key)) {
	                    value = key + '/' + value;
	                }
	                if (s.params.replaceState) {
	                    window.history.replaceState(null, null, value);
	                } else {
	                    window.history.pushState(null, null, value);
	                }
	            },
	            slugify: function slugify(text) {
	                return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
	            },
	            scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
	                if (value) {
	                    for (var i = 0, length = s.slides.length; i < length; i++) {
	                        var slide = s.slides.eq(i);
	                        var slideHistory = this.slugify(slide.attr('data-history'));
	                        if (slideHistory === value && !slide.hasClass(s.params.slideDuplicateClass)) {
	                            var index = slide.index();
	                            s.slideTo(index, speed, runCallbacks);
	                        }
	                    }
	                } else {
	                    s.slideTo(0, speed, runCallbacks);
	                }
	            }
	        };
	
	        /*=========================
	          Keyboard Control
	          ===========================*/
	        function handleKeyboard(e) {
	            if (e.originalEvent) e = e.originalEvent; //jquery fix
	            var kc = e.keyCode || e.charCode;
	            // Directions locks
	            if (!s.params.allowSwipeToNext && (s.isHorizontal() && kc === 39 || !s.isHorizontal() && kc === 40)) {
	                return false;
	            }
	            if (!s.params.allowSwipeToPrev && (s.isHorizontal() && kc === 37 || !s.isHorizontal() && kc === 38)) {
	                return false;
	            }
	            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
	                return;
	            }
	            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
	                return;
	            }
	            if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
	                var inView = false;
	                //Check that swiper should be inside of visible area of window
	                if (s.container.parents('.' + s.params.slideClass).length > 0 && s.container.parents('.' + s.params.slideActiveClass).length === 0) {
	                    return;
	                }
	                var windowScroll = {
	                    left: window.pageXOffset,
	                    top: window.pageYOffset
	                };
	                var windowWidth = window.innerWidth;
	                var windowHeight = window.innerHeight;
	                var swiperOffset = s.container.offset();
	                if (s.rtl) swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
	                var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + s.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + s.height], [swiperOffset.left + s.width, swiperOffset.top + s.height]];
	                for (var i = 0; i < swiperCoord.length; i++) {
	                    var point = swiperCoord[i];
	                    if (point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight) {
	                        inView = true;
	                    }
	                }
	                if (!inView) return;
	            }
	            if (s.isHorizontal()) {
	                if (kc === 37 || kc === 39) {
	                    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	                }
	                if (kc === 39 && !s.rtl || kc === 37 && s.rtl) s.slideNext();
	                if (kc === 37 && !s.rtl || kc === 39 && s.rtl) s.slidePrev();
	            } else {
	                if (kc === 38 || kc === 40) {
	                    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	                }
	                if (kc === 40) s.slideNext();
	                if (kc === 38) s.slidePrev();
	            }
	            s.emit('onKeyPress', s, kc);
	        }
	        s.disableKeyboardControl = function () {
	            s.params.keyboardControl = false;
	            $(document).off('keydown', handleKeyboard);
	        };
	        s.enableKeyboardControl = function () {
	            s.params.keyboardControl = true;
	            $(document).on('keydown', handleKeyboard);
	        };
	
	        /*=========================
	          Mousewheel Control
	          ===========================*/
	        s.mousewheel = {
	            event: false,
	            lastScrollTime: new window.Date().getTime()
	        };
	        function isEventSupported() {
	            var eventName = 'onwheel';
	            var isSupported = eventName in document;
	
	            if (!isSupported) {
	                var element = document.createElement('div');
	                element.setAttribute(eventName, 'return;');
	                isSupported = typeof element[eventName] === 'function';
	            }
	
	            if (!isSupported && document.implementation && document.implementation.hasFeature &&
	            // always returns true in newer browsers as per the standard.
	            // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	            document.implementation.hasFeature('', '') !== true) {
	                // This is the only way to test support for the `wheel` event in IE9+.
	                isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	            }
	
	            return isSupported;
	        }
	        /**
	         * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
	         * complicated, thus this doc is long and (hopefully) detailed enough to answer
	         * your questions.
	         *
	         * If you need to react to the mouse wheel in a predictable way, this code is
	         * like your bestest friend. * hugs *
	         *
	         * As of today, there are 4 DOM event types you can listen to:
	         *
	         *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
	         *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
	         *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
	         *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
	         *
	         * So what to do?  The is the best:
	         *
	         *   normalizeWheel.getEventType();
	         *
	         * In your event callback, use this code to get sane interpretation of the
	         * deltas.  This code will return an object with properties:
	         *
	         *   spinX   -- normalized spin speed (use for zoom) - x plane
	         *   spinY   -- " - y plane
	         *   pixelX  -- normalized distance (to pixels) - x plane
	         *   pixelY  -- " - y plane
	         *
	         * Wheel values are provided by the browser assuming you are using the wheel to
	         * scroll a web page by a number of lines or pixels (or pages).  Values can vary
	         * significantly on different platforms and browsers, forgetting that you can
	         * scroll at different speeds.  Some devices (like trackpads) emit more events
	         * at smaller increments with fine granularity, and some emit massive jumps with
	         * linear speed or acceleration.
	         *
	         * This code does its best to normalize the deltas for you:
	         *
	         *   - spin is trying to normalize how far the wheel was spun (or trackpad
	         *     dragged).  This is super useful for zoom support where you want to
	         *     throw away the chunky scroll steps on the PC and make those equal to
	         *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
	         *     resolve a single slow step on a wheel to 1.
	         *
	         *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
	         *     get the crazy differences between browsers, but at least it'll be in
	         *     pixels!
	         *
	         *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
	         *     should translate to positive value zooming IN, negative zooming OUT.
	         *     This matches the newer 'wheel' event.
	         *
	         * Why are there spinX, spinY (or pixels)?
	         *
	         *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
	         *     with a mouse.  It results in side-scrolling in the browser by default.
	         *
	         *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
	         *
	         *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
	         *     probably is by browsers in conjunction with fancy 3D controllers .. but
	         *     you know.
	         *
	         * Implementation info:
	         *
	         * Examples of 'wheel' event if you scroll slowly (down) by one step with an
	         * average mouse:
	         *
	         *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
	         *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
	         *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
	         *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
	         *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
	         *
	         * On the trackpad:
	         *
	         *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
	         *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
	         *
	         * On other/older browsers.. it's more complicated as there can be multiple and
	         * also missing delta values.
	         *
	         * The 'wheel' event is more standard:
	         *
	         * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
	         *
	         * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
	         * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
	         * backward compatibility with older events.  Those other values help us
	         * better normalize spin speed.  Example of what the browsers provide:
	         *
	         *                          | event.wheelDelta | event.detail
	         *        ------------------+------------------+--------------
	         *          Safari v5/OS X  |       -120       |       0
	         *          Safari v5/Win7  |       -120       |       0
	         *         Chrome v17/OS X  |       -120       |       0
	         *         Chrome v17/Win7  |       -120       |       0
	         *                IE9/Win7  |       -120       |   undefined
	         *         Firefox v4/OS X  |     undefined    |       1
	         *         Firefox v4/Win7  |     undefined    |       3
	         *
	         */
	        function normalizeWheel( /*object*/event) /*object*/{
	            // Reasonable defaults
	            var PIXEL_STEP = 10;
	            var LINE_HEIGHT = 40;
	            var PAGE_HEIGHT = 800;
	
	            var sX = 0,
	                sY = 0,
	                // spinX, spinY
	            pX = 0,
	                pY = 0; // pixelX, pixelY
	
	            // Legacy
	            if ('detail' in event) {
	                sY = event.detail;
	            }
	            if ('wheelDelta' in event) {
	                sY = -event.wheelDelta / 120;
	            }
	            if ('wheelDeltaY' in event) {
	                sY = -event.wheelDeltaY / 120;
	            }
	            if ('wheelDeltaX' in event) {
	                sX = -event.wheelDeltaX / 120;
	            }
	
	            // side scrolling on FF with DOMMouseScroll
	            if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
	                sX = sY;
	                sY = 0;
	            }
	
	            pX = sX * PIXEL_STEP;
	            pY = sY * PIXEL_STEP;
	
	            if ('deltaY' in event) {
	                pY = event.deltaY;
	            }
	            if ('deltaX' in event) {
	                pX = event.deltaX;
	            }
	
	            if ((pX || pY) && event.deltaMode) {
	                if (event.deltaMode === 1) {
	                    // delta in LINE units
	                    pX *= LINE_HEIGHT;
	                    pY *= LINE_HEIGHT;
	                } else {
	                    // delta in PAGE units
	                    pX *= PAGE_HEIGHT;
	                    pY *= PAGE_HEIGHT;
	                }
	            }
	
	            // Fall-back if spin cannot be determined
	            if (pX && !sX) {
	                sX = pX < 1 ? -1 : 1;
	            }
	            if (pY && !sY) {
	                sY = pY < 1 ? -1 : 1;
	            }
	
	            return {
	                spinX: sX,
	                spinY: sY,
	                pixelX: pX,
	                pixelY: pY
	            };
	        }
	        if (s.params.mousewheelControl) {
	            /**
	             * The best combination if you prefer spinX + spinY normalization.  It favors
	             * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
	             * 'wheel' event, making spin speed determination impossible.
	             */
	            s.mousewheel.event = navigator.userAgent.indexOf('firefox') > -1 ? 'DOMMouseScroll' : isEventSupported() ? 'wheel' : 'mousewheel';
	        }
	        function handleMousewheel(e) {
	            if (e.originalEvent) e = e.originalEvent; //jquery fix
	            var delta = 0;
	            var rtlFactor = s.rtl ? -1 : 1;
	
	            var data = normalizeWheel(e);
	
	            if (s.params.mousewheelForceToAxis) {
	                if (s.isHorizontal()) {
	                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;else return;
	                } else {
	                    if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;else return;
	                }
	            } else {
	                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
	            }
	
	            if (delta === 0) return;
	
	            if (s.params.mousewheelInvert) delta = -delta;
	
	            if (!s.params.freeMode) {
	                if (new window.Date().getTime() - s.mousewheel.lastScrollTime > 60) {
	                    if (delta < 0) {
	                        if ((!s.isEnd || s.params.loop) && !s.animating) {
	                            s.slideNext();
	                            s.emit('onScroll', s, e);
	                        } else if (s.params.mousewheelReleaseOnEdges) return true;
	                    } else {
	                        if ((!s.isBeginning || s.params.loop) && !s.animating) {
	                            s.slidePrev();
	                            s.emit('onScroll', s, e);
	                        } else if (s.params.mousewheelReleaseOnEdges) return true;
	                    }
	                }
	                s.mousewheel.lastScrollTime = new window.Date().getTime();
	            } else {
	                //Freemode or scrollContainer:
	                var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
	                var wasBeginning = s.isBeginning,
	                    wasEnd = s.isEnd;
	
	                if (position >= s.minTranslate()) position = s.minTranslate();
	                if (position <= s.maxTranslate()) position = s.maxTranslate();
	
	                s.setWrapperTransition(0);
	                s.setWrapperTranslate(position);
	                s.updateProgress();
	                s.updateActiveIndex();
	
	                if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
	                    s.updateClasses();
	                }
	
	                if (s.params.freeModeSticky) {
	                    clearTimeout(s.mousewheel.timeout);
	                    s.mousewheel.timeout = setTimeout(function () {
	                        s.slideReset();
	                    }, 300);
	                } else {
	                    if (s.params.lazyLoading && s.lazy) {
	                        s.lazy.load();
	                    }
	                }
	                // Emit event
	                s.emit('onScroll', s, e);
	
	                // Stop autoplay
	                if (s.params.autoplay && s.params.autoplayDisableOnInteraction) s.stopAutoplay();
	
	                // Return page scroll on edge positions
	                if (position === 0 || position === s.maxTranslate()) return;
	            }
	
	            if (e.preventDefault) e.preventDefault();else e.returnValue = false;
	            return false;
	        }
	        s.disableMousewheelControl = function () {
	            if (!s.mousewheel.event) return false;
	            var target = s.container;
	            if (s.params.mousewheelEventsTarged !== 'container') {
	                target = $(s.params.mousewheelEventsTarged);
	            }
	            target.off(s.mousewheel.event, handleMousewheel);
	            s.params.mousewheelControl = false;
	            return true;
	        };
	
	        s.enableMousewheelControl = function () {
	            if (!s.mousewheel.event) return false;
	            var target = s.container;
	            if (s.params.mousewheelEventsTarged !== 'container') {
	                target = $(s.params.mousewheelEventsTarged);
	            }
	            target.on(s.mousewheel.event, handleMousewheel);
	            s.params.mousewheelControl = true;
	            return true;
	        };
	
	        /*=========================
	          Parallax
	          ===========================*/
	        function setParallaxTransform(el, progress) {
	            el = $(el);
	            var p, pX, pY;
	            var rtlFactor = s.rtl ? -1 : 1;
	
	            p = el.attr('data-swiper-parallax') || '0';
	            pX = el.attr('data-swiper-parallax-x');
	            pY = el.attr('data-swiper-parallax-y');
	            if (pX || pY) {
	                pX = pX || '0';
	                pY = pY || '0';
	            } else {
	                if (s.isHorizontal()) {
	                    pX = p;
	                    pY = '0';
	                } else {
	                    pY = p;
	                    pX = '0';
	                }
	            }
	
	            if (pX.indexOf('%') >= 0) {
	                pX = parseInt(pX, 10) * progress * rtlFactor + '%';
	            } else {
	                pX = pX * progress * rtlFactor + 'px';
	            }
	            if (pY.indexOf('%') >= 0) {
	                pY = parseInt(pY, 10) * progress + '%';
	            } else {
	                pY = pY * progress + 'px';
	            }
	
	            el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
	        }
	        s.parallax = {
	            setTranslate: function setTranslate() {
	                s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
	                    setParallaxTransform(this, s.progress);
	                });
	                s.slides.each(function () {
	                    var slide = $(this);
	                    slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
	                        var progress = Math.min(Math.max(slide[0].progress, -1), 1);
	                        setParallaxTransform(this, progress);
	                    });
	                });
	            },
	            setTransition: function setTransition(duration) {
	                if (typeof duration === 'undefined') duration = s.params.speed;
	                s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
	                    var el = $(this);
	                    var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
	                    if (duration === 0) parallaxDuration = 0;
	                    el.transition(parallaxDuration);
	                });
	            }
	        };
	
	        /*=========================
	          Zoom
	          ===========================*/
	        s.zoom = {
	            // "Global" Props
	            scale: 1,
	            currentScale: 1,
	            isScaling: false,
	            gesture: {
	                slide: undefined,
	                slideWidth: undefined,
	                slideHeight: undefined,
	                image: undefined,
	                imageWrap: undefined,
	                zoomMax: s.params.zoomMax
	            },
	            image: {
	                isTouched: undefined,
	                isMoved: undefined,
	                currentX: undefined,
	                currentY: undefined,
	                minX: undefined,
	                minY: undefined,
	                maxX: undefined,
	                maxY: undefined,
	                width: undefined,
	                height: undefined,
	                startX: undefined,
	                startY: undefined,
	                touchesStart: {},
	                touchesCurrent: {}
	            },
	            velocity: {
	                x: undefined,
	                y: undefined,
	                prevPositionX: undefined,
	                prevPositionY: undefined,
	                prevTime: undefined
	            },
	            // Calc Scale From Multi-touches
	            getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
	                if (e.targetTouches.length < 2) return 1;
	                var x1 = e.targetTouches[0].pageX,
	                    y1 = e.targetTouches[0].pageY,
	                    x2 = e.targetTouches[1].pageX,
	                    y2 = e.targetTouches[1].pageY;
	                var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
	                return distance;
	            },
	            // Events
	            onGestureStart: function onGestureStart(e) {
	                var z = s.zoom;
	                if (!s.support.gestures) {
	                    if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
	                        return;
	                    }
	                    z.gesture.scaleStart = z.getDistanceBetweenTouches(e);
	                }
	                if (!z.gesture.slide || !z.gesture.slide.length) {
	                    z.gesture.slide = $(this);
	                    if (z.gesture.slide.length === 0) z.gesture.slide = s.slides.eq(s.activeIndex);
	                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
	                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
	                    z.gesture.zoomMax = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax;
	                    if (z.gesture.imageWrap.length === 0) {
	                        z.gesture.image = undefined;
	                        return;
	                    }
	                }
	                z.gesture.image.transition(0);
	                z.isScaling = true;
	            },
	            onGestureChange: function onGestureChange(e) {
	                var z = s.zoom;
	                if (!s.support.gestures) {
	                    if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
	                        return;
	                    }
	                    z.gesture.scaleMove = z.getDistanceBetweenTouches(e);
	                }
	                if (!z.gesture.image || z.gesture.image.length === 0) return;
	                if (s.support.gestures) {
	                    z.scale = e.scale * z.currentScale;
	                } else {
	                    z.scale = z.gesture.scaleMove / z.gesture.scaleStart * z.currentScale;
	                }
	                if (z.scale > z.gesture.zoomMax) {
	                    z.scale = z.gesture.zoomMax - 1 + Math.pow(z.scale - z.gesture.zoomMax + 1, 0.5);
	                }
	                if (z.scale < s.params.zoomMin) {
	                    z.scale = s.params.zoomMin + 1 - Math.pow(s.params.zoomMin - z.scale + 1, 0.5);
	                }
	                z.gesture.image.transform('translate3d(0,0,0) scale(' + z.scale + ')');
	            },
	            onGestureEnd: function onGestureEnd(e) {
	                var z = s.zoom;
	                if (!s.support.gestures) {
	                    if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2) {
	                        return;
	                    }
	                }
	                if (!z.gesture.image || z.gesture.image.length === 0) return;
	                z.scale = Math.max(Math.min(z.scale, z.gesture.zoomMax), s.params.zoomMin);
	                z.gesture.image.transition(s.params.speed).transform('translate3d(0,0,0) scale(' + z.scale + ')');
	                z.currentScale = z.scale;
	                z.isScaling = false;
	                if (z.scale === 1) z.gesture.slide = undefined;
	            },
	            onTouchStart: function onTouchStart(s, e) {
	                var z = s.zoom;
	                if (!z.gesture.image || z.gesture.image.length === 0) return;
	                if (z.image.isTouched) return;
	                if (s.device.os === 'android') e.preventDefault();
	                z.image.isTouched = true;
	                z.image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	                z.image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	            },
	            onTouchMove: function onTouchMove(e) {
	                var z = s.zoom;
	                if (!z.gesture.image || z.gesture.image.length === 0) return;
	                s.allowClick = false;
	                if (!z.image.isTouched || !z.gesture.slide) return;
	
	                if (!z.image.isMoved) {
	                    z.image.width = z.gesture.image[0].offsetWidth;
	                    z.image.height = z.gesture.image[0].offsetHeight;
	                    z.image.startX = s.getTranslate(z.gesture.imageWrap[0], 'x') || 0;
	                    z.image.startY = s.getTranslate(z.gesture.imageWrap[0], 'y') || 0;
	                    z.gesture.slideWidth = z.gesture.slide[0].offsetWidth;
	                    z.gesture.slideHeight = z.gesture.slide[0].offsetHeight;
	                    z.gesture.imageWrap.transition(0);
	                    if (s.rtl) z.image.startX = -z.image.startX;
	                    if (s.rtl) z.image.startY = -z.image.startY;
	                }
	                // Define if we need image drag
	                var scaledWidth = z.image.width * z.scale;
	                var scaledHeight = z.image.height * z.scale;
	
	                if (scaledWidth < z.gesture.slideWidth && scaledHeight < z.gesture.slideHeight) return;
	
	                z.image.minX = Math.min(z.gesture.slideWidth / 2 - scaledWidth / 2, 0);
	                z.image.maxX = -z.image.minX;
	                z.image.minY = Math.min(z.gesture.slideHeight / 2 - scaledHeight / 2, 0);
	                z.image.maxY = -z.image.minY;
	
	                z.image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	                z.image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	
	                if (!z.image.isMoved && !z.isScaling) {
	                    if (s.isHorizontal() && Math.floor(z.image.minX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x < z.image.touchesStart.x || Math.floor(z.image.maxX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x > z.image.touchesStart.x) {
	                        z.image.isTouched = false;
	                        return;
	                    } else if (!s.isHorizontal() && Math.floor(z.image.minY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y < z.image.touchesStart.y || Math.floor(z.image.maxY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y > z.image.touchesStart.y) {
	                        z.image.isTouched = false;
	                        return;
	                    }
	                }
	                e.preventDefault();
	                e.stopPropagation();
	
	                z.image.isMoved = true;
	                z.image.currentX = z.image.touchesCurrent.x - z.image.touchesStart.x + z.image.startX;
	                z.image.currentY = z.image.touchesCurrent.y - z.image.touchesStart.y + z.image.startY;
	
	                if (z.image.currentX < z.image.minX) {
	                    z.image.currentX = z.image.minX + 1 - Math.pow(z.image.minX - z.image.currentX + 1, 0.8);
	                }
	                if (z.image.currentX > z.image.maxX) {
	                    z.image.currentX = z.image.maxX - 1 + Math.pow(z.image.currentX - z.image.maxX + 1, 0.8);
	                }
	
	                if (z.image.currentY < z.image.minY) {
	                    z.image.currentY = z.image.minY + 1 - Math.pow(z.image.minY - z.image.currentY + 1, 0.8);
	                }
	                if (z.image.currentY > z.image.maxY) {
	                    z.image.currentY = z.image.maxY - 1 + Math.pow(z.image.currentY - z.image.maxY + 1, 0.8);
	                }
	
	                //Velocity
	                if (!z.velocity.prevPositionX) z.velocity.prevPositionX = z.image.touchesCurrent.x;
	                if (!z.velocity.prevPositionY) z.velocity.prevPositionY = z.image.touchesCurrent.y;
	                if (!z.velocity.prevTime) z.velocity.prevTime = Date.now();
	                z.velocity.x = (z.image.touchesCurrent.x - z.velocity.prevPositionX) / (Date.now() - z.velocity.prevTime) / 2;
	                z.velocity.y = (z.image.touchesCurrent.y - z.velocity.prevPositionY) / (Date.now() - z.velocity.prevTime) / 2;
	                if (Math.abs(z.image.touchesCurrent.x - z.velocity.prevPositionX) < 2) z.velocity.x = 0;
	                if (Math.abs(z.image.touchesCurrent.y - z.velocity.prevPositionY) < 2) z.velocity.y = 0;
	                z.velocity.prevPositionX = z.image.touchesCurrent.x;
	                z.velocity.prevPositionY = z.image.touchesCurrent.y;
	                z.velocity.prevTime = Date.now();
	
	                z.gesture.imageWrap.transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
	            },
	            onTouchEnd: function onTouchEnd(s, e) {
	                var z = s.zoom;
	                if (!z.gesture.image || z.gesture.image.length === 0) return;
	                if (!z.image.isTouched || !z.image.isMoved) {
	                    z.image.isTouched = false;
	                    z.image.isMoved = false;
	                    return;
	                }
	                z.image.isTouched = false;
	                z.image.isMoved = false;
	                var momentumDurationX = 300;
	                var momentumDurationY = 300;
	                var momentumDistanceX = z.velocity.x * momentumDurationX;
	                var newPositionX = z.image.currentX + momentumDistanceX;
	                var momentumDistanceY = z.velocity.y * momentumDurationY;
	                var newPositionY = z.image.currentY + momentumDistanceY;
	
	                //Fix duration
	                if (z.velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - z.image.currentX) / z.velocity.x);
	                if (z.velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - z.image.currentY) / z.velocity.y);
	                var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
	
	                z.image.currentX = newPositionX;
	                z.image.currentY = newPositionY;
	
	                // Define if we need image drag
	                var scaledWidth = z.image.width * z.scale;
	                var scaledHeight = z.image.height * z.scale;
	                z.image.minX = Math.min(z.gesture.slideWidth / 2 - scaledWidth / 2, 0);
	                z.image.maxX = -z.image.minX;
	                z.image.minY = Math.min(z.gesture.slideHeight / 2 - scaledHeight / 2, 0);
	                z.image.maxY = -z.image.minY;
	                z.image.currentX = Math.max(Math.min(z.image.currentX, z.image.maxX), z.image.minX);
	                z.image.currentY = Math.max(Math.min(z.image.currentY, z.image.maxY), z.image.minY);
	
	                z.gesture.imageWrap.transition(momentumDuration).transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
	            },
	            onTransitionEnd: function onTransitionEnd(s) {
	                var z = s.zoom;
	                if (z.gesture.slide && s.previousIndex !== s.activeIndex) {
	                    z.gesture.image.transform('translate3d(0,0,0) scale(1)');
	                    z.gesture.imageWrap.transform('translate3d(0,0,0)');
	                    z.gesture.slide = z.gesture.image = z.gesture.imageWrap = undefined;
	                    z.scale = z.currentScale = 1;
	                }
	            },
	            // Toggle Zoom
	            toggleZoom: function toggleZoom(s, e) {
	                var z = s.zoom;
	                if (!z.gesture.slide) {
	                    z.gesture.slide = s.clickedSlide ? $(s.clickedSlide) : s.slides.eq(s.activeIndex);
	                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
	                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
	                }
	                if (!z.gesture.image || z.gesture.image.length === 0) return;
	
	                var touchX, touchY, offsetX, offsetY, diffX, diffY, translateX, translateY, imageWidth, imageHeight, scaledWidth, scaledHeight, translateMinX, translateMinY, translateMaxX, translateMaxY, slideWidth, slideHeight;
	
	                if (typeof z.image.touchesStart.x === 'undefined' && e) {
	                    touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
	                    touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
	                } else {
	                    touchX = z.image.touchesStart.x;
	                    touchY = z.image.touchesStart.y;
	                }
	
	                if (z.scale && z.scale !== 1) {
	                    // Zoom Out
	                    z.scale = z.currentScale = 1;
	                    z.gesture.imageWrap.transition(300).transform('translate3d(0,0,0)');
	                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(1)');
	                    z.gesture.slide = undefined;
	                } else {
	                    // Zoom In
	                    z.scale = z.currentScale = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax;
	                    if (e) {
	                        slideWidth = z.gesture.slide[0].offsetWidth;
	                        slideHeight = z.gesture.slide[0].offsetHeight;
	                        offsetX = z.gesture.slide.offset().left;
	                        offsetY = z.gesture.slide.offset().top;
	                        diffX = offsetX + slideWidth / 2 - touchX;
	                        diffY = offsetY + slideHeight / 2 - touchY;
	
	                        imageWidth = z.gesture.image[0].offsetWidth;
	                        imageHeight = z.gesture.image[0].offsetHeight;
	                        scaledWidth = imageWidth * z.scale;
	                        scaledHeight = imageHeight * z.scale;
	
	                        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
	                        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
	                        translateMaxX = -translateMinX;
	                        translateMaxY = -translateMinY;
	
	                        translateX = diffX * z.scale;
	                        translateY = diffY * z.scale;
	
	                        if (translateX < translateMinX) {
	                            translateX = translateMinX;
	                        }
	                        if (translateX > translateMaxX) {
	                            translateX = translateMaxX;
	                        }
	
	                        if (translateY < translateMinY) {
	                            translateY = translateMinY;
	                        }
	                        if (translateY > translateMaxY) {
	                            translateY = translateMaxY;
	                        }
	                    } else {
	                        translateX = 0;
	                        translateY = 0;
	                    }
	                    z.gesture.imageWrap.transition(300).transform('translate3d(' + translateX + 'px, ' + translateY + 'px,0)');
	                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(' + z.scale + ')');
	                }
	            },
	            // Attach/Detach Events
	            attachEvents: function attachEvents(detach) {
	                var action = detach ? 'off' : 'on';
	
	                if (s.params.zoom) {
	                    var target = s.slides;
	                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? { passive: true, capture: false } : false;
	                    // Scale image
	                    if (s.support.gestures) {
	                        s.slides[action]('gesturestart', s.zoom.onGestureStart, passiveListener);
	                        s.slides[action]('gesturechange', s.zoom.onGestureChange, passiveListener);
	                        s.slides[action]('gestureend', s.zoom.onGestureEnd, passiveListener);
	                    } else if (s.touchEvents.start === 'touchstart') {
	                        s.slides[action](s.touchEvents.start, s.zoom.onGestureStart, passiveListener);
	                        s.slides[action](s.touchEvents.move, s.zoom.onGestureChange, passiveListener);
	                        s.slides[action](s.touchEvents.end, s.zoom.onGestureEnd, passiveListener);
	                    }
	
	                    // Move image
	                    s[action]('touchStart', s.zoom.onTouchStart);
	                    s.slides.each(function (index, slide) {
	                        if ($(slide).find('.' + s.params.zoomContainerClass).length > 0) {
	                            $(slide)[action](s.touchEvents.move, s.zoom.onTouchMove);
	                        }
	                    });
	                    s[action]('touchEnd', s.zoom.onTouchEnd);
	
	                    // Scale Out
	                    s[action]('transitionEnd', s.zoom.onTransitionEnd);
	                    if (s.params.zoomToggle) {
	                        s.on('doubleTap', s.zoom.toggleZoom);
	                    }
	                }
	            },
	            init: function init() {
	                s.zoom.attachEvents();
	            },
	            destroy: function destroy() {
	                s.zoom.attachEvents(true);
	            }
	        };
	
	        /*=========================
	          Plugins API. Collect all and init all plugins
	          ===========================*/
	        s._plugins = [];
	        for (var plugin in s.plugins) {
	            var p = s.plugins[plugin](s, s.params[plugin]);
	            if (p) s._plugins.push(p);
	        }
	        // Method to call all plugins event/method
	        s.callPlugins = function (eventName) {
	            for (var i = 0; i < s._plugins.length; i++) {
	                if (eventName in s._plugins[i]) {
	                    s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	                }
	            }
	        };
	
	        /*=========================
	          Events/Callbacks/Plugins Emitter
	          ===========================*/
	        function normalizeEventName(eventName) {
	            if (eventName.indexOf('on') !== 0) {
	                if (eventName[0] !== eventName[0].toUpperCase()) {
	                    eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
	                } else {
	                    eventName = 'on' + eventName;
	                }
	            }
	            return eventName;
	        }
	        s.emitterEventListeners = {};
	        s.emit = function (eventName) {
	            // Trigger callbacks
	            if (s.params[eventName]) {
	                s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	            }
	            var i;
	            // Trigger events
	            if (s.emitterEventListeners[eventName]) {
	                for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
	                    s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	                }
	            }
	            // Trigger plugins
	            if (s.callPlugins) s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	        };
	        s.on = function (eventName, handler) {
	            eventName = normalizeEventName(eventName);
	            if (!s.emitterEventListeners[eventName]) s.emitterEventListeners[eventName] = [];
	            s.emitterEventListeners[eventName].push(handler);
	            return s;
	        };
	        s.off = function (eventName, handler) {
	            var i;
	            eventName = normalizeEventName(eventName);
	            if (typeof handler === 'undefined') {
	                // Remove all handlers for such event
	                s.emitterEventListeners[eventName] = [];
	                return s;
	            }
	            if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0) return;
	            for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
	                if (s.emitterEventListeners[eventName][i] === handler) s.emitterEventListeners[eventName].splice(i, 1);
	            }
	            return s;
	        };
	        s.once = function (eventName, handler) {
	            eventName = normalizeEventName(eventName);
	            var _handler = function _handler() {
	                handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
	                s.off(eventName, _handler);
	            };
	            s.on(eventName, _handler);
	            return s;
	        };
	
	        // Accessibility tools
	        s.a11y = {
	            makeFocusable: function makeFocusable($el) {
	                $el.attr('tabIndex', '0');
	                return $el;
	            },
	            addRole: function addRole($el, role) {
	                $el.attr('role', role);
	                return $el;
	            },
	
	            addLabel: function addLabel($el, label) {
	                $el.attr('aria-label', label);
	                return $el;
	            },
	
	            disable: function disable($el) {
	                $el.attr('aria-disabled', true);
	                return $el;
	            },
	
	            enable: function enable($el) {
	                $el.attr('aria-disabled', false);
	                return $el;
	            },
	
	            onEnterKey: function onEnterKey(event) {
	                if (event.keyCode !== 13) return;
	                if ($(event.target).is(s.params.nextButton)) {
	                    s.onClickNext(event);
	                    if (s.isEnd) {
	                        s.a11y.notify(s.params.lastSlideMessage);
	                    } else {
	                        s.a11y.notify(s.params.nextSlideMessage);
	                    }
	                } else if ($(event.target).is(s.params.prevButton)) {
	                    s.onClickPrev(event);
	                    if (s.isBeginning) {
	                        s.a11y.notify(s.params.firstSlideMessage);
	                    } else {
	                        s.a11y.notify(s.params.prevSlideMessage);
	                    }
	                }
	                if ($(event.target).is('.' + s.params.bulletClass)) {
	                    $(event.target)[0].click();
	                }
	            },
	
	            liveRegion: $('<span class="' + s.params.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>'),
	
	            notify: function notify(message) {
	                var notification = s.a11y.liveRegion;
	                if (notification.length === 0) return;
	                notification.html('');
	                notification.html(message);
	            },
	            init: function init() {
	                // Setup accessibility
	                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
	                    s.a11y.makeFocusable(s.nextButton);
	                    s.a11y.addRole(s.nextButton, 'button');
	                    s.a11y.addLabel(s.nextButton, s.params.nextSlideMessage);
	                }
	                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
	                    s.a11y.makeFocusable(s.prevButton);
	                    s.a11y.addRole(s.prevButton, 'button');
	                    s.a11y.addLabel(s.prevButton, s.params.prevSlideMessage);
	                }
	
	                $(s.container).append(s.a11y.liveRegion);
	            },
	            initPagination: function initPagination() {
	                if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
	                    s.bullets.each(function () {
	                        var bullet = $(this);
	                        s.a11y.makeFocusable(bullet);
	                        s.a11y.addRole(bullet, 'button');
	                        s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
	                    });
	                }
	            },
	            destroy: function destroy() {
	                if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0) s.a11y.liveRegion.remove();
	            }
	        };
	
	        /*=========================
	          Init/Destroy
	          ===========================*/
	        s.init = function () {
	            if (s.params.loop) s.createLoop();
	            s.updateContainerSize();
	            s.updateSlidesSize();
	            s.updatePagination();
	            if (s.params.scrollbar && s.scrollbar) {
	                s.scrollbar.set();
	                if (s.params.scrollbarDraggable) {
	                    s.scrollbar.enableDraggable();
	                }
	            }
	            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
	                if (!s.params.loop) s.updateProgress();
	                s.effects[s.params.effect].setTranslate();
	            }
	            if (s.params.loop) {
	                s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
	            } else {
	                s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
	                if (s.params.initialSlide === 0) {
	                    if (s.parallax && s.params.parallax) s.parallax.setTranslate();
	                    if (s.lazy && s.params.lazyLoading) {
	                        s.lazy.load();
	                        s.lazy.initialImageLoaded = true;
	                    }
	                }
	            }
	            s.attachEvents();
	            if (s.params.observer && s.support.observer) {
	                s.initObservers();
	            }
	            if (s.params.preloadImages && !s.params.lazyLoading) {
	                s.preloadImages();
	            }
	            if (s.params.zoom && s.zoom) {
	                s.zoom.init();
	            }
	            if (s.params.autoplay) {
	                s.startAutoplay();
	            }
	            if (s.params.keyboardControl) {
	                if (s.enableKeyboardControl) s.enableKeyboardControl();
	            }
	            if (s.params.mousewheelControl) {
	                if (s.enableMousewheelControl) s.enableMousewheelControl();
	            }
	            // Deprecated hashnavReplaceState changed to replaceState for use in hashnav and history
	            if (s.params.hashnavReplaceState) {
	                s.params.replaceState = s.params.hashnavReplaceState;
	            }
	            if (s.params.history) {
	                if (s.history) s.history.init();
	            }
	            if (s.params.hashnav) {
	                if (s.hashnav) s.hashnav.init();
	            }
	            if (s.params.a11y && s.a11y) s.a11y.init();
	            s.emit('onInit', s);
	        };
	
	        // Cleanup dynamic styles
	        s.cleanupStyles = function () {
	            // Container
	            s.container.removeClass(s.classNames.join(' ')).removeAttr('style');
	
	            // Wrapper
	            s.wrapper.removeAttr('style');
	
	            // Slides
	            if (s.slides && s.slides.length) {
	                s.slides.removeClass([s.params.slideVisibleClass, s.params.slideActiveClass, s.params.slideNextClass, s.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row');
	            }
	
	            // Pagination/Bullets
	            if (s.paginationContainer && s.paginationContainer.length) {
	                s.paginationContainer.removeClass(s.params.paginationHiddenClass);
	            }
	            if (s.bullets && s.bullets.length) {
	                s.bullets.removeClass(s.params.bulletActiveClass);
	            }
	
	            // Buttons
	            if (s.params.prevButton) $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
	            if (s.params.nextButton) $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
	
	            // Scrollbar
	            if (s.params.scrollbar && s.scrollbar) {
	                if (s.scrollbar.track && s.scrollbar.track.length) s.scrollbar.track.removeAttr('style');
	                if (s.scrollbar.drag && s.scrollbar.drag.length) s.scrollbar.drag.removeAttr('style');
	            }
	        };
	
	        // Destroy
	        s.destroy = function (deleteInstance, cleanupStyles) {
	            // Detach evebts
	            s.detachEvents();
	            // Stop autoplay
	            s.stopAutoplay();
	            // Disable draggable
	            if (s.params.scrollbar && s.scrollbar) {
	                if (s.params.scrollbarDraggable) {
	                    s.scrollbar.disableDraggable();
	                }
	            }
	            // Destroy loop
	            if (s.params.loop) {
	                s.destroyLoop();
	            }
	            // Cleanup styles
	            if (cleanupStyles) {
	                s.cleanupStyles();
	            }
	            // Disconnect observer
	            s.disconnectObservers();
	
	            // Destroy zoom
	            if (s.params.zoom && s.zoom) {
	                s.zoom.destroy();
	            }
	            // Disable keyboard/mousewheel
	            if (s.params.keyboardControl) {
	                if (s.disableKeyboardControl) s.disableKeyboardControl();
	            }
	            if (s.params.mousewheelControl) {
	                if (s.disableMousewheelControl) s.disableMousewheelControl();
	            }
	            // Disable a11y
	            if (s.params.a11y && s.a11y) s.a11y.destroy();
	            // Delete history popstate
	            if (s.params.history && !s.params.replaceState) {
	                window.removeEventListener('popstate', s.history.setHistoryPopState);
	            }
	            if (s.params.hashnav && s.hashnav) {
	                s.hashnav.destroy();
	            }
	            // Destroy callback
	            s.emit('onDestroy');
	            // Delete instance
	            if (deleteInstance !== false) s = null;
	        };
	
	        s.init();
	
	        // Return swiper instance
	        return s;
	    };
	
	    /*==================================================
	        Prototype
	    ====================================================*/
	    Swiper.prototype = {
	        isSafari: function () {
	            var ua = window.navigator.userAgent.toLowerCase();
	            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
	        }(),
	        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
	        isArray: function isArray(arr) {
	            return Object.prototype.toString.apply(arr) === '[object Array]';
	        },
	        /*==================================================
	        Browser
	        ====================================================*/
	        browser: {
	            ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
	            ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1,
	            lteIE9: function () {
	                // create temporary DIV
	                var div = document.createElement('div');
	                // add content to tmp DIV which is wrapped into the IE HTML conditional statement
	                div.innerHTML = '<!--[if lte IE 9]><i></i><![endif]-->';
	                // return true / false value based on what will browser render
	                return div.getElementsByTagName('i').length === 1;
	            }()
	        },
	        /*==================================================
	        Devices
	        ====================================================*/
	        device: function () {
	            var ua = window.navigator.userAgent;
	            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	            var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
	            return {
	                ios: ipad || iphone || ipod,
	                android: android
	            };
	        }(),
	        /*==================================================
	        Feature Detection
	        ====================================================*/
	        support: {
	            touch: window.Modernizr && Modernizr.touch === true || function () {
	                return !!('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);
	            }(),
	
	            transforms3d: window.Modernizr && Modernizr.csstransforms3d === true || function () {
	                var div = document.createElement('div').style;
	                return 'webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div;
	            }(),
	
	            flexbox: function () {
	                var div = document.createElement('div').style;
	                var styles = 'alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' ');
	                for (var i = 0; i < styles.length; i++) {
	                    if (styles[i] in div) return true;
	                }
	            }(),
	
	            observer: function () {
	                return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
	            }(),
	
	            passiveListener: function () {
	                var supportsPassive = false;
	                try {
	                    var opts = Object.defineProperty({}, 'passive', {
	                        get: function get() {
	                            supportsPassive = true;
	                        }
	                    });
	                    window.addEventListener('testPassiveListener', null, opts);
	                } catch (e) {}
	                return supportsPassive;
	            }(),
	
	            gestures: function () {
	                return 'ongesturestart' in window;
	            }()
	        },
	        /*==================================================
	        Plugins
	        ====================================================*/
	        plugins: {}
	    };
	
	    /*===========================
	    Dom7 Library
	    ===========================*/
	    var Dom7 = function () {
	        var Dom7 = function Dom7(arr) {
	            var _this = this,
	                i = 0;
	            // Create array-like object
	            for (i = 0; i < arr.length; i++) {
	                _this[i] = arr[i];
	            }
	            _this.length = arr.length;
	            // Return collection with methods
	            return this;
	        };
	        var $ = function $(selector, context) {
	            var arr = [],
	                i = 0;
	            if (selector && !context) {
	                if (selector instanceof Dom7) {
	                    return selector;
	                }
	            }
	            if (selector) {
	                // String
	                if (typeof selector === 'string') {
	                    var els,
	                        tempParent,
	                        html = selector.trim();
	                    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
	                        var toCreate = 'div';
	                        if (html.indexOf('<li') === 0) toCreate = 'ul';
	                        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
	                        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
	                        if (html.indexOf('<tbody') === 0) toCreate = 'table';
	                        if (html.indexOf('<option') === 0) toCreate = 'select';
	                        tempParent = document.createElement(toCreate);
	                        tempParent.innerHTML = selector;
	                        for (i = 0; i < tempParent.childNodes.length; i++) {
	                            arr.push(tempParent.childNodes[i]);
	                        }
	                    } else {
	                        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
	                            // Pure ID selector
	                            els = [document.getElementById(selector.split('#')[1])];
	                        } else {
	                            // Other selectors
	                            els = (context || document).querySelectorAll(selector);
	                        }
	                        for (i = 0; i < els.length; i++) {
	                            if (els[i]) arr.push(els[i]);
	                        }
	                    }
	                }
	                // Node/element
	                else if (selector.nodeType || selector === window || selector === document) {
	                        arr.push(selector);
	                    }
	                    //Array of elements or instance of Dom
	                    else if (selector.length > 0 && selector[0].nodeType) {
	                            for (i = 0; i < selector.length; i++) {
	                                arr.push(selector[i]);
	                            }
	                        }
	            }
	            return new Dom7(arr);
	        };
	        Dom7.prototype = {
	            // Classes and attriutes
	            addClass: function addClass(className) {
	                if (typeof className === 'undefined') {
	                    return this;
	                }
	                var classes = className.split(' ');
	                for (var i = 0; i < classes.length; i++) {
	                    for (var j = 0; j < this.length; j++) {
	                        this[j].classList.add(classes[i]);
	                    }
	                }
	                return this;
	            },
	            removeClass: function removeClass(className) {
	                var classes = className.split(' ');
	                for (var i = 0; i < classes.length; i++) {
	                    for (var j = 0; j < this.length; j++) {
	                        this[j].classList.remove(classes[i]);
	                    }
	                }
	                return this;
	            },
	            hasClass: function hasClass(className) {
	                if (!this[0]) return false;else return this[0].classList.contains(className);
	            },
	            toggleClass: function toggleClass(className) {
	                var classes = className.split(' ');
	                for (var i = 0; i < classes.length; i++) {
	                    for (var j = 0; j < this.length; j++) {
	                        this[j].classList.toggle(classes[i]);
	                    }
	                }
	                return this;
	            },
	            attr: function attr(attrs, value) {
	                if (arguments.length === 1 && typeof attrs === 'string') {
	                    // Get attr
	                    if (this[0]) return this[0].getAttribute(attrs);else return undefined;
	                } else {
	                    // Set attrs
	                    for (var i = 0; i < this.length; i++) {
	                        if (arguments.length === 2) {
	                            // String
	                            this[i].setAttribute(attrs, value);
	                        } else {
	                            // Object
	                            for (var attrName in attrs) {
	                                this[i][attrName] = attrs[attrName];
	                                this[i].setAttribute(attrName, attrs[attrName]);
	                            }
	                        }
	                    }
	                    return this;
	                }
	            },
	            removeAttr: function removeAttr(attr) {
	                for (var i = 0; i < this.length; i++) {
	                    this[i].removeAttribute(attr);
	                }
	                return this;
	            },
	            data: function data(key, value) {
	                if (typeof value === 'undefined') {
	                    // Get value
	                    if (this[0]) {
	                        var dataKey = this[0].getAttribute('data-' + key);
	                        if (dataKey) return dataKey;else if (this[0].dom7ElementDataStorage && key in this[0].dom7ElementDataStorage) return this[0].dom7ElementDataStorage[key];else return undefined;
	                    } else return undefined;
	                } else {
	                    // Set value
	                    for (var i = 0; i < this.length; i++) {
	                        var el = this[i];
	                        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
	                        el.dom7ElementDataStorage[key] = value;
	                    }
	                    return this;
	                }
	            },
	            // Transforms
	            transform: function transform(_transform) {
	                for (var i = 0; i < this.length; i++) {
	                    var elStyle = this[i].style;
	                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = _transform;
	                }
	                return this;
	            },
	            transition: function transition(duration) {
	                if (typeof duration !== 'string') {
	                    duration = duration + 'ms';
	                }
	                for (var i = 0; i < this.length; i++) {
	                    var elStyle = this[i].style;
	                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
	                }
	                return this;
	            },
	            //Events
	            on: function on(eventName, targetSelector, listener, capture) {
	                function handleLiveEvent(e) {
	                    var target = e.target;
	                    if ($(target).is(targetSelector)) listener.call(target, e);else {
	                        var parents = $(target).parents();
	                        for (var k = 0; k < parents.length; k++) {
	                            if ($(parents[k]).is(targetSelector)) listener.call(parents[k], e);
	                        }
	                    }
	                }
	                var events = eventName.split(' ');
	                var i, j;
	                for (i = 0; i < this.length; i++) {
	                    if (typeof targetSelector === 'function' || targetSelector === false) {
	                        // Usual events
	                        if (typeof targetSelector === 'function') {
	                            listener = arguments[1];
	                            capture = arguments[2] || false;
	                        }
	                        for (j = 0; j < events.length; j++) {
	                            this[i].addEventListener(events[j], listener, capture);
	                        }
	                    } else {
	                        //Live events
	                        for (j = 0; j < events.length; j++) {
	                            if (!this[i].dom7LiveListeners) this[i].dom7LiveListeners = [];
	                            this[i].dom7LiveListeners.push({ listener: listener, liveListener: handleLiveEvent });
	                            this[i].addEventListener(events[j], handleLiveEvent, capture);
	                        }
	                    }
	                }
	
	                return this;
	            },
	            off: function off(eventName, targetSelector, listener, capture) {
	                var events = eventName.split(' ');
	                for (var i = 0; i < events.length; i++) {
	                    for (var j = 0; j < this.length; j++) {
	                        if (typeof targetSelector === 'function' || targetSelector === false) {
	                            // Usual events
	                            if (typeof targetSelector === 'function') {
	                                listener = arguments[1];
	                                capture = arguments[2] || false;
	                            }
	                            this[j].removeEventListener(events[i], listener, capture);
	                        } else {
	                            // Live event
	                            if (this[j].dom7LiveListeners) {
	                                for (var k = 0; k < this[j].dom7LiveListeners.length; k++) {
	                                    if (this[j].dom7LiveListeners[k].listener === listener) {
	                                        this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	                return this;
	            },
	            once: function once(eventName, targetSelector, listener, capture) {
	                var dom = this;
	                if (typeof targetSelector === 'function') {
	                    targetSelector = false;
	                    listener = arguments[1];
	                    capture = arguments[2];
	                }
	                function proxy(e) {
	                    listener(e);
	                    dom.off(eventName, targetSelector, proxy, capture);
	                }
	                dom.on(eventName, targetSelector, proxy, capture);
	            },
	            trigger: function trigger(eventName, eventData) {
	                for (var i = 0; i < this.length; i++) {
	                    var evt;
	                    try {
	                        evt = new window.CustomEvent(eventName, { detail: eventData, bubbles: true, cancelable: true });
	                    } catch (e) {
	                        evt = document.createEvent('Event');
	                        evt.initEvent(eventName, true, true);
	                        evt.detail = eventData;
	                    }
	                    this[i].dispatchEvent(evt);
	                }
	                return this;
	            },
	            transitionEnd: function transitionEnd(callback) {
	                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
	                    i,
	                    j,
	                    dom = this;
	                function fireCallBack(e) {
	                    /*jshint validthis:true */
	                    if (e.target !== this) return;
	                    callback.call(this, e);
	                    for (i = 0; i < events.length; i++) {
	                        dom.off(events[i], fireCallBack);
	                    }
	                }
	                if (callback) {
	                    for (i = 0; i < events.length; i++) {
	                        dom.on(events[i], fireCallBack);
	                    }
	                }
	                return this;
	            },
	            // Sizing/Styles
	            width: function width() {
	                if (this[0] === window) {
	                    return window.innerWidth;
	                } else {
	                    if (this.length > 0) {
	                        return parseFloat(this.css('width'));
	                    } else {
	                        return null;
	                    }
	                }
	            },
	            outerWidth: function outerWidth(includeMargins) {
	                if (this.length > 0) {
	                    if (includeMargins) return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));else return this[0].offsetWidth;
	                } else return null;
	            },
	            height: function height() {
	                if (this[0] === window) {
	                    return window.innerHeight;
	                } else {
	                    if (this.length > 0) {
	                        return parseFloat(this.css('height'));
	                    } else {
	                        return null;
	                    }
	                }
	            },
	            outerHeight: function outerHeight(includeMargins) {
	                if (this.length > 0) {
	                    if (includeMargins) return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));else return this[0].offsetHeight;
	                } else return null;
	            },
	            offset: function offset() {
	                if (this.length > 0) {
	                    var el = this[0];
	                    var box = el.getBoundingClientRect();
	                    var body = document.body;
	                    var clientTop = el.clientTop || body.clientTop || 0;
	                    var clientLeft = el.clientLeft || body.clientLeft || 0;
	                    var scrollTop = window.pageYOffset || el.scrollTop;
	                    var scrollLeft = window.pageXOffset || el.scrollLeft;
	                    return {
	                        top: box.top + scrollTop - clientTop,
	                        left: box.left + scrollLeft - clientLeft
	                    };
	                } else {
	                    return null;
	                }
	            },
	            css: function css(props, value) {
	                var i;
	                if (arguments.length === 1) {
	                    if (typeof props === 'string') {
	                        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
	                    } else {
	                        for (i = 0; i < this.length; i++) {
	                            for (var prop in props) {
	                                this[i].style[prop] = props[prop];
	                            }
	                        }
	                        return this;
	                    }
	                }
	                if (arguments.length === 2 && typeof props === 'string') {
	                    for (i = 0; i < this.length; i++) {
	                        this[i].style[props] = value;
	                    }
	                    return this;
	                }
	                return this;
	            },
	
	            //Dom manipulation
	            each: function each(callback) {
	                for (var i = 0; i < this.length; i++) {
	                    callback.call(this[i], i, this[i]);
	                }
	                return this;
	            },
	            html: function html(_html) {
	                if (typeof _html === 'undefined') {
	                    return this[0] ? this[0].innerHTML : undefined;
	                } else {
	                    for (var i = 0; i < this.length; i++) {
	                        this[i].innerHTML = _html;
	                    }
	                    return this;
	                }
	            },
	            text: function text(_text) {
	                if (typeof _text === 'undefined') {
	                    if (this[0]) {
	                        return this[0].textContent.trim();
	                    } else return null;
	                } else {
	                    for (var i = 0; i < this.length; i++) {
	                        this[i].textContent = _text;
	                    }
	                    return this;
	                }
	            },
	            is: function is(selector) {
	                if (!this[0]) return false;
	                var compareWith, i;
	                if (typeof selector === 'string') {
	                    var el = this[0];
	                    if (el === document) return selector === document;
	                    if (el === window) return selector === window;
	
	                    if (el.matches) return el.matches(selector);else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);else if (el.mozMatchesSelector) return el.mozMatchesSelector(selector);else if (el.msMatchesSelector) return el.msMatchesSelector(selector);else {
	                        compareWith = $(selector);
	                        for (i = 0; i < compareWith.length; i++) {
	                            if (compareWith[i] === this[0]) return true;
	                        }
	                        return false;
	                    }
	                } else if (selector === document) return this[0] === document;else if (selector === window) return this[0] === window;else {
	                    if (selector.nodeType || selector instanceof Dom7) {
	                        compareWith = selector.nodeType ? [selector] : selector;
	                        for (i = 0; i < compareWith.length; i++) {
	                            if (compareWith[i] === this[0]) return true;
	                        }
	                        return false;
	                    }
	                    return false;
	                }
	            },
	            index: function index() {
	                if (this[0]) {
	                    var child = this[0];
	                    var i = 0;
	                    while ((child = child.previousSibling) !== null) {
	                        if (child.nodeType === 1) i++;
	                    }
	                    return i;
	                } else return undefined;
	            },
	            eq: function eq(index) {
	                if (typeof index === 'undefined') return this;
	                var length = this.length;
	                var returnIndex;
	                if (index > length - 1) {
	                    return new Dom7([]);
	                }
	                if (index < 0) {
	                    returnIndex = length + index;
	                    if (returnIndex < 0) return new Dom7([]);else return new Dom7([this[returnIndex]]);
	                }
	                return new Dom7([this[index]]);
	            },
	            append: function append(newChild) {
	                var i, j;
	                for (i = 0; i < this.length; i++) {
	                    if (typeof newChild === 'string') {
	                        var tempDiv = document.createElement('div');
	                        tempDiv.innerHTML = newChild;
	                        while (tempDiv.firstChild) {
	                            this[i].appendChild(tempDiv.firstChild);
	                        }
	                    } else if (newChild instanceof Dom7) {
	                        for (j = 0; j < newChild.length; j++) {
	                            this[i].appendChild(newChild[j]);
	                        }
	                    } else {
	                        this[i].appendChild(newChild);
	                    }
	                }
	                return this;
	            },
	            prepend: function prepend(newChild) {
	                var i, j;
	                for (i = 0; i < this.length; i++) {
	                    if (typeof newChild === 'string') {
	                        var tempDiv = document.createElement('div');
	                        tempDiv.innerHTML = newChild;
	                        for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
	                            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
	                        }
	                        // this[i].insertAdjacentHTML('afterbegin', newChild);
	                    } else if (newChild instanceof Dom7) {
	                        for (j = 0; j < newChild.length; j++) {
	                            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
	                        }
	                    } else {
	                        this[i].insertBefore(newChild, this[i].childNodes[0]);
	                    }
	                }
	                return this;
	            },
	            insertBefore: function insertBefore(selector) {
	                var before = $(selector);
	                for (var i = 0; i < this.length; i++) {
	                    if (before.length === 1) {
	                        before[0].parentNode.insertBefore(this[i], before[0]);
	                    } else if (before.length > 1) {
	                        for (var j = 0; j < before.length; j++) {
	                            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
	                        }
	                    }
	                }
	            },
	            insertAfter: function insertAfter(selector) {
	                var after = $(selector);
	                for (var i = 0; i < this.length; i++) {
	                    if (after.length === 1) {
	                        after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
	                    } else if (after.length > 1) {
	                        for (var j = 0; j < after.length; j++) {
	                            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
	                        }
	                    }
	                }
	            },
	            next: function next(selector) {
	                if (this.length > 0) {
	                    if (selector) {
	                        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);
	                    } else {
	                        if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);
	                    }
	                } else return new Dom7([]);
	            },
	            nextAll: function nextAll(selector) {
	                var nextEls = [];
	                var el = this[0];
	                if (!el) return new Dom7([]);
	                while (el.nextElementSibling) {
	                    var next = el.nextElementSibling;
	                    if (selector) {
	                        if ($(next).is(selector)) nextEls.push(next);
	                    } else nextEls.push(next);
	                    el = next;
	                }
	                return new Dom7(nextEls);
	            },
	            prev: function prev(selector) {
	                if (this.length > 0) {
	                    if (selector) {
	                        if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);
	                    } else {
	                        if (this[0].previousElementSibling) return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);
	                    }
	                } else return new Dom7([]);
	            },
	            prevAll: function prevAll(selector) {
	                var prevEls = [];
	                var el = this[0];
	                if (!el) return new Dom7([]);
	                while (el.previousElementSibling) {
	                    var prev = el.previousElementSibling;
	                    if (selector) {
	                        if ($(prev).is(selector)) prevEls.push(prev);
	                    } else prevEls.push(prev);
	                    el = prev;
	                }
	                return new Dom7(prevEls);
	            },
	            parent: function parent(selector) {
	                var parents = [];
	                for (var i = 0; i < this.length; i++) {
	                    if (selector) {
	                        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
	                    } else {
	                        parents.push(this[i].parentNode);
	                    }
	                }
	                return $($.unique(parents));
	            },
	            parents: function parents(selector) {
	                var parents = [];
	                for (var i = 0; i < this.length; i++) {
	                    var parent = this[i].parentNode;
	                    while (parent) {
	                        if (selector) {
	                            if ($(parent).is(selector)) parents.push(parent);
	                        } else {
	                            parents.push(parent);
	                        }
	                        parent = parent.parentNode;
	                    }
	                }
	                return $($.unique(parents));
	            },
	            find: function find(selector) {
	                var foundElements = [];
	                for (var i = 0; i < this.length; i++) {
	                    var found = this[i].querySelectorAll(selector);
	                    for (var j = 0; j < found.length; j++) {
	                        foundElements.push(found[j]);
	                    }
	                }
	                return new Dom7(foundElements);
	            },
	            children: function children(selector) {
	                var children = [];
	                for (var i = 0; i < this.length; i++) {
	                    var childNodes = this[i].childNodes;
	
	                    for (var j = 0; j < childNodes.length; j++) {
	                        if (!selector) {
	                            if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
	                        } else {
	                            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) children.push(childNodes[j]);
	                        }
	                    }
	                }
	                return new Dom7($.unique(children));
	            },
	            remove: function remove() {
	                for (var i = 0; i < this.length; i++) {
	                    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
	                }
	                return this;
	            },
	            add: function add() {
	                var dom = this;
	                var i, j;
	                for (i = 0; i < arguments.length; i++) {
	                    var toAdd = $(arguments[i]);
	                    for (j = 0; j < toAdd.length; j++) {
	                        dom[dom.length] = toAdd[j];
	                        dom.length++;
	                    }
	                }
	                return dom;
	            }
	        };
	        $.fn = Dom7.prototype;
	        $.unique = function (arr) {
	            var unique = [];
	            for (var i = 0; i < arr.length; i++) {
	                if (unique.indexOf(arr[i]) === -1) unique.push(arr[i]);
	            }
	            return unique;
	        };
	
	        return $;
	    }();
	
	    /*===========================
	     Get Dom libraries
	     ===========================*/
	    var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
	    for (var i = 0; i < swiperDomPlugins.length; i++) {
	        if (window[swiperDomPlugins[i]]) {
	            addLibraryPlugin(window[swiperDomPlugins[i]]);
	        }
	    }
	    // Required DOM Plugins
	    var domLib;
	    if (typeof Dom7 === 'undefined') {
	        domLib = window.Dom7 || window.Zepto || __webpack_provided_window_dot_jQuery;
	    } else {
	        domLib = Dom7;
	    }
	
	    /*===========================
	    Add .swiper plugin from Dom libraries
	    ===========================*/
	    function addLibraryPlugin(lib) {
	        lib.fn.swiper = function (params) {
	            var firstInstance;
	            lib(this).each(function () {
	                var s = new Swiper(this, params);
	                if (!firstInstance) firstInstance = s;
	            });
	            return firstInstance;
	        };
	    }
	
	    if (domLib) {
	        if (!('transitionEnd' in domLib.fn)) {
	            domLib.fn.transitionEnd = function (callback) {
	                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
	                    i,
	                    j,
	                    dom = this;
	                function fireCallBack(e) {
	                    /*jshint validthis:true */
	                    if (e.target !== this) return;
	                    callback.call(this, e);
	                    for (i = 0; i < events.length; i++) {
	                        dom.off(events[i], fireCallBack);
	                    }
	                }
	                if (callback) {
	                    for (i = 0; i < events.length; i++) {
	                        dom.on(events[i], fireCallBack);
	                    }
	                }
	                return this;
	            };
	        }
	        if (!('transform' in domLib.fn)) {
	            domLib.fn.transform = function (transform) {
	                for (var i = 0; i < this.length; i++) {
	                    var elStyle = this[i].style;
	                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
	                }
	                return this;
	            };
	        }
	        if (!('transition' in domLib.fn)) {
	            domLib.fn.transition = function (duration) {
	                if (typeof duration !== 'string') {
	                    duration = duration + 'ms';
	                }
	                for (var i = 0; i < this.length; i++) {
	                    var elStyle = this[i].style;
	                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
	                }
	                return this;
	            };
	        }
	        if (!('outerWidth' in domLib.fn)) {
	            domLib.fn.outerWidth = function (includeMargins) {
	                if (this.length > 0) {
	                    if (includeMargins) return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));else return this[0].offsetWidth;
	                } else return null;
	            };
	        }
	    }
	
	    window.Swiper = Swiper;
	})();
	
	/*===========================
	Swiper AMD Export
	===========================*/
	if (true) {
	    module.exports = window.Swiper;
	} else if (typeof define === 'function' && define.amd) {
	    define([], function () {
	        'use strict';
	
	        return window.Swiper;
	    });
	}
	
	//# sourceMappingURL=maps/swiper.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 3), __webpack_require__(/*! jquery */ 3)))

/***/ }),
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */
/*!*************************************!*\
  !*** ./public/src/lib/evaporate.js ***!
  \*************************************/
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*Copyright (c) 2016, TT Labs, Inc.
	 All rights reserved.
	
	 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	 Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	
	 Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	 Neither the name of the TT Labs, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
	
	 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/
	
	/***************************************************************************************************
	 *                                                                                                 *
	 *  version 2.1.0                                                                                  *
	 *                                                                                                 *
	 ***************************************************************************************************/
	
	(function () {
	  "use strict";
	
	  var FAR_FUTURE = new Date('2060-10-22'),
	      HOURS_AGO,
	      PENDING = 0,
	      EVAPORATING = 2,
	      COMPLETE = 3,
	      PAUSED = 4,
	      CANCELED = 5,
	      ERROR = 10,
	      ABORTED = 20,
	      PAUSING = 30,
	      PAUSED_STATUSES = [PAUSED, PAUSING],
	      ACTIVE_STATUSES = [PENDING, EVAPORATING, ERROR],
	      ETAG_OF_0_LENGTH_BLOB = '"d41d8cd98f00b204e9800998ecf8427e"',
	      PARTS_MONITOR_INTERVAL_MS = 2 * 60 * 1000,
	      IMMUTABLE_OPTIONS = ['maxConcurrentParts', 'logging', 'cloudfront', 'encodeFilename', 'computeContentMd5', 'allowS3ExistenceOptimization', 'onlyRetryForSameFileName', 'timeUrl', 'cryptoMd5Method', 'cryptoHexEncodedHash256', 'awsRegion', 'awsSignatureVersion', 'evaporateChanged'],
	      l;
	
	  var Evaporate = function Evaporate(config) {
	    this.config = extend({
	      readableStreams: false,
	      readableStreamPartMethod: null,
	      bucket: null,
	      logging: true,
	      maxConcurrentParts: 5,
	      partSize: 6 * 1024 * 1024,
	      retryBackoffPower: 2,
	      maxRetryBackoffSecs: 300,
	      progressIntervalMS: 1000,
	      maxRetryAttemps: 5,
	      cloudfront: false,
	      s3Acceleration: false,
	      mockLocalStorage: false,
	      encodeFilename: true,
	      computeContentMd5: false,
	      allowS3ExistenceOptimization: false,
	      onlyRetryForSameFileName: false,
	      timeUrl: null,
	      cryptoMd5Method: null,
	      cryptoHexEncodedHash256: null,
	      aws_key: null,
	      awsRegion: 'us-east-1',
	      awsSignatureVersion: '4',
	      sendCanonicalRequestToSignerUrl: false,
	      s3FileCacheHoursAgo: null, // Must be a whole number of hours. Will be interpreted as negative (hours in the past).
	      signParams: {},
	      signHeaders: {},
	      customAuthMethod: undefined,
	      maxFileSize: null,
	      signResponseHandler: null,
	      xhrWithCredentials: false,
	      // undocumented, experimental
	      localTimeOffset: undefined,
	      evaporateChanged: function evaporateChanged() {},
	      abortCompletionThrottlingMs: 1000
	    }, config);
	
	    if (typeof window !== 'undefined' && window.console) {
	      l = window.console;
	      l.d = l.log;
	      l.w = window.console.warn ? l.warn : l.d;
	      l.e = window.console.error ? l.error : l.d;
	    }
	
	    this._instantiationError = this.validateEvaporateOptions();
	    if (typeof this._instantiationError === 'string') {
	      this.supported = false;
	      return;
	    } else {
	      delete this._instantiationError;
	    }
	
	    if (!this.config.logging) {
	      // Reset the logger to be a no_op
	      l = noOpLogger();
	    }
	
	    var _d = new Date();
	    HOURS_AGO = new Date(_d.setHours(_d.getHours() - (this.config.s3FileCacheHoursAgo || -100)));
	    if (typeof config.localTimeOffset === 'number') {
	      this.localTimeOffset = config.localTimeOffset;
	    } else {
	      var self = this;
	      Evaporate.getLocalTimeOffset(this.config).then(function (offset) {
	        self.localTimeOffset = offset;
	      });
	    }
	    this.pendingFiles = {};
	    this.queuedFiles = [];
	    this.filesInProcess = [];
	    historyCache = new HistoryCache(this.config.mockLocalStorage);
	  };
	  Evaporate.create = function (config) {
	    var evapConfig = extend({}, config);
	    return Evaporate.getLocalTimeOffset(evapConfig).then(function (offset) {
	      evapConfig.localTimeOffset = offset;
	      return new Promise(function (resolve, reject) {
	        var e = new Evaporate(evapConfig);
	        if (e.supported === true) {
	          resolve(e);
	        } else {
	          reject(e._instantiationError);
	        }
	      });
	    });
	  };
	  Evaporate.getLocalTimeOffset = function (config) {
	    return new Promise(function (resolve, reject) {
	      if (typeof config.localTimeOffset === 'number') {
	        return resolve(config.localTimeOffset);
	      }
	      if (config.timeUrl) {
	        var xhr = new XMLHttpRequest();
	
	        xhr.open("GET", config.timeUrl + '?requestTime=' + new Date().getTime());
	        xhr.onreadystatechange = function () {
	          if (xhr.readyState === 4) {
	            if (xhr.status === 200) {
	              var server_date = new Date(Date.parse(xhr.responseText)),
	                  now = new Date();
	              resolve(server_date - now);
	            }
	          }
	        };
	
	        xhr.onerror = function (xhr) {
	          l.e('xhr error timeUrl', xhr);
	          reject('Fetching offset time failed with status: ' + xhr.status);
	        };
	        xhr.send();
	      } else {
	        resolve(0);
	      }
	    }).then(function (offset) {
	      l.d('localTimeOffset is', offset, 'ms');
	      return new Promise(function (resolve) {
	        resolve(offset);
	      });
	    });
	  };
	  Evaporate.prototype.config = {};
	  Evaporate.prototype.localTimeOffset = 0;
	  Evaporate.prototype.supported = false;
	  Evaporate.prototype._instantiationError = undefined;
	  Evaporate.prototype.evaporatingCount = 0;
	  Evaporate.prototype.pendingFiles = {};
	  Evaporate.prototype.filesInProcess = [];
	  Evaporate.prototype.queuedFiles = [];
	  Evaporate.prototype.startNextFile = function (reason) {
	    if (!this.queuedFiles.length || this.evaporatingCount >= this.config.maxConcurrentParts) {
	      return;
	    }
	    var fileUpload = this.queuedFiles.shift();
	    if (fileUpload.status === PENDING) {
	      l.d('Starting', decodeURIComponent(fileUpload.name), 'reason:', reason);
	      this.evaporatingCnt(+1);
	      fileUpload.start();
	    } else {
	      // Add the file back to the stack, it's not ready
	      l.d('Requeued', decodeURIComponent(fileUpload.name), 'status:', fileUpload.status, 'reason:', reason);
	      this.queuedFiles.push(fileUpload);
	    }
	  };
	  Evaporate.prototype.fileCleanup = function (fileUpload) {
	    removeAtIndex(this.queuedFiles, fileUpload);
	    if (removeAtIndex(this.filesInProcess, fileUpload)) {
	      this.evaporatingCnt(-1);
	    }
	    fileUpload.done();
	    this.consumeRemainingSlots();
	  };
	  Evaporate.prototype.queueFile = function (fileUpload) {
	    this.filesInProcess.push(fileUpload);
	    this.queuedFiles.push(fileUpload);
	    if (this.filesInProcess.length === 1) {
	      this.startNextFile('first file');
	    }
	  };
	  Evaporate.prototype.add = function (file, pConfig) {
	    var self = this,
	        fileConfig;
	    return new Promise(function (resolve, reject) {
	      var c = extend(pConfig, {});
	
	      IMMUTABLE_OPTIONS.forEach(function (a) {
	        delete c[a];
	      });
	
	      fileConfig = extend(self.config, c);
	
	      if (typeof file === 'undefined' || typeof file.file === 'undefined') {
	        return reject('Missing file');
	      }
	      if (fileConfig.maxFileSize && file.file.size > fileConfig.maxFileSize) {
	        return reject('File size too large. Maximum size allowed is ' + fileConfig.maxFileSize);
	      }
	      if (typeof file.name === 'undefined') {
	        return reject('Missing attribute: name');
	      }
	
	      if (fileConfig.encodeFilename) {
	        // correctly encode to an S3 object name, considering '/' and ' '
	        file.name = s3EncodedObjectName(file.name);
	      }
	
	      var fileUpload = new FileUpload(extend({
	        started: function started() {},
	        uploadInitiated: function uploadInitiated() {},
	        progress: function progress() {},
	        complete: function complete() {},
	        cancelled: function cancelled() {},
	        paused: function paused() {},
	        resumed: function resumed() {},
	        pausing: function pausing() {},
	        nameChanged: function nameChanged() {},
	        info: function info() {},
	        warn: function warn() {},
	        error: function error() {},
	        beforeSigner: undefined,
	        xAmzHeadersAtInitiate: {},
	        notSignedHeadersAtInitiate: {},
	        xAmzHeadersCommon: null,
	        xAmzHeadersAtUpload: {},
	        xAmzHeadersAtComplete: {}
	      }, file, {
	        status: PENDING,
	        priority: 0,
	        loadedBytes: 0,
	        sizeBytes: file.file.size,
	        eTag: ''
	      }), fileConfig, self),
	          fileKey = fileUpload.id;
	
	      self.pendingFiles[fileKey] = fileUpload;
	
	      self.queueFile(fileUpload);
	
	      // Resolve or reject the Add promise based on how the fileUpload completes
	      fileUpload.deferredCompletion.promise.then(function () {
	        self.fileCleanup(fileUpload);
	        resolve(decodeURIComponent(fileUpload.name));
	      }, function (reason) {
	        self.fileCleanup(fileUpload);
	        reject(reason);
	      });
	    });
	  };
	  Evaporate.prototype.cancel = function (id) {
	    return typeof id === 'undefined' ? this._cancelAll() : this._cancelOne(id);
	  };
	  Evaporate.prototype._cancelAll = function () {
	    l.d('Canceling all file uploads');
	    var promises = [];
	    for (var key in this.pendingFiles) {
	      if (this.pendingFiles.hasOwnProperty(key)) {
	        var file = this.pendingFiles[key];
	        if (ACTIVE_STATUSES.indexOf(file.status) > -1) {
	          promises.push(file.stop());
	        }
	      }
	    }
	    if (!promises.length) {
	      promises.push(Promise.reject('No files to cancel.'));
	    }
	    return Promise.all(promises);
	  };
	  Evaporate.prototype._cancelOne = function (id) {
	    var promise = [];
	    if (this.pendingFiles[id]) {
	      promise.push(this.pendingFiles[id].stop());
	    } else {
	      promise.push(Promise.reject('File does not exist'));
	    }
	    return Promise.all(promise);
	  };
	  Evaporate.prototype.pause = function (id, options) {
	    options = options || {};
	    var force = typeof options.force === 'undefined' ? false : options.force;
	    return typeof id === 'undefined' ? this._pauseAll(force) : this._pauseOne(id, force);
	  };
	  Evaporate.prototype._pauseAll = function (force) {
	    l.d('Pausing all file uploads');
	    var promises = [];
	    for (var key in this.pendingFiles) {
	      if (this.pendingFiles.hasOwnProperty(key)) {
	        var file = this.pendingFiles[key];
	        if (ACTIVE_STATUSES.indexOf(file.status) > -1) {
	          this._pause(file, force, promises);
	        }
	      }
	    }
	    return Promise.all(promises);
	  };
	  Evaporate.prototype._pauseOne = function (id, force) {
	    var promises = [],
	        file = this.pendingFiles[id];
	    if (typeof file === 'undefined') {
	      promises.push(Promise.reject('Cannot pause a file that has not been added.'));
	    } else if (file.status === PAUSED) {
	      promises.push(Promise.reject('Cannot pause a file that is already paused.'));
	    }
	    if (!promises.length) {
	      this._pause(file, force, promises);
	    }
	    return Promise.all(promises);
	  };
	  Evaporate.prototype._pause = function (fileUpload, force, promises) {
	    promises.push(fileUpload.pause(force));
	    removeAtIndex(this.filesInProcess, fileUpload);
	    removeAtIndex(this.queuedFiles, fileUpload);
	  };
	  Evaporate.prototype.resume = function (id) {
	    return typeof id === 'undefined' ? this._resumeAll() : this._resumeOne(id);
	  };
	  Evaporate.prototype._resumeAll = function () {
	    l.d('Resuming all file uploads');
	    for (var key in this.pendingFiles) {
	      if (this.pendingFiles.hasOwnProperty(key)) {
	        var file = this.pendingFiles[key];
	        if (PAUSED_STATUSES.indexOf(file.status) > -1) {
	          this.resumeFile(file);
	        }
	      }
	    }
	    return Promise.resolve();
	  };
	  Evaporate.prototype._resumeOne = function (id) {
	    var file = this.pendingFiles[id],
	        promises = [];
	    if (typeof file === 'undefined') {
	      promises.push(Promise.reject('Cannot pause a file that does not exist.'));
	    } else if (PAUSED_STATUSES.indexOf(file.status) === -1) {
	      promises.push(Promise.reject('Cannot resume a file that has not been paused.'));
	    } else {
	      this.resumeFile(file);
	    }
	    return Promise.all(promises);
	  };
	  Evaporate.prototype.resumeFile = function (fileUpload) {
	    fileUpload.resume();
	    this.queueFile(fileUpload);
	  };
	  Evaporate.prototype.forceRetry = function () {};
	  Evaporate.prototype.consumeRemainingSlots = function () {
	    var avail = this.config.maxConcurrentParts - this.evaporatingCount;
	    if (!avail) {
	      return;
	    }
	    for (var i = 0; i < this.filesInProcess.length; i++) {
	      var file = this.filesInProcess[i];
	      var consumed = file.consumeSlots();
	      if (consumed < 0) {
	        continue;
	      }
	      avail -= consumed;
	      if (!avail) {
	        return;
	      }
	    }
	  };
	  Evaporate.prototype.validateEvaporateOptions = function () {
	    this.supported = !(typeof File === 'undefined' || typeof Promise === 'undefined');
	
	    if (!this.supported) {
	      return 'Evaporate requires support for File and Promise';
	    }
	
	    if (this.config.readableStreams) {
	      if (typeof this.config.readableStreamPartMethod !== 'function') {
	        return "Option readableStreamPartMethod is required when readableStreams is set.";
	      }
	    } else {
	      if (typeof Blob === 'undefined' || typeof (Blob.prototype.webkitSlice || Blob.prototype.mozSlice || Blob.prototype.slice) === 'undefined') {
	        return 'Evaporate requires support for Blob [webkitSlice || mozSlice || slice]';
	      }
	    }
	
	    if (!this.config.signerUrl && typeof this.config.customAuthMethod !== 'function') {
	      return "Option signerUrl is required unless customAuthMethod is present.";
	    }
	
	    if (!this.config.bucket) {
	      return "The AWS 'bucket' option must be present.";
	    }
	
	    if (this.config.computeContentMd5) {
	      this.supported = typeof FileReader.prototype.readAsArrayBuffer !== 'undefined';
	      if (!this.supported) {
	        return 'The browser\'s FileReader object does not support readAsArrayBuffer';
	      }
	
	      if (typeof this.config.cryptoMd5Method !== 'function') {
	        return 'Option computeContentMd5 has been set but cryptoMd5Method is not defined.';
	      }
	
	      if (this.config.awsSignatureVersion === '4') {
	        if (typeof this.config.cryptoHexEncodedHash256 !== 'function') {
	          return 'Option awsSignatureVersion is 4 but cryptoHexEncodedHash256 is not defined.';
	        }
	      }
	    } else if (this.config.awsSignatureVersion === '4') {
	      return 'Option awsSignatureVersion is 4 but computeContentMd5 is not enabled.';
	    }
	    return true;
	  };
	  Evaporate.prototype.evaporatingCnt = function (incr) {
	    this.evaporatingCount = Math.max(0, this.evaporatingCount + incr);
	    this.config.evaporateChanged(this, this.evaporatingCount);
	  };
	
	  function FileUpload(file, con, evaporate) {
	    this.fileTotalBytesUploaded = 0;
	    this.s3Parts = [];
	    this.partsOnS3 = [];
	    this.partsInProcess = [];
	    this.partsToUpload = [];
	    this.numParts = -1;
	    this.con = extend({}, con);
	    this.evaporate = evaporate;
	    this.localTimeOffset = evaporate.localTimeOffset;
	    this.deferredCompletion = defer();
	
	    extend(this, file);
	
	    this.id = decodeURIComponent(this.con.bucket + '/' + this.name);
	
	    this.signParams = con.signParams;
	  }
	  FileUpload.prototype.con = undefined;
	  FileUpload.prototype.evaporate = undefined;
	  FileUpload.prototype.localTimeOffset = 0;
	  FileUpload.prototype.id = undefined;
	  FileUpload.prototype.status = PENDING;
	  FileUpload.prototype.numParts = -1;
	  FileUpload.prototype.fileTotalBytesUploaded = 0;
	  FileUpload.prototype.partsInProcess = [];
	  FileUpload.prototype.partsToUpload = [];
	  FileUpload.prototype.s3Parts = [];
	  FileUpload.prototype.partsOnS3 = [];
	  FileUpload.prototype.deferredCompletion = undefined;
	  FileUpload.prototype.abortedByUser = false;
	
	  // Progress and Stats
	  FileUpload.prototype.progressInterval = undefined;
	  FileUpload.prototype.startTime = undefined;
	  FileUpload.prototype.loaded = 0;
	  FileUpload.prototype.totalUpoaded = 0;
	  FileUpload.prototype.updateLoaded = function (loadedNow) {
	    this.loaded += loadedNow;
	    this.fileTotalBytesUploaded += loadedNow;
	  };
	  FileUpload.prototype.progessStats = function () {
	    // Adapted from https://github.com/fkjaekel
	    // https://github.com/TTLabs/EvaporateJS/issues/13
	    if (this.fileTotalBytesUploaded === 0) {
	      return {};
	    }
	
	    this.totalUpoaded += this.loaded;
	    var delta = (new Date() - this.startTime) / 1000,
	        avgSpeed = this.totalUpoaded / delta,
	        stats = {
	      speed: avgSpeed,
	      readableSpeed: readableFileSize(avgSpeed),
	      loaded: this.loaded
	    },
	        remainingSize = this.sizeBytes - this.fileTotalBytesUploaded;
	
	    if (avgSpeed > 0) {
	      stats.secondsLeft = Math.round(remainingSize / avgSpeed);
	    }
	    return stats;
	  };
	  FileUpload.prototype.onProgress = function () {
	    if ([ABORTED, PAUSED].indexOf(this.status) === -1) {
	      this.progress(this.fileTotalBytesUploaded / this.sizeBytes, this.progessStats());
	      this.loaded = 0;
	    }
	  };
	  FileUpload.prototype.startMonitor = function () {
	    clearInterval(this.progressInterval);
	    this.startTime = new Date();
	    this.loaded = 0;
	    this.totalUpoaded = 0;
	    this.onProgress();
	    this.progressInterval = setInterval(this.onProgress.bind(this), this.con.progressIntervalMS);
	  };
	  FileUpload.prototype.stopMonitor = function () {
	    clearInterval(this.progressInterval);
	  };
	
	  // Evaporate proxies
	  FileUpload.prototype.startNextFile = function (reason) {
	    this.evaporate.startNextFile(reason);
	  };
	  FileUpload.prototype.evaporatingCnt = function (incr) {
	    this.evaporate.evaporatingCnt(incr);
	  };
	  FileUpload.prototype.consumeRemainingSlots = function () {
	    this.evaporate.consumeRemainingSlots();
	  };
	  FileUpload.prototype.getRemainingSlots = function () {
	    var evapCount = this.evaporate.evaporatingCount;
	    if (!this.partsInProcess.length && evapCount > 0) {
	      // we can use our file slot
	      evapCount -= 1;
	    }
	    return this.con.maxConcurrentParts - evapCount;
	  };
	
	  FileUpload.prototype.lastPartSatisfied = Promise.resolve('onStart');
	
	  FileUpload.prototype.start = function () {
	    this.status = EVAPORATING;
	    this.startMonitor();
	    this.started(this.id);
	
	    if (this.uploadId) {
	      l.d('resuming FileUpload ', this.id);
	      return this.consumeSlots();
	    }
	
	    var awsKey = this.name;
	
	    this.getUnfinishedFileUpload();
	
	    var existenceOptimized = this.con.computeContentMd5 && this.con.allowS3ExistenceOptimization && typeof this.firstMd5Digest !== 'undefined' && typeof this.eTag !== 'undefined',
	        self = this,
	        callComplete = false;
	
	    new Promise(function (resolve, reject) {
	
	      new Promise(function (resolve, rejectToUploadNew) {
	        if (self.uploadId) {
	          if (existenceOptimized) {
	            return self.reuseS3Object(awsKey).then(resolve, rejectToUploadNew);
	          }
	
	          callComplete = true;
	          self.resumeInterruptedUpload().then(resolve, rejectToUploadNew);
	        } else {
	          throw ""; // throw triggers the Upload here for the common case
	        }
	      }).then(resolve, function (reason) {
	        // rejectToUploadNew
	        if (ACTIVE_STATUSES.indexOf(self.status) === -1) {
	          return;
	        }
	        l.d(reason);
	        self.uploadId = undefined;
	        callComplete = true;
	        self.uploadFile(awsKey).then(resolve, reject);
	      });
	    }).then(function () {
	      var promise = callComplete ? self.completeUpload() : Promise.resolve();
	      promise.then(self.deferredCompletion.resolve.bind(self));
	    }, function () {
	      // uploadFile failed
	      if (!self.abortedByUser) {
	        self.abortUpload().then(function () {
	          self.deferredCompletion.reject('File upload aborted due to a part failing to upload');
	        }, self.deferredCompletion.reject.bind(self));
	      }
	    });
	  };
	  FileUpload.prototype.stop = function () {
	    l.d('stopping FileUpload ', this.id);
	    this.setStatus(CANCELED);
	    this.info('Canceling uploads...');
	    this.abortedByUser = true;
	    var self = this;
	    return this.abortUpload().then(function () {
	      throw "User aborted the upload";
	    }).catch(function (reason) {
	      self.deferredCompletion.reject(reason);
	    });
	  };
	  FileUpload.prototype.pause = function (force) {
	    l.d('pausing FileUpload, force:', !!force, this.id);
	    var promises = [];
	    this.info('Pausing uploads...');
	    this.status = PAUSING;
	    if (force) {
	      this.abortParts(true);
	    } else {
	      promises = this.partsInProcess.map(function (p) {
	        return this.s3Parts[p].awsRequest.awsDeferred.promise;
	      }, this);
	      this.pausing();
	    }
	    return Promise.all(promises).then(function () {
	      this.stopMonitor();
	      this.status = PAUSED;
	      this.startNextFile('pause');
	      this.paused();
	    }.bind(this));
	  };
	  FileUpload.prototype.resume = function () {
	    this.status = PENDING;
	    this.resumed();
	  };
	  FileUpload.prototype.done = function () {
	    clearInterval(this.progressInterval);
	    this.startNextFile('file done');
	    this.partsOnS3 = [];
	    this.s3Parts = [];
	  };
	
	  FileUpload.prototype.startPartUpload = function (part) {
	    this.lastPartSatisfied.then(part.delaySend.bind(part));
	    this.lastPartSatisfied = part.getStartedPromise();
	  };
	  FileUpload.prototype.abortParts = function (pause) {
	    var self = this;
	    var toAbort = this.partsInProcess.slice(0);
	    toAbort.forEach(function (i) {
	      var part = self.s3Parts[i];
	      if (part) {
	        part.awsRequest.abort();
	        if (pause) {
	          part.status = PENDING;
	        }
	        removeAtIndex(self.partsInProcess, part.part);
	        if (self.partsToUpload.length) {
	          self.evaporatingCnt(-1);
	        }
	      }
	    });
	  };
	  FileUpload.prototype.makeParts = function (firstPart) {
	    this.numParts = Math.ceil(this.sizeBytes / this.con.partSize) || 1; // issue #58
	    var partsDeferredPromises = [];
	
	    var self = this;
	
	    function cleanUpAfterPart(s3Part) {
	      removeAtIndex(self.partsToUpload, s3Part.part);
	      removeAtIndex(self.partsInProcess, s3Part.part);
	
	      if (self.partsToUpload.length) {
	        self.evaporatingCnt(-1);
	      }
	    }
	
	    function resolve(s3Part) {
	      return function () {
	        cleanUpAfterPart(s3Part);
	        if (self.partsToUpload.length) {
	          self.consumeRemainingSlots();
	        }
	        if (self.partsToUpload.length < self.con.maxConcurrentParts) {
	          self.startNextFile('part resolve');
	        }
	      };
	    }
	    function reject(s3Part) {
	      return function () {
	        cleanUpAfterPart(s3Part);
	      };
	    }
	
	    var limit = firstPart ? 1 : this.numParts;
	
	    for (var part = 1; part <= limit; part++) {
	      var s3Part = this.s3Parts[part];
	      if (typeof s3Part !== "undefined") {
	        if (s3Part.status === COMPLETE) {
	          continue;
	        }
	      } else {
	        s3Part = this.makePart(part, PENDING, this.sizeBytes);
	      }
	      s3Part.awsRequest = new PutPart(this, s3Part);
	      s3Part.awsRequest.awsDeferred.promise.then(resolve(s3Part), reject(s3Part));
	
	      this.partsToUpload.push(part);
	      partsDeferredPromises.push(this.s3Parts[part].awsRequest.awsDeferred.promise);
	    }
	
	    return partsDeferredPromises;
	  };
	  FileUpload.prototype.makePart = function (partNumber, status, size) {
	    var part = {
	      status: status,
	      loadedBytes: 0,
	      loadedBytesPrevious: null,
	      isEmpty: size === 0, // issue #58
	      md5_digest: null,
	      part: partNumber
	    };
	
	    this.s3Parts[partNumber] = part;
	
	    return part;
	  };
	  FileUpload.prototype.setStatus = function (s) {
	    this.status = s;
	  };
	
	  FileUpload.prototype.createUploadFile = function () {
	    if (this.status === ABORTED) {
	      return;
	    }
	    var fileKey = uploadKey(this),
	        newUpload = {
	      awsKey: this.name,
	      bucket: this.con.bucket,
	      uploadId: this.uploadId,
	      fileSize: this.sizeBytes,
	      fileType: this.file.type,
	      lastModifiedDate: dateISOString(this.file.lastModified),
	      partSize: this.con.partSize,
	      signParams: this.con.signParams,
	      createdAt: new Date().toISOString()
	    };
	    saveUpload(fileKey, newUpload);
	  };
	  FileUpload.prototype.updateUploadFile = function (updates) {
	    var fileKey = uploadKey(this),
	        uploads = getSavedUploads(),
	        upload = extend({}, uploads[fileKey], updates);
	    saveUpload(fileKey, upload);
	  };
	  FileUpload.prototype.completeUploadFile = function (xhr) {
	    var uploads = getSavedUploads(),
	        upload = uploads[uploadKey(this)];
	
	    if (typeof upload !== 'undefined') {
	      upload.completedAt = new Date().toISOString();
	      upload.eTag = this.eTag;
	      upload.firstMd5Digest = this.firstMd5Digest;
	      uploads[uploadKey(this)] = upload;
	      historyCache.setItem('awsUploads', JSON.stringify(uploads));
	    }
	
	    this.complete(xhr, this.name, this.progessStats());
	    this.setStatus(COMPLETE);
	    this.onProgress();
	  };
	  FileUpload.prototype.removeUploadFile = function () {
	    if (typeof this.file !== 'undefined') {
	      removeUpload(uploadKey(this));
	    }
	  };
	  FileUpload.prototype.getUnfinishedFileUpload = function () {
	    var savedUploads = getSavedUploads(true),
	        u = savedUploads[uploadKey(this)];
	
	    if (this.canRetryUpload(u)) {
	      this.uploadId = u.uploadId;
	      this.name = u.awsKey;
	      this.eTag = u.eTag;
	      this.firstMd5Digest = u.firstMd5Digest;
	      this.signParams = u.signParams;
	    }
	  };
	  FileUpload.prototype.canRetryUpload = function (u) {
	    // Must be the same file name, file size, last_modified, file type as previous upload
	    if (typeof u === 'undefined') {
	      return false;
	    }
	    var completedAt = new Date(u.completedAt || FAR_FUTURE);
	
	    // check that the part sizes and bucket match, and if the file name of the upload
	    // matches if onlyRetryForSameFileName is true
	    return this.con.partSize === u.partSize && completedAt > HOURS_AGO && this.con.bucket === u.bucket && (this.con.onlyRetryForSameFileName ? this.name === u.awsKey : true);
	  };
	
	  FileUpload.prototype.partSuccess = function (eTag, putRequest) {
	    var part = putRequest.part;
	    l.d(putRequest.request.step, 'ETag:', eTag);
	    if (part.isEmpty || eTag !== ETAG_OF_0_LENGTH_BLOB) {
	      // issue #58
	      part.eTag = eTag;
	      part.status = COMPLETE;
	      this.partsOnS3.push(part);
	      return true;
	    } else {
	      part.status = ERROR;
	      putRequest.resetLoadedBytes();
	      var msg = ['eTag matches MD5 of 0 length blob for part #', putRequest.partNumber, 'Retrying part.'].join(" ");
	      l.w(msg);
	      this.warn(msg);
	    }
	  };
	  FileUpload.prototype.listPartsSuccess = function (listPartsRequest, partsXml) {
	    this.info('uploadId', this.uploadId, 'is not complete. Fetching parts from part marker', listPartsRequest.partNumberMarker);
	    partsXml = partsXml.replace(/(\r\n|\n|\r)/gm, ""); // strip line breaks to ease the regex requirements
	    var partRegex = /<Part>(.+?)<\/Part\>/g;
	
	    while (true) {
	      var cp = (partRegex.exec(partsXml) || [])[1];
	      if (!cp) {
	        break;
	      }
	
	      var partSize = parseInt(elementText(cp, "Size"), 10);
	      this.fileTotalBytesUploaded += partSize;
	      this.partsOnS3.push({
	        eTag: elementText(cp, "ETag").replace(/&quot;/g, '"'),
	        partNumber: parseInt(elementText(cp, "PartNumber"), 10),
	        size: partSize,
	        LastModified: elementText(cp, "LastModified")
	      });
	    }
	    return elementText(partsXml, "IsTruncated") === 'true' ? elementText(partsXml, "NextPartNumberMarker") : undefined;
	  };
	  FileUpload.prototype.makePartsfromPartsOnS3 = function () {
	    if (ACTIVE_STATUSES.indexOf(this.status) === -1) {
	      return;
	    }
	    this.nameChanged(this.name);
	    this.partsOnS3.forEach(function (cp) {
	      var uploadedPart = this.makePart(cp.partNumber, COMPLETE, cp.size);
	      uploadedPart.eTag = cp.eTag;
	      uploadedPart.loadedBytes = cp.size;
	      uploadedPart.loadedBytesPrevious = cp.size;
	      uploadedPart.finishedUploadingAt = cp.LastModified;
	    }.bind(this));
	  };
	  FileUpload.prototype.completeUpload = function () {
	    var self = this;
	    return new CompleteMultipartUpload(this).send().then(function (xhr) {
	      self.eTag = elementText(xhr.responseText, "ETag").replace(/&quot;/g, '"');
	      self.completeUploadFile(xhr);
	    });
	  };
	  FileUpload.prototype.getCompletedPayload = function () {
	    var completeDoc = [];
	    completeDoc.push('<CompleteMultipartUpload>');
	    this.s3Parts.forEach(function (part, partNumber) {
	      if (partNumber > 0) {
	        ['<Part><PartNumber>', partNumber, '</PartNumber><ETag>', part.eTag, '</ETag></Part>'].forEach(function (a) {
	          completeDoc.push(a);
	        });
	      }
	    });
	    completeDoc.push('</CompleteMultipartUpload>');
	
	    return completeDoc.join("");
	  };
	  FileUpload.prototype.consumeSlots = function () {
	    if (this.partsToUpload.length === 0) {
	      return -1;
	    }
	    if (this.partsToUpload.length !== this.partsInProcess.length && this.status === EVAPORATING) {
	
	      var partsToUpload = Math.min(this.getRemainingSlots(), this.partsToUpload.length);
	
	      if (!partsToUpload) {
	        return -1;
	      }
	
	      var satisfied = 0;
	      for (var i = 0; i < this.partsToUpload.length; i++) {
	        var part = this.s3Parts[this.partsToUpload[i]];
	
	        if (part.status === EVAPORATING) {
	          continue;
	        }
	
	        if (this.canStartPart(part)) {
	          if (this.partsInProcess.length && this.partsToUpload.length > 1) {
	            this.evaporatingCnt(+1);
	          }
	          this.partsInProcess.push(part.part);
	          this.startPartUpload(part.awsRequest);
	        } else {
	          continue;
	        }
	
	        satisfied += 1;
	
	        if (satisfied === partsToUpload) {
	          break;
	        }
	      }
	      var allInProcess = this.partsToUpload.length === this.partsInProcess.length,
	          remainingSlots = this.getRemainingSlots();
	      if (allInProcess && remainingSlots > 0) {
	        // We don't need any more slots...
	        this.startNextFile('consume slots');
	      }
	      return remainingSlots;
	    }
	    return 0;
	  };
	  FileUpload.prototype.canStartPart = function (part) {
	    return this.partsInProcess.indexOf(part.part) === -1 && !part.awsRequest.errorExceptionStatus();
	  };
	  FileUpload.prototype.uploadFile = function (awsKey) {
	    this.removeUploadFile();
	    var self = this;
	    return new InitiateMultipartUpload(self, awsKey).send().then(function () {
	      self.uploadInitiated(self.uploadId);
	      self.partsToUpload = [];
	      return self.uploadParts().then(function () {}, function (reason) {
	        throw reason;
	      });
	    });
	  };
	  FileUpload.prototype.uploadParts = function () {
	    this.loaded = 0;
	    this.totalUpoaded = 0;
	    if (ACTIVE_STATUSES.indexOf(this.status) === -1) {
	      return Promise.reject('Part uploading stopped because the file was canceled');
	    }
	    var promises = this.makeParts();
	    this.setStatus(EVAPORATING);
	    this.startTime = new Date();
	    this.consumeSlots();
	    return Promise.all(promises);
	  };
	  FileUpload.prototype.abortUpload = function () {
	    return new Promise(function (resolve, reject) {
	
	      if (typeof this.uploadId === 'undefined') {
	        resolve();
	        return;
	      }
	
	      new DeleteMultipartUpload(this).send().then(resolve, reject);
	    }.bind(this)).then(function () {
	      this.setStatus(ABORTED);
	      this.cancelled();
	      this.removeUploadFile();
	    }.bind(this), this.deferredCompletion.reject.bind(this));
	  };
	  FileUpload.prototype.resumeInterruptedUpload = function () {
	    return new ResumeInterruptedUpload(this).send().then(this.uploadParts.bind(this));
	  };
	  FileUpload.prototype.reuseS3Object = function (awsKey) {
	    var self = this;
	    // Attempt to reuse entire uploaded object on S3
	    this.makeParts(1);
	    this.partsToUpload = [];
	    var firstPart = this.s3Parts[1];
	    function reject(reason) {
	      self.name = awsKey;
	      throw reason;
	    }
	    return firstPart.awsRequest.getPartMd5Digest().then(function () {
	      if (self.firstMd5Digest === self.s3Parts[1].md5_digest) {
	        return new ReuseS3Object(self, awsKey).send().then(function (xhr) {
	          l.d('headObject found matching object on S3.');
	          self.completeUploadFile(xhr);
	          self.nameChanged(self.name);
	        }).catch(reject);
	      } else {
	        var msg = self.con.allowS3ExistenceOptimization ? 'File\'s first part MD5 digest does not match what was stored.' : 'allowS3ExistenceOptimization is not enabled.';
	        reject(msg);
	      }
	    });
	  };
	
	  function SignedS3AWSRequest(fileUpload, request) {
	    this.fileUpload = fileUpload;
	    this.con = fileUpload.con;
	    this.attempts = 1;
	    this.localTimeOffset = this.fileUpload.localTimeOffset;
	    this.awsDeferred = defer();
	    this.started = defer();
	
	    this.awsUrl = awsUrl(this.con);
	    this.awsHost = uri(this.awsUrl).hostname;
	
	    this.updateRequest(request);
	  }
	  SignedS3AWSRequest.prototype.fileUpload = undefined;
	  SignedS3AWSRequest.prototype.con = undefined;
	  SignedS3AWSRequest.prototype.awsUrl = undefined;
	  SignedS3AWSRequest.prototype.awsHost = undefined;
	  SignedS3AWSRequest.prototype.authorize = function () {};
	  SignedS3AWSRequest.prototype.localTimeOffset = 0;
	  SignedS3AWSRequest.prototype.awsDeferred = undefined;
	  SignedS3AWSRequest.prototype.started = undefined;
	  SignedS3AWSRequest.prototype.getPath = function () {
	    //var path = '/' + this.con.bucket + '/' + this.fileUpload.name;
	    //change path to the same as current IT solution
	    var path = '/' + this.fileUpload.name;
	    if (this.con.cloudfront || this.awsUrl.indexOf('cloudfront') > -1) {
	      path = '/' + this.fileUpload.name;
	    }
	    return path;
	  };
	
	  SignedS3AWSRequest.prototype.updateRequest = function (request) {
	    this.request = request;
	    var SigningClass = signingVersion(this, l);
	    this.signer = new SigningClass(request);
	  };
	  SignedS3AWSRequest.prototype.success = function () {
	    return true;
	  };
	  SignedS3AWSRequest.prototype.backOffWait = function () {
	    return this.attempts === 1 ? 0 : 1000 * Math.min(this.con.maxRetryBackoffSecs, Math.pow(this.con.retryBackoffPower, this.attempts - 2));
	  };
	  SignedS3AWSRequest.prototype.error = function (reason) {
	    if (this.errorExceptionStatus()) {
	      return;
	    }
	
	    this.signer.error();
	    l.d(this.request.step, 'error:', this.fileUpload.id, reason);
	
	    if (typeof this.errorHandler(reason) !== 'undefined') {
	      return;
	    }
	
	    this.fileUpload.warn('Error in ', this.request.step, reason);
	    this.fileUpload.setStatus(ERROR);
	
	    var self = this,
	        backOffWait = this.backOffWait();
	    this.attempts += 1;
	
	    setTimeout(function () {
	      if (!self.errorExceptionStatus()) {
	        self.trySend();
	      }
	    }, backOffWait);
	  };
	  SignedS3AWSRequest.prototype.errorHandler = function () {};
	  SignedS3AWSRequest.prototype.errorExceptionStatus = function () {
	    return false;
	  };
	  SignedS3AWSRequest.prototype.getPayload = function () {
	    return Promise.resolve(null);
	  };
	  SignedS3AWSRequest.prototype.success_status = function (xhr) {
	    return xhr.status >= 200 && xhr.status <= 299 || this.request.success404 && xhr.status === 404;
	  };
	  SignedS3AWSRequest.prototype.stringToSign = function () {
	    return encodeURIComponent(this.signer.stringToSign());
	  };
	  SignedS3AWSRequest.prototype.canonicalRequest = function () {
	    return this.signer.canonicalRequest();
	  };
	  SignedS3AWSRequest.prototype.signResponse = function (payload, stringToSign, signatureDateTime) {
	    var self = this;
	    return new Promise(function (resolve) {
	      if (typeof self.con.signResponseHandler === 'function') {
	        return self.con.signResponseHandler(payload, stringToSign, signatureDateTime).then(resolve);
	      }
	      resolve(payload);
	    });
	  };
	  SignedS3AWSRequest.prototype.sendRequestToAWS = function () {
	    var self = this;
	    return new Promise(function (resolve, reject) {
	      var xhr = new XMLHttpRequest();
	      self.currentXhr = xhr;
	
	      var url = [self.awsUrl, self.getPath(), self.request.path].join(""),
	          all_headers = {};
	
	      if (self.request.query_string) {
	        url += self.request.query_string;
	      }
	      extend(all_headers, self.request.not_signed_headers);
	      extend(all_headers, self.request.x_amz_headers);
	
	      xhr.onreadystatechange = function () {
	        if (xhr.readyState === 4) {
	
	          if (self.success_status(xhr)) {
	            if (self.request.response_match && xhr.response.match(new RegExp(self.request.response_match)) === undefined) {
	              reject('AWS response does not match set pattern: ' + self.request.response_match);
	            } else {
	              resolve(xhr);
	            }
	          } else {
	            var reason = xhr.responseText ? getAwsResponse(xhr) : ' ';
	            reason += 'status:' + xhr.status;
	            reject(reason);
	          }
	        }
	      };
	
	      xhr.open(self.request.method, url);
	      xhr.setRequestHeader('Authorization', self.signer.authorizationString());
	
	      for (var key in all_headers) {
	        if (all_headers.hasOwnProperty(key)) {
	          xhr.setRequestHeader(key, all_headers[key]);
	        }
	      }
	
	      self.signer.setHeaders(xhr);
	
	      if (self.request.contentType) {
	        xhr.setRequestHeader('Content-Type', self.request.contentType);
	      }
	
	      if (self.request.md5_digest) {
	        xhr.setRequestHeader('Content-MD5', self.request.md5_digest);
	      }
	      xhr.onerror = function (xhr) {
	        var reason = xhr.responseText ? getAwsResponse(xhr) : 'transport error';
	        reject(reason);
	      };
	
	      if (typeof self.request.onProgress === 'function') {
	        xhr.upload.onprogress = self.request.onProgress;
	      }
	
	      self.getPayload().then(xhr.send.bind(xhr), reject);
	
	      setTimeout(function () {
	        // We have to delay here or Safari will hang
	        self.started.resolve('request sent ' + self.request.step);
	      }, 20);
	      self.signer.payload = null;
	      self.payloadPromise = undefined;
	    });
	  };
	  //see: http://docs.amazonwebservices.com/AmazonS3/latest/dev/RESTAuthentication.html#ConstructingTheAuthenticationHeader
	  SignedS3AWSRequest.prototype.authorize = function () {
	    this.request.dateString = this.signer.dateString(this.localTimeOffset);
	    this.request.x_amz_headers = extend(this.request.x_amz_headers, {
	      'x-amz-date': this.request.dateString
	    });
	    return this.signer.getPayload().then(function () {
	      return authorizationMethod(this).authorize();
	    }.bind(this));
	  };
	  SignedS3AWSRequest.prototype.authorizationSuccess = function (authorization) {
	    l.d(this.request.step, 'signature:', authorization);
	    this.request.auth = authorization;
	  };
	  SignedS3AWSRequest.prototype.trySend = function () {
	    var self = this;
	    return this.authorize().then(function (value) {
	      self.authorizationSuccess(value);
	      if (self.fileUpload.status === ABORTED) {
	        return;
	      }
	      self.sendRequestToAWS().then(function (value) {
	        if (self.success(value)) {
	          self.awsDeferred.resolve(value);
	        }
	      }, self.error.bind(self));
	    }, self.error.bind(self));
	  };
	  SignedS3AWSRequest.prototype.send = function () {
	    this.trySend();
	    return this.awsDeferred.promise;
	  };
	
	  function CancelableS3AWSRequest(fileUpload, request) {
	    SignedS3AWSRequest.call(this, fileUpload, request);
	  }
	  CancelableS3AWSRequest.prototype = Object.create(SignedS3AWSRequest.prototype);
	  CancelableS3AWSRequest.prototype.constructor = CancelableS3AWSRequest;
	  CancelableS3AWSRequest.prototype.errorExceptionStatus = function () {
	    return [ABORTED, CANCELED].indexOf(this.fileUpload.status) > -1;
	  };
	
	  function SignedS3AWSRequestWithRetryLimit(fileUpload, request, maxRetries) {
	    if (maxRetries > -1) {
	      this.maxRetries = maxRetries;
	    }
	    SignedS3AWSRequest.call(this, fileUpload, request);
	  }
	  SignedS3AWSRequestWithRetryLimit.prototype = Object.create(CancelableS3AWSRequest.prototype);
	  SignedS3AWSRequestWithRetryLimit.prototype.constructor = SignedS3AWSRequestWithRetryLimit;
	  SignedS3AWSRequestWithRetryLimit.prototype.maxRetries = 1;
	  SignedS3AWSRequestWithRetryLimit.prototype.errorHandler = function (reason) {
	    if (this.attempts > this.maxRetries) {
	      var msg = ['MaxRetries exceeded. Will re-upload file id ', this.fileUpload.id, ', ', reason].join("");
	      l.w(msg);
	      this.awsDeferred.reject(msg);
	      return true;
	    }
	  };
	  SignedS3AWSRequestWithRetryLimit.prototype.rejectedSuccess = function () {
	    var reason = Array.prototype.slice.call(arguments, 1).join("");
	    this.awsDeferred.reject(reason);
	    return false;
	  };
	
	  // see: http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadInitiate.html
	  function InitiateMultipartUpload(fileUpload, awsKey) {
	    var request = {
	      method: 'POST',
	      path: '?uploads',
	      step: 'initiate',
	      x_amz_headers: fileUpload.xAmzHeadersAtInitiate,
	      not_signed_headers: fileUpload.notSignedHeadersAtInitiate,
	      response_match: '<UploadId>(.+)<\/UploadId>'
	    };
	
	    if (fileUpload.contentType) {
	      request.contentType = fileUpload.contentType;
	    }
	
	    CancelableS3AWSRequest.call(this, fileUpload, request);
	    this.awsKey = awsKey;
	  }
	  InitiateMultipartUpload.prototype = Object.create(CancelableS3AWSRequest.prototype);
	  InitiateMultipartUpload.prototype.constructor = InitiateMultipartUpload;
	  InitiateMultipartUpload.prototype.success = function (xhr) {
	    var match = xhr.response.match(new RegExp(this.request.response_match));
	    this.fileUpload.uploadId = match[1];
	    this.fileUpload.awsKey = this.awsKey;
	    l.d('InitiateMultipartUpload ID is', this.fileUpload.uploadId);
	    this.fileUpload.createUploadFile();
	    return true;
	  };
	
	  //http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadComplete.html
	  function CompleteMultipartUpload(fileUpload) {
	    fileUpload.info('will attempt to complete upload');
	    var request = {
	      method: 'POST',
	      contentType: 'application/xml; charset=UTF-8',
	      path: '?uploadId=' + fileUpload.uploadId,
	      x_amz_headers: fileUpload.xAmzHeadersCommon || fileUpload.xAmzHeadersAtComplete,
	      step: 'complete'
	    };
	    CancelableS3AWSRequest.call(this, fileUpload, request);
	  }
	  CompleteMultipartUpload.prototype = Object.create(CancelableS3AWSRequest.prototype);
	  CompleteMultipartUpload.prototype.constructor = CompleteMultipartUpload;
	  CompleteMultipartUpload.prototype.getPayload = function () {
	    return Promise.resolve(this.fileUpload.getCompletedPayload());
	  };
	
	  //http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadComplete.html
	  function ReuseS3Object(fileUpload, awsKey) {
	    this.awsKey = awsKey;
	
	    fileUpload.info('will attempt to verify existence of the file');
	
	    var request = {
	      method: 'HEAD',
	      path: '',
	      x_amz_headers: fileUpload.xAmzHeadersCommon,
	      success404: true,
	      step: 'head_object'
	    };
	
	    SignedS3AWSRequestWithRetryLimit.call(this, fileUpload, request);
	  }
	  ReuseS3Object.prototype = Object.create(SignedS3AWSRequestWithRetryLimit.prototype);
	  ReuseS3Object.prototype.constructor = ReuseS3Object;
	  ReuseS3Object.prototype.awsKey = undefined;
	  ReuseS3Object.prototype.success = function (xhr) {
	    var eTag = xhr.getResponseHeader('Etag');
	    if (eTag !== this.fileUpload.eTag) {
	      return this.rejectedSuccess('uploadId ', this.fileUpload.id, ' found on S3 but the Etag doesn\'t match.');
	    }
	    return true;
	  };
	
	  //http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadListParts.html
	  function ResumeInterruptedUpload(fileUpload) {
	    SignedS3AWSRequestWithRetryLimit.call(this, fileUpload);
	    this.updateRequest(this.setupRequest(0));
	  }
	  ResumeInterruptedUpload.prototype = Object.create(SignedS3AWSRequestWithRetryLimit.prototype);
	  ResumeInterruptedUpload.prototype.constructor = ResumeInterruptedUpload;
	  ResumeInterruptedUpload.prototype.awsKey = undefined;
	  ResumeInterruptedUpload.prototype.partNumberMarker = 0;
	  ResumeInterruptedUpload.prototype.setupRequest = function (partNumberMarker) {
	    var msg = ['setupRequest() for uploadId:', this.fileUpload.uploadId, 'for part marker:', partNumberMarker].join(" ");
	    l.d(msg);
	
	    this.fileUpload.info(msg);
	
	    this.awsKey = this.fileUpload.name;
	    this.partNumberMarker = partNumberMarker;
	
	    var request = {
	      method: 'GET',
	      path: ['?uploadId=', this.fileUpload.uploadId].join(""),
	      query_string: "&part-number-marker=" + partNumberMarker,
	      x_amz_headers: this.fileUpload.xAmzHeadersCommon,
	      step: 'get upload parts',
	      success404: true
	    };
	
	    this.request = request;
	    return request;
	  };
	  ResumeInterruptedUpload.prototype.success = function (xhr) {
	    if (xhr.status === 404) {
	      // Success! Upload is no longer recognized, so there is nothing to fetch
	      return this.rejectedSuccess('uploadId ', this.fileUpload.id, ' not found on S3.');
	    }
	
	    var nextPartNumber = this.fileUpload.listPartsSuccess(this, xhr.responseText);
	    if (nextPartNumber) {
	      var request = this.setupRequest(nextPartNumber); // let's fetch the next set of parts
	      this.updateRequest(request);
	      this.trySend();
	    } else {
	      this.fileUpload.makePartsfromPartsOnS3();
	      return true;
	    }
	  };
	
	  //http://docs.aws.amazon.com/AmazonS3/latest/API/mpUploadUploadPart.html
	  function PutPart(fileUpload, part) {
	    this.part = part;
	    this.part.retry = 0;
	    this.partNumber = part.part;
	    this.start = (this.partNumber - 1) * fileUpload.con.partSize;
	    this.end = Math.min(this.partNumber * fileUpload.con.partSize, fileUpload.sizeBytes);
	
	    var request = {
	      method: 'PUT',
	      path: '?partNumber=' + this.partNumber + '&uploadId=' + fileUpload.uploadId,
	      step: 'upload #' + this.partNumber,
	      x_amz_headers: fileUpload.xAmzHeadersCommon || fileUpload.xAmzHeadersAtUpload,
	      contentSha256: "UNSIGNED-PAYLOAD",
	      onProgress: this.onProgress.bind(this)
	    };
	
	    SignedS3AWSRequest.call(this, fileUpload, request);
	  }
	  PutPart.prototype = Object.create(SignedS3AWSRequest.prototype);
	  PutPart.prototype.constructor = PutPart;
	  PutPart.prototype.part = 1;
	  PutPart.prototype.payloadPromise = undefined;
	  PutPart.prototype.start = 0;
	  PutPart.prototype.end = 0;
	  PutPart.prototype.partNumber = undefined;
	  PutPart.prototype.getPartMd5Digest = function () {
	    var self = this,
	        part = this.part;
	    return new Promise(function (resolve, reject) {
	      if (self.con.computeContentMd5 && !part.md5_digest) {
	        self.getPayload().then(function (data) {
	          var md5_digest = self.con.cryptoMd5Method(data);
	          if (self.partNumber === 1 && self.con.computeContentMd5 && typeof self.fileUpload.firstMd5Digest === "undefined") {
	            self.fileUpload.firstMd5Digest = md5_digest;
	            self.fileUpload.updateUploadFile({ firstMd5Digest: md5_digest });
	          }
	          resolve(md5_digest);
	        }, reject);
	      } else {
	        resolve(part.md5_digest);
	      }
	    }).then(function (md5_digest) {
	      if (md5_digest) {
	        l.d(self.request.step, 'MD5 digest:', md5_digest);
	        self.request.md5_digest = md5_digest;
	        self.part.md5_digest = md5_digest;
	      }
	    });
	  };
	  PutPart.prototype.sendRequestToAWS = function () {
	    this.stalledInterval = setInterval(this.stalledPartMonitor(), PARTS_MONITOR_INTERVAL_MS);
	    this.stalledPartMonitor();
	    return SignedS3AWSRequest.prototype.sendRequestToAWS.call(this);
	  };
	  PutPart.prototype.send = function () {
	    if (this.part.status !== COMPLETE && [ABORTED, PAUSED, CANCELED].indexOf(this.fileUpload.status) === -1) {
	      l.d('uploadPart #', this.partNumber, this.attempts === 1 ? 'submitting' : 'retrying');
	
	      this.part.status = EVAPORATING;
	      this.attempts += 1;
	      this.part.loadedBytesPrevious = null;
	
	      var self = this;
	      return this.getPartMd5Digest().then(function () {
	        l.d('Sending', self.request.step);
	        SignedS3AWSRequest.prototype.send.call(self);
	      });
	    }
	  };
	  PutPart.prototype.success = function (xhr) {
	    clearInterval(this.stalledInterval);
	    var eTag = xhr.getResponseHeader('ETag');
	    return this.fileUpload.partSuccess(eTag, this);
	  };
	  PutPart.prototype.onProgress = function (evt) {
	    if (evt.loaded > 0) {
	      var loadedNow = evt.loaded - this.part.loadedBytes;
	      if (loadedNow) {
	        this.part.loadedBytes = evt.loaded;
	        this.fileUpload.updateLoaded(loadedNow);
	      }
	    }
	  };
	  PutPart.prototype.stalledPartMonitor = function () {
	    var lastLoaded = this.part.loadedBytes;
	    var self = this;
	    return function () {
	      clearInterval(self.stalledInterval);
	      if ([EVAPORATING, ERROR, PAUSING, PAUSED].indexOf(self.fileUpload.status) === -1 && self.part.status !== ABORTED && self.part.loadedBytes < this.size) {
	        if (lastLoaded === self.part.loadedBytes) {
	          l.w('Part stalled. Will abort and retry:', self.partNumber, decodeURIComponent(self.fileUpload.name));
	          self.abort();
	          if (!self.errorExceptionStatus()) {
	            self.delaySend();
	          }
	        } else {
	          self.stalledInterval = setInterval(self.stalledPartMonitor(), PARTS_MONITOR_INTERVAL_MS);
	        }
	      }
	    };
	  };
	  PutPart.prototype.resetLoadedBytes = function () {
	    this.fileUpload.updateLoaded(-this.part.loadedBytes);
	    this.part.loadedBytes = 0;
	    this.fileUpload.onProgress();
	  };
	  PutPart.prototype.errorExceptionStatus = function () {
	    return [CANCELED, ABORTED, PAUSED, PAUSING].indexOf(this.fileUpload.status) > -1;
	  };
	  PutPart.prototype.delaySend = function () {
	    var backOffWait;
	
	    if (this.part.status === ERROR) {
	      backOffWait = this.backOffWait();
	
	      this.attempts += 1;
	    } else {
	      backOffWait = 0;
	    }
	
	    setTimeout(this.send.bind(this), backOffWait);
	  };
	  PutPart.prototype.errorHandler = function (reason) {
	    clearInterval(this.stalledInterval);
	    if (reason.match(/status:404/) || this.part.retry > this.fileUpload.con.maxRetryAttemps) {
	      var errMsg = '404 error on part PUT. The part and the file will abort. ' + reason;
	      l.w(errMsg);
	      this.fileUpload.error(errMsg);
	      this.part.status = ABORTED;
	      this.awsDeferred.reject(errMsg);
	      return true;
	    }
	    this.resetLoadedBytes();
	    this.part.status = ERROR;
	    this.part.retry = this.part.retry + 1;
	    if (!this.errorExceptionStatus()) {
	      this.delaySend();
	    }
	    return true;
	  };
	  PutPart.prototype.abort = function () {
	    if (this.currentXhr) {
	      this.currentXhr.abort();
	    }
	    this.resetLoadedBytes();
	    this.attempts = 1;
	  };
	  PutPart.size = 0;
	  PutPart.prototype.streamToArrayBuffer = function (stream) {
	    var promise = new Promise(function (resolve, reject) {
	      // stream is empty or ended
	      if (!stream.readable) {
	        return resolve([]);
	      }
	
	      var arr = new Uint8Array(Math.min(this.con.partSize, this.end - this.start)),
	          i = 0;
	      stream.on('data', onData);
	      stream.on('end', onEnd);
	      stream.on('error', onEnd);
	      stream.on('close', onClose);
	
	      function onData(data) {
	        if (data.byteLength === 1) {
	          return;
	        }
	        arr.set(data, i);
	        i += data.byteLength;
	      }
	
	      function onEnd(err) {
	        if (err) {
	          reject(err);
	        } else {
	          resolve(arr);
	        }
	        cleanup();
	      }
	
	      function onClose() {
	        resolve(arr);
	        cleanup();
	      }
	
	      function cleanup() {
	        arr = null;
	        stream.removeListener('data', onData);
	        stream.removeListener('end', onEnd);
	        stream.removeListener('error', onEnd);
	        stream.removeListener('close', onClose);
	      }
	    }.bind(this));
	
	    return promise;
	  };
	  PutPart.prototype.getPayload = function () {
	    if (typeof this.payloadPromise === 'undefined') {
	      this.payloadPromise = new Promise(function (resolve, reject) {
	        var promise = this.con.readableStreams ? this.payloadFromStream() : this.payloadFromBlob();
	        promise.then(resolve, reject);
	      }.bind(this));
	    }
	    return this.payloadPromise;
	  };
	  PutPart.prototype.payloadFromStream = function () {
	    var stream = this.con.readableStreamPartMethod(this.fileUpload.file, this.start, this.end - 1);
	    return new Promise(function (resolve, reject) {
	      var streamPromise = this.streamToArrayBuffer(stream);
	      streamPromise.then(function (data) {
	        resolve(data);
	      }.bind(this), reject);
	    }.bind(this));
	  };
	  PutPart.prototype.payloadFromBlob = function () {
	    // browsers' implementation of the Blob.slice function has been renamed a couple of times, and the meaning of the
	    // 2nd parameter changed. For example Gecko went from slice(start,length) -> mozSlice(start, end) -> slice(start, end).
	    // As of 12/12/12, it seems that the unified 'slice' is the best bet, hence it being first in the list. See
	    // https://developer.mozilla.org/en-US/docs/DOM/Blob for more info.
	    var file = this.fileUpload.file,
	        slicerFn = file.slice ? 'slice' : file.mozSlice ? 'mozSlice' : 'webkitSlice',
	        blob = file[slicerFn](this.start, this.end);
	    if (this.con.computeContentMd5) {
	      return new Promise(function (resolve) {
	        var reader = new FileReader();
	        reader.onloadend = function () {
	          var buffer = this.result && typeof this.result.buffer !== 'undefined',
	              result = buffer ? new Uint8Array(this.result.buffer) : this.result;
	          resolve(result);
	        };
	        reader.readAsArrayBuffer(blob);
	      });
	    }
	    return Promise.resolve(blob);
	  };
	  PutPart.prototype.stalledInterval = -1;
	  PutPart.prototype.getStartedPromise = function () {
	    return this.started.promise;
	  };
	
	  //http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadAbort.html
	  function DeleteMultipartUpload(fileUpload) {
	    fileUpload.info('will attempt to abort the upload');
	
	    fileUpload.abortParts();
	
	    var request = {
	      method: 'DELETE',
	      path: '?uploadId=' + fileUpload.uploadId,
	      x_amz_headers: fileUpload.xAmzHeadersCommon,
	      success404: true,
	      step: 'abort'
	    };
	
	    SignedS3AWSRequest.call(this, fileUpload, request);
	  }
	  DeleteMultipartUpload.prototype = Object.create(SignedS3AWSRequest.prototype);
	  DeleteMultipartUpload.prototype.constructor = DeleteMultipartUpload;
	  DeleteMultipartUpload.prototype.maxRetries = 1;
	  DeleteMultipartUpload.prototype.success = function () {
	    this.fileUpload.setStatus(ABORTED);
	    return true;
	  };
	  DeleteMultipartUpload.prototype.errorHandler = function (reason) {
	    if (this.attempts > this.maxRetries) {
	      var msg = 'Error aborting upload, Exceeded retries deleting the file upload: ' + reason;
	      l.w(msg);
	      this.fileUpload.error(msg);
	      this.awsDeferred.reject(msg);
	      return true;
	    }
	  };
	
	  function signingVersion(awsRequest, l) {
	    var con = awsRequest.con;
	    function AwsSignature(request) {
	      this.request = request;
	    }
	    AwsSignature.prototype.request = {};
	    AwsSignature.prototype.error = function () {};
	    AwsSignature.prototype.authorizationString = function () {};
	    AwsSignature.prototype.stringToSign = function () {};
	    AwsSignature.prototype.canonicalRequest = function () {};
	    AwsSignature.prototype.setHeaders = function () {};
	    AwsSignature.prototype.datetime = function (timeOffset) {
	      return new Date(new Date().getTime() + timeOffset);
	    };
	    AwsSignature.prototype.dateString = function (timeOffset) {
	      return this.datetime(timeOffset).toISOString().slice(0, 19).replace(/-|:/g, '') + "Z";
	    };
	
	    function AwsSignatureV2(request) {
	      AwsSignature.call(this, request);
	    }
	    AwsSignatureV2.prototype = Object.create(AwsSignature.prototype);
	    AwsSignatureV2.prototype.constructor = AwsSignatureV2;
	    AwsSignatureV2.prototype.authorizationString = function () {
	      return ['AWS ', con.aws_key, ':', this.request.auth].join('');
	    };
	    AwsSignatureV2.prototype.stringToSign = function () {
	      var x_amz_headers = '',
	          result,
	          header_key_array = [];
	
	      for (var key in this.request.x_amz_headers) {
	        if (this.request.x_amz_headers.hasOwnProperty(key)) {
	          header_key_array.push(key);
	        }
	      }
	      header_key_array.sort();
	
	      header_key_array.forEach(function (header_key) {
	        x_amz_headers += header_key + ':' + this.request.x_amz_headers[header_key] + '\n';
	      }.bind(this));
	
	      result = this.request.method + '\n' + (this.request.md5_digest || '') + '\n' + (this.request.contentType || '') + '\n' + '\n' + x_amz_headers + (con.cloudfront ? '/' + con.bucket : '') + awsRequest.getPath() + this.request.path;
	
	      l.d('V2 stringToSign:', result);
	      return result;
	    };
	    AwsSignatureV2.prototype.dateString = function (timeOffset) {
	      return this.datetime(timeOffset).toUTCString();
	    };
	    AwsSignatureV2.prototype.getPayload = function () {
	      return Promise.resolve();
	    };
	
	    function AwsSignatureV4(request) {
	      this._cr = undefined;
	      AwsSignature.call(this, request);
	    }
	    AwsSignatureV4.prototype = Object.create(AwsSignature.prototype);
	    AwsSignatureV4.prototype.constructor = AwsSignatureV4;
	    AwsSignatureV4.prototype._cr = undefined;
	    AwsSignatureV4.prototype.payload = null;
	    AwsSignatureV4.prototype.error = function () {
	      this._cr = undefined;
	    };
	    AwsSignatureV4.prototype.getPayload = function () {
	      return awsRequest.getPayload().then(function (data) {
	        this.payload = data;
	      }.bind(this));
	    };
	    AwsSignatureV4.prototype.authorizationString = function () {
	      var authParts = [];
	
	      var credentials = this.credentialString();
	      var headers = this.canonicalHeaders();
	
	      authParts.push(['AWS4-HMAC-SHA256 Credential=', con.aws_key, '/', credentials].join(''));
	      authParts.push('SignedHeaders=' + headers.signedHeaders);
	      authParts.push('Signature=' + this.request.auth);
	
	      return authParts.join(', ');
	    };
	    AwsSignatureV4.prototype.stringToSign = function () {
	      var signParts = [];
	      signParts.push('AWS4-HMAC-SHA256');
	      signParts.push(this.request.dateString);
	      signParts.push(this.credentialString());
	      signParts.push(con.cryptoHexEncodedHash256(this.canonicalRequest()));
	      var result = signParts.join('\n');
	
	      l.d('V4 stringToSign:', result);
	      return result;
	    };
	    AwsSignatureV4.prototype.credentialString = function () {
	      var credParts = [];
	
	      credParts.push(this.request.dateString.slice(0, 8));
	      credParts.push(con.awsRegion);
	      credParts.push('s3');
	      credParts.push('aws4_request');
	      return credParts.join('/');
	    };
	    AwsSignatureV4.prototype.canonicalQueryString = function () {
	      var qs = awsRequest.request.query_string || '',
	          search = uri([awsRequest.awsUrl, this.request.path, qs].join("")).search,
	          searchParts = search.length ? search.split('&') : [],
	          encoded = [],
	          nameValue,
	          i;
	
	      for (i = 0; i < searchParts.length; i++) {
	        nameValue = searchParts[i].split("=");
	        encoded.push({
	          name: encodeURIComponent(nameValue[0]),
	          value: nameValue.length > 1 ? encodeURIComponent(nameValue[1]) : null
	        });
	      }
	      var sorted = encoded.sort(function (a, b) {
	        if (a.name < b.name) {
	          return -1;
	        } else if (a.name > b.name) {
	          return 1;
	        }
	        return 0;
	      });
	
	      var result = [];
	      for (i = 0; i < sorted.length; i++) {
	        nameValue = sorted[i].value ? [sorted[i].name, sorted[i].value].join("=") : sorted[i].name + '=';
	        result.push(nameValue);
	      }
	
	      return result.join('&');
	    };
	    AwsSignatureV4.prototype.getPayloadSha256Content = function () {
	      var result = this.request.contentSha256 || con.cryptoHexEncodedHash256(this.payload || '');
	      l.d(this.request.step, 'getPayloadSha256Content:', result);
	      return result;
	    };
	    AwsSignatureV4.prototype.canonicalHeaders = function () {
	      var canonicalHeaders = [],
	          keys = [],
	          i;
	
	      function addHeader(name, value) {
	        var key = name.toLowerCase();
	        keys.push(key);
	        canonicalHeaders[key] = value.replace(/\s+/g, ' ');
	      }
	
	      if (this.request.md5_digest) {
	        addHeader("Content-Md5", this.request.md5_digest);
	      }
	
	      addHeader('Host', awsRequest.awsHost);
	
	      if (this.request.contentType) {
	        addHeader('Content-Type', this.request.contentType || '');
	      }
	
	      var amzHeaders = this.request.x_amz_headers || {};
	      for (var key in amzHeaders) {
	        if (amzHeaders.hasOwnProperty(key)) {
	          addHeader(key, amzHeaders[key]);
	        }
	      }
	
	      var sortedKeys = keys.sort(function (a, b) {
	        if (a < b) {
	          return -1;
	        } else if (a > b) {
	          return 1;
	        }
	        return 0;
	      });
	
	      var result = [];
	
	      var unsigned_headers = [],
	          not_signed = this.request.not_signed_headers || [],
	          signed_headers = [];
	      for (i = 0; i < not_signed.length; i++) {
	        unsigned_headers.push(not_signed[i].toLowerCase());
	      }
	
	      for (i = 0; i < sortedKeys.length; i++) {
	        var k = sortedKeys[i];
	        result.push([k, canonicalHeaders[k]].join(":"));
	        if (unsigned_headers.indexOf(k) === -1) {
	          signed_headers.push(k);
	        }
	      }
	
	      return {
	        canonicalHeaders: result.join("\n"),
	        signedHeaders: signed_headers.join(";")
	      };
	    };
	    AwsSignatureV4.prototype.canonicalRequest = function () {
	      if (typeof this._cr !== 'undefined') {
	        return this._cr;
	      }
	      var canonParts = [];
	
	      canonParts.push(this.request.method);
	      canonParts.push(uri([awsRequest.awsUrl, awsRequest.getPath(), this.request.path].join("")).pathname);
	      canonParts.push(this.canonicalQueryString() || '');
	
	      var headers = this.canonicalHeaders();
	      canonParts.push(headers.canonicalHeaders + '\n');
	      canonParts.push(headers.signedHeaders);
	      canonParts.push(this.getPayloadSha256Content());
	
	      this._cr = canonParts.join("\n");
	      l.d(this.request.step, 'V4 CanonicalRequest:', this._cr);
	      return this._cr;
	    };
	    AwsSignatureV4.prototype.setHeaders = function (xhr) {
	      xhr.setRequestHeader("x-amz-content-sha256", this.getPayloadSha256Content());
	    };
	
	    return con.awsSignatureVersion === '4' ? AwsSignatureV4 : AwsSignatureV2;
	  }
	  function authorizationMethod(awsRequest) {
	    var fileUpload = awsRequest.fileUpload,
	        con = fileUpload.con,
	        request = awsRequest.request;
	
	    function AuthorizationMethod() {
	      this.request = request;
	    }
	    AuthorizationMethod.prototype = Object.create(AuthorizationMethod.prototype);
	    AuthorizationMethod.prototype.request = {};
	    AuthorizationMethod.makeSignParamsObject = function (params) {
	      var out = {};
	      for (var param in params) {
	        if (!params.hasOwnProperty(param)) {
	          continue;
	        }
	        if (typeof params[param] === 'function') {
	          out[param] = params[param]();
	        } else {
	          out[param] = params[param];
	        }
	      }
	      return out;
	    };
	    AuthorizationMethod.prototype.authorize = function () {
	      return new Promise(function (resolve, reject) {
	        var xhr = new XMLHttpRequest();
	        awsRequest.currentXhr = xhr;
	
	        var stringToSign = awsRequest.stringToSign(),
	            url = [con.signerUrl, '?to_sign=', stringToSign, '&datetime=', request.dateString];
	        if (con.sendCanonicalRequestToSignerUrl) {
	          url.push('&canonical_request=');
	          url.push(encodeURIComponent(awsRequest.canonicalRequest()));
	        }
	        url = url.join("");
	
	        var signParams = AuthorizationMethod.makeSignParamsObject(fileUpload.signParams);
	        for (var param in signParams) {
	          if (!signParams.hasOwnProperty(param)) {
	            continue;
	          }
	          url += '&' + encodeURIComponent(param) + '=' + encodeURIComponent(signParams[param]);
	        }
	
	        if (con.xhrWithCredentials) {
	          xhr.withCredentials = true;
	        }
	
	        xhr.onreadystatechange = function () {
	          if (xhr.readyState === 4) {
	            if (xhr.status === 200) {
	              awsRequest.signResponse(xhr.response, stringToSign, request.dateString).then(resolve);
	            } else {
	              if ([401, 403].indexOf(xhr.status) > -1) {
	                var reason = "status:" + xhr.status;
	                fileUpload.deferredCompletion.reject('Permission denied ' + reason);
	                return reject(reason);
	              }
	              reject("Signature fetch returned status: " + xhr.status);
	            }
	          }
	        };
	
	        xhr.onerror = function (xhr) {
	          reject('authorizedSend transport error: ' + xhr.responseText);
	        };
	
	        xhr.open('GET', url);
	        var signHeaders = AuthorizationMethod.makeSignParamsObject(con.signHeaders);
	        for (var header in signHeaders) {
	          if (!signHeaders.hasOwnProperty(header)) {
	            continue;
	          }
	          xhr.setRequestHeader(header, signHeaders[header]);
	        }
	
	        if (typeof fileUpload.beforeSigner === 'function') {
	          fileUpload.beforeSigner(xhr, url);
	        }
	        xhr.send();
	      });
	    };
	
	    function AuthorizationCustom() {
	      AuthorizationMethod.call(this);
	    }
	    AuthorizationCustom.prototype = Object.create(AuthorizationMethod.prototype);
	    AuthorizationCustom.prototype.authorize = function () {
	      return con.customAuthMethod(AuthorizationMethod.makeSignParamsObject(fileUpload.signParams), AuthorizationMethod.makeSignParamsObject(con.signHeaders), awsRequest.stringToSign(), request.dateString, awsRequest.canonicalRequest()).catch(function (reason) {
	        fileUpload.deferredCompletion.reject(reason);
	        throw reason;
	      });
	    };
	
	    if (typeof con.customAuthMethod === 'function') {
	      return new AuthorizationCustom();
	    }
	
	    return new AuthorizationMethod();
	  }
	
	  function awsUrl(con) {
	    var url;
	    if (con.aws_url) {
	      url = [con.aws_url];
	    } else {
	      if (con.s3Acceleration) {
	        url = ["https://", con.bucket, ".s3-accelerate"];
	        con.cloudfront = true;
	      } else {
	        url = ["https://", con.cloudfront ? con.bucket + "." : "", "s3"];
	        if (con.awsRegion !== "us-east-1") {
	          url.push("-", con.awsRegion);
	        }
	      }
	      url.push(".amazonaws.com");
	    }
	    return url.join("");
	  }
	
	  function s3EncodedObjectName(fileName) {
	    var fileParts = fileName.split('/'),
	        encodedParts = [];
	    fileParts.forEach(function (p) {
	      encodedParts.push(encodeURIComponent(p).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/'/g, "%27"));
	    });
	    return encodedParts.join('/');
	  }
	
	  function uri(url) {
	    var p,
	        href = url || '/';
	
	    try {
	      p = new URL(href);
	    } catch (e) {
	      p = document.createElement('a');
	      p.href = href;
	    }
	
	    return {
	      protocol: p.protocol, // => "http:"
	      hostname: p.hostname, // => "example.com"
	      // IE omits the leading slash, so add it if it's missing
	      pathname: p.pathname.replace(/(^\/?)/, "/"), // => "/pathname/"
	      port: p.port, // => "3000"
	      search: p.search[0] === '?' ? p.search.substr(1) : p.search, // => "search=test"
	      hash: p.hash, // => "#hash"
	      host: p.host // => "example.com:3000"
	    };
	  }
	
	  function dateISOString(date) {
	    // Try to get the modified date as an ISO String, if the date exists
	    return date ? new Date(date).toISOString() : '';
	  }
	
	  function getAwsResponse(xhr) {
	    var code = elementText(xhr.responseText, "Code"),
	        msg = elementText(xhr.responseText, "Message");
	    return code.length ? ['AWS Code: ', code, ', Message:', msg].join("") : '';
	  }
	
	  function elementText(source, element) {
	    var match = source.match(["<", element, ">(.+)</", element, ">"].join(""));
	    return match ? match[1] : '';
	  }
	
	  function defer() {
	    var deferred = {},
	        promise;
	    promise = new Promise(function (resolve, reject) {
	      deferred = { resolve: resolve, reject: reject };
	    });
	    return {
	      resolve: deferred.resolve,
	      reject: deferred.reject,
	      promise: promise
	    };
	  }
	
	  function extend(obj1, obj2, obj3) {
	    function ext(target, source) {
	      if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
	        return;
	      }
	      for (var key in source) {
	        if (source.hasOwnProperty(key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	
	    obj1 = obj1 || {};
	    obj2 = obj2 || {};
	    obj3 = obj3 || {};
	    ext(obj2, obj3);
	    ext(obj1, obj2);
	
	    return obj1;
	  }
	
	  function getSavedUploads(purge) {
	    var uploads = JSON.parse(historyCache.getItem('awsUploads') || '{}');
	
	    if (purge) {
	      for (var key in uploads) {
	        if (uploads.hasOwnProperty(key)) {
	          var upload = uploads[key],
	              completedAt = new Date(upload.completedAt || FAR_FUTURE);
	
	          if (completedAt < HOURS_AGO) {
	            // The upload is recent, let's keep it
	            delete uploads[key];
	          }
	        }
	      }
	
	      historyCache.setItem('awsUploads', JSON.stringify(uploads));
	    }
	
	    return uploads;
	  }
	
	  function uploadKey(fileUpload) {
	    // The key tries to give a signature to a file in the absence of its path.
	    // "<filename>-<mimetype>-<modifieddate>-<filesize>"
	    return [fileUpload.file.name, fileUpload.file.type, dateISOString(fileUpload.file.lastModified), fileUpload.sizeBytes].join("-");
	  }
	
	  function saveUpload(uploadKey, upload) {
	    var uploads = getSavedUploads();
	    uploads[uploadKey] = upload;
	    historyCache.setItem('awsUploads', JSON.stringify(uploads));
	  }
	
	  function removeUpload(uploadKey) {
	    var uploads = getSavedUploads();
	    delete uploads[uploadKey];
	    historyCache.setItem('awsUploads', JSON.stringify(uploads));
	  }
	
	  function removeAtIndex(a, i) {
	    var idx = a.indexOf(i);
	    if (idx > -1) {
	      a.splice(idx, 1);
	      return true;
	    }
	  }
	
	  function readableFileSize(size) {
	    // Adapted from https://github.com/fkjaekel
	    // https://github.com/TTLabs/EvaporateJS/issues/13
	    var units = ['B', 'Kb', 'Mb', 'Gb', 'Tb', 'Pb', 'Eb', 'Zb', 'Yb'],
	        i = 0;
	    while (size >= 1024) {
	      size /= 1024;
	      ++i;
	    }
	    return [size.toFixed(2).replace('.00', ''), units[i]].join(" ");
	  }
	
	  var historyCache;
	  function HistoryCache(mockLocalStorage) {
	    var supported = HistoryCache.supported();
	    this.cacheStore = mockLocalStorage ? {} : supported ? localStorage : undefined;
	  }
	  HistoryCache.prototype.supported = false;
	  HistoryCache.prototype.cacheStore = undefined;
	  HistoryCache.prototype.getItem = function (key) {
	    if (this.cacheStore) {
	      return this.cacheStore[key];
	    }
	  };
	  HistoryCache.prototype.setItem = function (key, value) {
	    if (this.cacheStore) {
	      this.cacheStore[key] = value;
	    }
	  };
	  HistoryCache.prototype.removeItem = function (key) {
	    if (this.cacheStore) {
	      return delete this.cacheStore[key];
	    }
	  };
	  HistoryCache.supported = function () {
	    var result = false;
	    if (typeof window !== 'undefined') {
	      if (!('localStorage' in window)) {
	        return result;
	      }
	    } else {
	      return result;
	    }
	
	    // Try to use storage (it might be disabled, e.g. user is in private mode)
	    try {
	      var k = '___test';
	      localStorage[k] = 'OK';
	      var test = localStorage[k];
	      delete localStorage[k];
	      return test === 'OK';
	    } catch (e) {
	      return result;
	    }
	  };
	
	  function noOpLogger() {
	    return { d: function d() {}, w: function w() {}, e: function e() {} };
	  }
	
	  l = noOpLogger();
	
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = Evaporate;
	  } else if (typeof window !== 'undefined') {
	    window.Evaporate = Evaporate;
	  }
	})();

/***/ }),
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */
/*!*****************************************!*\
  !*** ./~/create-react-class/factory.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(/*! object-assign */ 74);
	
	var emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ 192);
	var _invariant = __webpack_require__(/*! fbjs/lib/invariant */ 65);
	
	if (true) {
	  var warning = __webpack_require__(/*! fbjs/lib/warning */ 66);
	}
	
	var MIXINS_KEY = 'mixins';
	
	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}
	
	var ReactPropTypeLocationNames;
	if (true) {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	} else {
	  ReactPropTypeLocationNames = {};
	}
	
	function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
	  /**
	   * Policies that describe methods in `ReactClassInterface`.
	   */
	
	  var injectedMixins = [];
	
	  /**
	   * Composite components are higher-level components that compose other composite
	   * or host components.
	   *
	   * To create a new type of `ReactClass`, pass a specification of
	   * your new class to `React.createClass`. The only requirement of your class
	   * specification is that you implement a `render` method.
	   *
	   *   var MyComponent = React.createClass({
	   *     render: function() {
	   *       return <div>Hello World</div>;
	   *     }
	   *   });
	   *
	   * The class specification supports a specific protocol of methods that have
	   * special meaning (e.g. `render`). See `ReactClassInterface` for
	   * more the comprehensive protocol. Any other properties and methods in the
	   * class specification will be available on the prototype.
	   *
	   * @interface ReactClassInterface
	   * @internal
	   */
	  var ReactClassInterface = {
	    /**
	     * An array of Mixin objects to include when defining your component.
	     *
	     * @type {array}
	     * @optional
	     */
	    mixins: 'DEFINE_MANY',
	
	    /**
	     * An object containing properties and methods that should be defined on
	     * the component's constructor instead of its prototype (static methods).
	     *
	     * @type {object}
	     * @optional
	     */
	    statics: 'DEFINE_MANY',
	
	    /**
	     * Definition of prop types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    propTypes: 'DEFINE_MANY',
	
	    /**
	     * Definition of context types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
	    contextTypes: 'DEFINE_MANY',
	
	    /**
	     * Definition of context types this component sets for its children.
	     *
	     * @type {object}
	     * @optional
	     */
	    childContextTypes: 'DEFINE_MANY',
	
	    // ==== Definition methods ====
	
	    /**
	     * Invoked when the component is mounted. Values in the mapping will be set on
	     * `this.props` if that prop is not specified (i.e. using an `in` check).
	     *
	     * This method is invoked before `getInitialState` and therefore cannot rely
	     * on `this.state` or use `this.setState`.
	     *
	     * @return {object}
	     * @optional
	     */
	    getDefaultProps: 'DEFINE_MANY_MERGED',
	
	    /**
	     * Invoked once before the component is mounted. The return value will be used
	     * as the initial value of `this.state`.
	     *
	     *   getInitialState: function() {
	     *     return {
	     *       isOn: false,
	     *       fooBaz: new BazFoo()
	     *     }
	     *   }
	     *
	     * @return {object}
	     * @optional
	     */
	    getInitialState: 'DEFINE_MANY_MERGED',
	
	    /**
	     * @return {object}
	     * @optional
	     */
	    getChildContext: 'DEFINE_MANY_MERGED',
	
	    /**
	     * Uses props from `this.props` and state from `this.state` to render the
	     * structure of the component.
	     *
	     * No guarantees are made about when or how often this method is invoked, so
	     * it must not have side effects.
	     *
	     *   render: function() {
	     *     var name = this.props.name;
	     *     return <div>Hello, {name}!</div>;
	     *   }
	     *
	     * @return {ReactComponent}
	     * @required
	     */
	    render: 'DEFINE_ONCE',
	
	    // ==== Delegate methods ====
	
	    /**
	     * Invoked when the component is initially created and about to be mounted.
	     * This may have side effects, but any external subscriptions or data created
	     * by this method must be cleaned up in `componentWillUnmount`.
	     *
	     * @optional
	     */
	    componentWillMount: 'DEFINE_MANY',
	
	    /**
	     * Invoked when the component has been mounted and has a DOM representation.
	     * However, there is no guarantee that the DOM node is in the document.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been mounted (initialized and rendered) for the first time.
	     *
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidMount: 'DEFINE_MANY',
	
	    /**
	     * Invoked before the component receives new props.
	     *
	     * Use this as an opportunity to react to a prop transition by updating the
	     * state using `this.setState`. Current props are accessed via `this.props`.
	     *
	     *   componentWillReceiveProps: function(nextProps, nextContext) {
	     *     this.setState({
	     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	     *     });
	     *   }
	     *
	     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	     * transition may cause a state change, but the opposite is not true. If you
	     * need it, you are probably looking for `componentWillUpdate`.
	     *
	     * @param {object} nextProps
	     * @optional
	     */
	    componentWillReceiveProps: 'DEFINE_MANY',
	
	    /**
	     * Invoked while deciding if the component should be updated as a result of
	     * receiving new props, state and/or context.
	     *
	     * Use this as an opportunity to `return false` when you're certain that the
	     * transition to the new props/state/context will not require a component
	     * update.
	     *
	     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	     *     return !equal(nextProps, this.props) ||
	     *       !equal(nextState, this.state) ||
	     *       !equal(nextContext, this.context);
	     *   }
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @return {boolean} True if the component should update.
	     * @optional
	     */
	    shouldComponentUpdate: 'DEFINE_ONCE',
	
	    /**
	     * Invoked when the component is about to update due to a transition from
	     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	     * and `nextContext`.
	     *
	     * Use this as an opportunity to perform preparation before an update occurs.
	     *
	     * NOTE: You **cannot** use `this.setState()` in this method.
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @param {ReactReconcileTransaction} transaction
	     * @optional
	     */
	    componentWillUpdate: 'DEFINE_MANY',
	
	    /**
	     * Invoked when the component's DOM representation has been updated.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been updated.
	     *
	     * @param {object} prevProps
	     * @param {?object} prevState
	     * @param {?object} prevContext
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
	    componentDidUpdate: 'DEFINE_MANY',
	
	    /**
	     * Invoked when the component is about to be removed from its parent and have
	     * its DOM representation destroyed.
	     *
	     * Use this as an opportunity to deallocate any external resources.
	     *
	     * NOTE: There is no `componentDidUnmount` since your component will have been
	     * destroyed by that point.
	     *
	     * @optional
	     */
	    componentWillUnmount: 'DEFINE_MANY',
	
	    /**
	     * Replacement for (deprecated) `componentWillMount`.
	     *
	     * @optional
	     */
	    UNSAFE_componentWillMount: 'DEFINE_MANY',
	
	    /**
	     * Replacement for (deprecated) `componentWillReceiveProps`.
	     *
	     * @optional
	     */
	    UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',
	
	    /**
	     * Replacement for (deprecated) `componentWillUpdate`.
	     *
	     * @optional
	     */
	    UNSAFE_componentWillUpdate: 'DEFINE_MANY',
	
	    // ==== Advanced methods ====
	
	    /**
	     * Updates the component's currently mounted DOM representation.
	     *
	     * By default, this implements React's rendering and reconciliation algorithm.
	     * Sophisticated clients may wish to override this.
	     *
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     * @overridable
	     */
	    updateComponent: 'OVERRIDE_BASE'
	  };
	
	  /**
	   * Similar to ReactClassInterface but for static methods.
	   */
	  var ReactClassStaticInterface = {
	    /**
	     * This method is invoked after a component is instantiated and when it
	     * receives new props. Return an object to update state in response to
	     * prop changes. Return null to indicate no change to state.
	     *
	     * If an object is returned, its keys will be merged into the existing state.
	     *
	     * @return {object || null}
	     * @optional
	     */
	    getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
	  };
	
	  /**
	   * Mapping from class specification keys to special processing functions.
	   *
	   * Although these are declared like instance properties in the specification
	   * when defining classes using `React.createClass`, they are actually static
	   * and are accessible on the constructor instead of the prototype. Despite
	   * being static, they must be defined outside of the "statics" key under
	   * which all other static methods are defined.
	   */
	  var RESERVED_SPEC_KEYS = {
	    displayName: function displayName(Constructor, _displayName) {
	      Constructor.displayName = _displayName;
	    },
	    mixins: function mixins(Constructor, _mixins) {
	      if (_mixins) {
	        for (var i = 0; i < _mixins.length; i++) {
	          mixSpecIntoComponent(Constructor, _mixins[i]);
	        }
	      }
	    },
	    childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	      if (true) {
	        validateTypeDef(Constructor, _childContextTypes, 'childContext');
	      }
	      Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
	    },
	    contextTypes: function contextTypes(Constructor, _contextTypes) {
	      if (true) {
	        validateTypeDef(Constructor, _contextTypes, 'context');
	      }
	      Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
	    },
	    /**
	     * Special case getDefaultProps which should move into statics but requires
	     * automatic merging.
	     */
	    getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	      } else {
	        Constructor.getDefaultProps = _getDefaultProps;
	      }
	    },
	    propTypes: function propTypes(Constructor, _propTypes) {
	      if (true) {
	        validateTypeDef(Constructor, _propTypes, 'prop');
	      }
	      Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
	    },
	    statics: function statics(Constructor, _statics) {
	      mixStaticSpecIntoComponent(Constructor, _statics);
	    },
	    autobind: function autobind() {}
	  };
	
	  function validateTypeDef(Constructor, typeDef, location) {
	    for (var propName in typeDef) {
	      if (typeDef.hasOwnProperty(propName)) {
	        // use a warning instead of an _invariant so components
	        // don't show up in prod but only in __DEV__
	        if (true) {
	          warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
	        }
	      }
	    }
	  }
	
	  function validateMethodOverride(isAlreadyDefined, name) {
	    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	    // Disallow overriding of base class methods unless explicitly allowed.
	    if (ReactClassMixin.hasOwnProperty(name)) {
	      _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);
	    }
	
	    // Disallow defining methods more than once unless explicitly allowed.
	    if (isAlreadyDefined) {
	      _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);
	    }
	  }
	
	  /**
	   * Mixin helper which handles policy validation and reserved
	   * specification keys when building React classes.
	   */
	  function mixSpecIntoComponent(Constructor, spec) {
	    if (!spec) {
	      if (true) {
	        var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
	        var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	        if (true) {
	          warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
	        }
	      }
	
	      return;
	    }
	
	    _invariant(typeof spec !== 'function', "ReactClass: You're attempting to " + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');
	    _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + 'use a component as a mixin. Instead, just use a regular object.');
	
	    var proto = Constructor.prototype;
	    var autoBindPairs = proto.__reactAutoBindPairs;
	
	    // By handling mixins before any other properties, we ensure the same
	    // chaining order is applied to methods with DEFINE_MANY policy, whether
	    // mixins are listed before or after these methods in the spec.
	    if (spec.hasOwnProperty(MIXINS_KEY)) {
	      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	    }
	
	    for (var name in spec) {
	      if (!spec.hasOwnProperty(name)) {
	        continue;
	      }
	
	      if (name === MIXINS_KEY) {
	        // We have already handled mixins in a special case above.
	        continue;
	      }
	
	      var property = spec[name];
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      validateMethodOverride(isAlreadyDefined, name);
	
	      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	        RESERVED_SPEC_KEYS[name](Constructor, property);
	      } else {
	        // Setup methods on prototype:
	        // The following member methods should not be automatically bound:
	        // 1. Expected ReactClass methods (in the "interface").
	        // 2. Overridden methods (that were mixed in).
	        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	        var isFunction = typeof property === 'function';
	        var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	        if (shouldAutoBind) {
	          autoBindPairs.push(name, property);
	          proto[name] = property;
	        } else {
	          if (isAlreadyDefined) {
	            var specPolicy = ReactClassInterface[name];
	
	            // These cases should already be caught by validateMethodOverride.
	            _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name);
	
	            // For methods which are defined more than once, call the existing
	            // methods before calling the new property, merging if appropriate.
	            if (specPolicy === 'DEFINE_MANY_MERGED') {
	              proto[name] = createMergedResultFunction(proto[name], property);
	            } else if (specPolicy === 'DEFINE_MANY') {
	              proto[name] = createChainedFunction(proto[name], property);
	            }
	          } else {
	            proto[name] = property;
	            if (true) {
	              // Add verbose displayName to the function, which helps when looking
	              // at profiling tools.
	              if (typeof property === 'function' && spec.displayName) {
	                proto[name].displayName = spec.displayName + '_' + name;
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	
	  function mixStaticSpecIntoComponent(Constructor, statics) {
	    if (!statics) {
	      return;
	    }
	
	    for (var name in statics) {
	      var property = statics[name];
	      if (!statics.hasOwnProperty(name)) {
	        continue;
	      }
	
	      var isReserved = name in RESERVED_SPEC_KEYS;
	      _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);
	
	      var isAlreadyDefined = name in Constructor;
	      if (isAlreadyDefined) {
	        var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;
	
	        _invariant(specPolicy === 'DEFINE_MANY_MERGED', 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);
	
	        Constructor[name] = createMergedResultFunction(Constructor[name], property);
	
	        return;
	      }
	
	      Constructor[name] = property;
	    }
	  }
	
	  /**
	   * Merge two objects, but throw if both contain the same key.
	   *
	   * @param {object} one The first object, which is mutated.
	   * @param {object} two The second object
	   * @return {object} one after it has been mutated to contain everything in two.
	   */
	  function mergeIntoWithNoDuplicateKeys(one, two) {
	    _invariant(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');
	
	    for (var key in two) {
	      if (two.hasOwnProperty(key)) {
	        _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);
	        one[key] = two[key];
	      }
	    }
	    return one;
	  }
	
	  /**
	   * Creates a function that invokes two functions and merges their return values.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createMergedResultFunction(one, two) {
	    return function mergedResult() {
	      var a = one.apply(this, arguments);
	      var b = two.apply(this, arguments);
	      if (a == null) {
	        return b;
	      } else if (b == null) {
	        return a;
	      }
	      var c = {};
	      mergeIntoWithNoDuplicateKeys(c, a);
	      mergeIntoWithNoDuplicateKeys(c, b);
	      return c;
	    };
	  }
	
	  /**
	   * Creates a function that invokes two functions and ignores their return vales.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
	  function createChainedFunction(one, two) {
	    return function chainedFunction() {
	      one.apply(this, arguments);
	      two.apply(this, arguments);
	    };
	  }
	
	  /**
	   * Binds a method to the component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   * @param {function} method Method to be bound.
	   * @return {function} The bound method.
	   */
	  function bindAutoBindMethod(component, method) {
	    var boundMethod = method.bind(component);
	    if (true) {
	      boundMethod.__reactBoundContext = component;
	      boundMethod.__reactBoundMethod = method;
	      boundMethod.__reactBoundArguments = null;
	      var componentName = component.constructor.displayName;
	      var _bind = boundMethod.bind;
	      boundMethod.bind = function (newThis) {
	        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }
	
	        // User is trying to bind() an autobound method; we effectively will
	        // ignore the value of "this" that the user is trying to use, so
	        // let's warn.
	        if (newThis !== component && newThis !== null) {
	          if (true) {
	            warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
	          }
	        } else if (!args.length) {
	          if (true) {
	            warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
	          }
	          return boundMethod;
	        }
	        var reboundMethod = _bind.apply(boundMethod, arguments);
	        reboundMethod.__reactBoundContext = component;
	        reboundMethod.__reactBoundMethod = method;
	        reboundMethod.__reactBoundArguments = args;
	        return reboundMethod;
	      };
	    }
	    return boundMethod;
	  }
	
	  /**
	   * Binds all auto-bound methods in a component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   */
	  function bindAutoBindMethods(component) {
	    var pairs = component.__reactAutoBindPairs;
	    for (var i = 0; i < pairs.length; i += 2) {
	      var autoBindKey = pairs[i];
	      var method = pairs[i + 1];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	
	  var IsMountedPreMixin = {
	    componentDidMount: function componentDidMount() {
	      this.__isMounted = true;
	    }
	  };
	
	  var IsMountedPostMixin = {
	    componentWillUnmount: function componentWillUnmount() {
	      this.__isMounted = false;
	    }
	  };
	
	  /**
	   * Add more to the ReactClass base class. These are all legacy features and
	   * therefore not already part of the modern ReactComponent.
	   */
	  var ReactClassMixin = {
	    /**
	     * TODO: This will be deprecated because state should always keep a consistent
	     * type signature and the only use case for this, is to avoid that.
	     */
	    replaceState: function replaceState(newState, callback) {
	      this.updater.enqueueReplaceState(this, newState, callback);
	    },
	
	    /**
	     * Checks whether or not this composite component is mounted.
	     * @return {boolean} True if mounted, false otherwise.
	     * @protected
	     * @final
	     */
	    isMounted: function isMounted() {
	      if (true) {
	        warning(this.__didWarnIsMounted, '%s: isMounted is deprecated. Instead, make sure to clean up ' + 'subscriptions and pending requests in componentWillUnmount to ' + 'prevent memory leaks.', this.constructor && this.constructor.displayName || this.name || 'Component');
	        this.__didWarnIsMounted = true;
	      }
	      return !!this.__isMounted;
	    }
	  };
	
	  var ReactClassComponent = function ReactClassComponent() {};
	  _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  function createClass(spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (true) {
	        warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (true) {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      _invariant((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');
	
	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
	    mixSpecIntoComponent(Constructor, spec);
	    mixSpecIntoComponent(Constructor, IsMountedPostMixin);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (true) {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');
	
	    if (true) {
	      warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
	      warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
	      warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, '%s has a method called UNSAFE_componentWillRecieveProps(). ' + 'Did you mean UNSAFE_componentWillReceiveProps()?', spec.displayName || 'A component');
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  }
	
	  return createClass;
	}
	
	module.exports = factory;

/***/ }),
/* 192 */
/*!***********************************!*\
  !*** ./~/fbjs/lib/emptyObject.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (true) {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;

/***/ }),
/* 193 */
/*!*************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/BrowserSupportCore.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _getVendorPrefixedName = __webpack_require__(/*! ./getVendorPrefixedName */ 120);
	
	var _getVendorPrefixedName2 = _interopRequireDefault(_getVendorPrefixedName);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var BrowserSupportCore = {
	  /**
	   * @return {bool} True if browser supports css animations.
	   */
	  hasCSSAnimations: function hasCSSAnimations() {
	    return !!(0, _getVendorPrefixedName2.default)('animationName');
	  },
	
	  /**
	   * @return {bool} True if browser supports css transforms.
	   */
	  hasCSSTransforms: function hasCSSTransforms() {
	    return !!(0, _getVendorPrefixedName2.default)('transform');
	  },
	
	  /**
	   * @return {bool} True if browser supports css 3d transforms.
	   */
	  hasCSS3DTransforms: function hasCSS3DTransforms() {
	    return !!(0, _getVendorPrefixedName2.default)('perspective');
	  },
	
	  /**
	   * @return {bool} True if browser supports css transitions.
	   */
	  hasCSSTransitions: function hasCSSTransitions() {
	    return !!(0, _getVendorPrefixedName2.default)('transition');
	  }
	}; /**
	    * Copyright Schrodinger, LLC
	    * All rights reserved.
	    *
	    * This source code is licensed under the BSD-style license found in the
	    * LICENSE file in the root directory of this source tree. An additional grant
	    * of patent rights can be found in the PATENTS file in the same directory.
	    *
	    * @providesModule BrowserSupportCore
	    */
	
	module.exports = BrowserSupportCore;

/***/ }),
/* 194 */
/*!********************************************************!*\
  !*** ./~/fixed-data-table-2/internal/EventListener.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _emptyFunction = __webpack_require__(/*! ./emptyFunction */ 22);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (true) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: _emptyFunction2.default
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	}; /**
	    * Copyright Schrodinger, LLC
	    * All rights reserved.
	    *
	    * This source code is licensed under the BSD-style license found in the
	    * LICENSE file in the root directory of this source tree. An additional grant
	    * of patent rights can be found in the PATENTS file in the same directory.
	    *
	    * @providesModule EventListener
	    * @typechecks
	    */
	
	module.exports = EventListener;

/***/ }),
/* 195 */
/*!*********************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTable.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	}; /**
	    * Copyright Schrodinger, LLC
	    * All rights reserved.
	    *
	    * This source code is licensed under the BSD-style license found in the
	    * LICENSE file in the root directory of this source tree. An additional grant
	    * of patent rights can be found in the PATENTS file in the same directory.
	    *
	    * @providesModule FixedDataTable
	    * @typechecks
	    * @noflow
	    */
	
	/*eslint no-bitwise:1*/
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _createReactClass = __webpack_require__(/*! create-react-class */ 21);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _ReactComponentWithPureRenderMixin = __webpack_require__(/*! ./ReactComponentWithPureRenderMixin */ 46);
	
	var _ReactComponentWithPureRenderMixin2 = _interopRequireDefault(_ReactComponentWithPureRenderMixin);
	
	var _ReactWheelHandler = __webpack_require__(/*! ./ReactWheelHandler */ 119);
	
	var _ReactWheelHandler2 = _interopRequireDefault(_ReactWheelHandler);
	
	var _ReactTouchHandler = __webpack_require__(/*! ./ReactTouchHandler */ 210);
	
	var _ReactTouchHandler2 = _interopRequireDefault(_ReactTouchHandler);
	
	var _Scrollbar = __webpack_require__(/*! ./Scrollbar */ 211);
	
	var _Scrollbar2 = _interopRequireDefault(_Scrollbar);
	
	var _FixedDataTableBufferedRows = __webpack_require__(/*! ./FixedDataTableBufferedRows */ 196);
	
	var _FixedDataTableBufferedRows2 = _interopRequireDefault(_FixedDataTableBufferedRows);
	
	var _FixedDataTableColumnResizeHandle = __webpack_require__(/*! ./FixedDataTableColumnResizeHandle */ 200);
	
	var _FixedDataTableColumnResizeHandle2 = _interopRequireDefault(_FixedDataTableColumnResizeHandle);
	
	var _FixedDataTableRow = __webpack_require__(/*! ./FixedDataTableRow */ 118);
	
	var _FixedDataTableRow2 = _interopRequireDefault(_FixedDataTableRow);
	
	var _FixedDataTableScrollHelper = __webpack_require__(/*! ./FixedDataTableScrollHelper */ 203);
	
	var _FixedDataTableScrollHelper2 = _interopRequireDefault(_FixedDataTableScrollHelper);
	
	var _FixedDataTableWidthHelper = __webpack_require__(/*! ./FixedDataTableWidthHelper */ 204);
	
	var _FixedDataTableWidthHelper2 = _interopRequireDefault(_FixedDataTableWidthHelper);
	
	var _FixedDataTableEventHelper = __webpack_require__(/*! ./FixedDataTableEventHelper */ 68);
	
	var _FixedDataTableEventHelper2 = _interopRequireDefault(_FixedDataTableEventHelper);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	var _debounceCore = __webpack_require__(/*! ./debounceCore */ 216);
	
	var _debounceCore2 = _interopRequireDefault(_debounceCore);
	
	var _emptyFunction = __webpack_require__(/*! ./emptyFunction */ 22);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	var _invariant = __webpack_require__(/*! ./invariant */ 34);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _joinClasses = __webpack_require__(/*! ./joinClasses */ 35);
	
	var _joinClasses2 = _interopRequireDefault(_joinClasses);
	
	var _shallowEqual = __webpack_require__(/*! ./shallowEqual */ 121);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _FixedDataTableTranslateDOMPosition = __webpack_require__(/*! ./FixedDataTableTranslateDOMPosition */ 45);
	
	var _FixedDataTableTranslateDOMPosition2 = _interopRequireDefault(_FixedDataTableTranslateDOMPosition);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var ReactChildren = _React2.default.Children;
	
	var EMPTY_OBJECT = {};
	var BORDER_HEIGHT = 1;
	var HEADER = 'header';
	var FOOTER = 'footer';
	var CELL = 'cell';
	var DRAG_SCROLL_SPEED = 15;
	var DRAG_SCROLL_BUFFER = 100;
	
	/**
	 * Data grid component with fixed or scrollable header and columns.
	 *
	 * The layout of the data table is as follows:
	 *
	 * ```
	 * +---------------------------------------------------+
	 * | Fixed Column Group    | Scrollable Column Group   |
	 * | Header                | Header                    |
	 * |                       |                           |
	 * +---------------------------------------------------+
	 * |                       |                           |
	 * | Fixed Header Columns  | Scrollable Header Columns |
	 * |                       |                           |
	 * +-----------------------+---------------------------+
	 * |                       |                           |
	 * | Fixed Body Columns    | Scrollable Body Columns   |
	 * |                       |                           |
	 * +-----------------------+---------------------------+
	 * |                       |                           |
	 * | Fixed Footer Columns  | Scrollable Footer Columns |
	 * |                       |                           |
	 * +-----------------------+---------------------------+
	 * ```
	 *
	 * - Fixed Column Group Header: These are the headers for a group
	 *   of columns if included in the table that do not scroll
	 *   vertically or horizontally.
	 *
	 * - Scrollable Column Group Header: The header for a group of columns
	 *   that do not move while scrolling vertically, but move horizontally
	 *   with the horizontal scrolling.
	 *
	 * - Fixed Header Columns: The header columns that do not move while scrolling
	 *   vertically or horizontally.
	 *
	 * - Scrollable Header Columns: The header columns that do not move
	 *   while scrolling vertically, but move horizontally with the horizontal
	 *   scrolling.
	 *
	 * - Fixed Body Columns: The body columns that do not move while scrolling
	 *   horizontally, but move vertically with the vertical scrolling.
	 *
	 * - Scrollable Body Columns: The body columns that move while scrolling
	 *   vertically or horizontally.
	 */
	var FixedDataTable = (0, _createReactClass2.default)({
	  displayName: 'FixedDataTable',
	
	  propTypes: {
	
	    /**
	     * Pixel width of table. If all columns do not fit,
	     * a horizontal scrollbar will appear.
	     */
	    width: _propTypes2.default.number.isRequired,
	
	    /**
	     * Pixel height of table. If all rows do not fit,
	     * a vertical scrollbar will appear.
	     *
	     * Either `height` or `maxHeight` must be specified.
	     */
	    height: _propTypes2.default.number,
	
	    /**
	     * Class name to be passed into parent container
	     */
	    className: _propTypes2.default.string,
	
	    /**
	     * Maximum pixel height of table. If all rows do not fit,
	     * a vertical scrollbar will appear.
	     *
	     * Either `height` or `maxHeight` must be specified.
	     */
	    maxHeight: _propTypes2.default.number,
	
	    /**
	     * Pixel height of table's owner, this is used in a managed scrolling
	     * situation when you want to slide the table up from below the fold
	     * without having to constantly update the height on every scroll tick.
	     * Instead, vary this property on scroll. By using `ownerHeight`, we
	     * over-render the table while making sure the footer and horizontal
	     * scrollbar of the table are visible when the current space for the table
	     * in view is smaller than the final, over-flowing height of table. It
	     * allows us to avoid resizing and reflowing table when it is moving in the
	     * view.
	     *
	     * This is used if `ownerHeight < height` (or `maxHeight`).
	     */
	    ownerHeight: _propTypes2.default.number,
	
	    overflowX: _propTypes2.default.oneOf(['hidden', 'auto']),
	    overflowY: _propTypes2.default.oneOf(['hidden', 'auto']),
	
	    /**
	     * Boolean flag indicating of touch scrolling should be enabled
	     * This feature is current in beta and may have bugs
	     */
	    touchScrollEnabled: _propTypes2.default.bool,
	
	    /**
	     * Hide the scrollbar but still enable scroll functionality
	     */
	    showScrollbarX: _propTypes2.default.bool,
	    showScrollbarY: _propTypes2.default.bool,
	
	    /**
	     * Callback when horizontally scrolling the grid.
	     *
	     * Return false to stop propagation.
	     */
	    onHorizontalScroll: _propTypes2.default.func,
	
	    /**
	     * Callback when vertically scrolling the grid.
	     *
	     * Return false to stop propagation.
	     */
	    onVerticalScroll: _propTypes2.default.func,
	
	    /**
	     * Number of rows in the table.
	     */
	    rowsCount: _propTypes2.default.number.isRequired,
	
	    /**
	     * Pixel height of rows unless `rowHeightGetter` is specified and returns
	     * different value.
	     */
	    rowHeight: _propTypes2.default.number.isRequired,
	
	    /**
	     * If specified, `rowHeightGetter(index)` is called for each row and the
	     * returned value overrides `rowHeight` for particular row.
	     */
	    rowHeightGetter: _propTypes2.default.func,
	
	    /**
	     * Pixel height of sub-row unless `subRowHeightGetter` is specified and returns
	     * different value.  Defaults to 0 and no sub-row being displayed.
	     */
	    subRowHeight: _propTypes2.default.number,
	
	    /**
	     * If specified, `subRowHeightGetter(index)` is called for each row and the
	     * returned value overrides `subRowHeight` for particular row.
	     */
	    subRowHeightGetter: _propTypes2.default.func,
	
	    /**
	     * The row expanded for table row.
	     * This can either be a React element, or a function that generates
	     * a React Element. By default, the React element passed in can expect to
	     * receive the following props:
	     *
	     * ```
	     * props: {
	     *   rowIndex; number // (the row index)
	     *   height: number // (supplied from the Table or rowHeightGetter)
	     *   width: number // (supplied from the Table)
	     * }
	     * ```
	     *
	     * Because you are passing in your own React element, you can feel free to
	     * pass in whatever props you may want or need.
	     *
	     * If you pass in a function, you will receive the same props object as the
	     * first argument.
	     */
	    rowExpanded: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.func]),
	
	    /**
	     * To get any additional CSS classes that should be added to a row,
	     * `rowClassNameGetter(index)` is called.
	     */
	    rowClassNameGetter: _propTypes2.default.func,
	
	    /**
	     * If specified, `rowKeyGetter(index)` is called for each row and the
	     * returned value overrides `key` for the particular row.
	     */
	    rowKeyGetter: _propTypes2.default.func,
	
	    /**
	     * Pixel height of the column group header.
	     */
	    groupHeaderHeight: _propTypes2.default.number,
	
	    /**
	     * Pixel height of header.
	     */
	    headerHeight: _propTypes2.default.number.isRequired,
	
	    /**
	     * Pixel height of fixedDataTableCellGroupLayout/cellGroupWrapper.
	     * Default is headerHeight and groupHeaderHeight.
	     *
	     * This can be used with CSS to make a header cell span both the group & normal header row.
	     * Setting this to a value larger than height will cause the content to
	     * overflow the height. This is useful when adding a 2nd table as the group
	     * header and vertically merging the 2 headers when a column is not part
	     * of a group. Here are the necessary CSS changes:
	     *
	     * Both headers:
	     *  - cellGroupWrapper needs overflow-x: hidden and pointer-events: none
	     *  - cellGroup needs pointer-events: auto to reenable them on child els
	     * Group header:
	     *  - Layout/main needs overflow: visible and a higher z-index
	     *  - CellLayout/main needs overflow-y: visible
	     *  - cellGroup needs overflow: visible
	     */
	    cellGroupWrapperHeight: _propTypes2.default.number,
	
	    /**
	     * Pixel height of footer.
	     */
	    footerHeight: _propTypes2.default.number,
	
	    /**
	     * Value of horizontal scroll.
	     */
	    scrollLeft: _propTypes2.default.number,
	
	    /**
	     * Index of column to scroll to.
	     */
	    scrollToColumn: _propTypes2.default.number,
	
	    /**
	     * Value of vertical scroll.
	     */
	    scrollTop: _propTypes2.default.number,
	
	    /**
	     * Index of row to scroll to.
	     */
	    scrollToRow: _propTypes2.default.number,
	
	    /**
	     * Callback that is called when scrolling starts with current horizontal
	     * and vertical scroll values.
	     */
	    onScrollStart: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when scrolling ends or stops with new horizontal
	     * and vertical scroll values.
	     */
	    onScrollEnd: _propTypes2.default.func,
	
	    /**
	     * If enabled scroll events will not be propagated outside of the table.
	     */
	    stopScrollPropagation: _propTypes2.default.bool,
	
	    /**
	     * Callback that is called when `rowHeightGetter` returns a different height
	     * for a row than the `rowHeight` prop. This is necessary because initially
	     * table estimates heights of some parts of the content.
	     */
	    onContentHeightChange: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a row is clicked.
	     */
	    onRowClick: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a row is double clicked.
	     */
	    onRowDoubleClick: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a mouse-down event happens on a row.
	     */
	    onRowMouseDown: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a mouse-up event happens on a row.
	     */
	    onRowMouseUp: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a mouse-enter event happens on a row.
	     */
	    onRowMouseEnter: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a mouse-leave event happens on a row.
	     */
	    onRowMouseLeave: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a touch-start event happens on a row.
	     */
	    onRowTouchStart: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a touch-end event happens on a row.
	     */
	    onRowTouchEnd: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when a touch-move event happens on a row.
	     */
	    onRowTouchMove: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when resizer has been released
	     * and column needs to be updated.
	     *
	     * Required if the isResizable property is true on any column.
	     *
	     * ```
	     * function(
	     *   newColumnWidth: number,
	     *   columnKey: string,
	     * )
	     * ```
	     */
	    onColumnResizeEndCallback: _propTypes2.default.func,
	
	    /**
	     * Callback that is called when reordering has been completed
	     * and columns need to be updated.
	     *
	     * ```
	     * function(
	     *   event {
	     *     columnBefore: string|undefined, // the column before the new location of this one
	     *     columnAfter: string|undefined,  // the column after the new location of this one
	     *     reorderColumn: string,          // the column key that was just reordered
	     *   }
	     * )
	     * ```
	     */
	    onColumnReorderEndCallback: _propTypes2.default.func,
	
	    /**
	     * Whether a column is currently being resized.
	     */
	    isColumnResizing: _propTypes2.default.bool,
	
	    /**
	     * Whether columns are currently being reordered.
	     */
	    isColumnReordering: _propTypes2.default.bool,
	
	    /**
	     * The number of rows outside the viewport to prerender. Defaults to roughly
	     * half of the number of visible rows.
	     */
	    bufferRowCount: _propTypes2.default.number
	  },
	
	  getDefaultProps: function getDefaultProps() /*object*/{
	    return {
	      footerHeight: 0,
	      groupHeaderHeight: 0,
	      headerHeight: 0,
	      showScrollbarX: true,
	      showScrollbarY: true,
	      touchScrollEnabled: false,
	      stopScrollPropagation: false
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    var props = this.props;
	
	    var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);
	    this._scrollHelper = new _FixedDataTableScrollHelper2.default(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter, props.subRowHeight, props.subRowHeightGetter);
	
	    this._didScrollStop = (0, _debounceCore2.default)(this._didScrollStopSync, 200, this);
	
	    this._wheelHandler = new _ReactWheelHandler2.default(this._onScroll, this._shouldHandleWheelX, this._shouldHandleWheelY, props.stopScrollPropagation);
	    this._touchHandler = new _ReactTouchHandler2.default(this._onScroll, this._shouldHandleTouchX, this._shouldHandleTouchY, props.stopScrollPropagation);
	
	    this.setState(this._calculateState(props));
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._wheelHandler = null;
	    this._touchHandler = null;
	
	    // Cancel any pending debounced scroll handling and handle immediately.
	    this._didScrollStop.reset();
	    this._didScrollStopSync();
	  },
	  _shouldHandleTouchX: function _shouldHandleTouchX( /*number*/delta) /*boolean*/{
	    return this.props.touchScrollEnabled && this._shouldHandleWheelX(delta);
	  },
	  _shouldHandleTouchY: function _shouldHandleTouchY( /*number*/delta) /*boolean*/{
	    return this.props.touchScrollEnabled && this._shouldHandleWheelY(delta);
	  },
	  _shouldHandleWheelX: function _shouldHandleWheelX( /*number*/delta) /*boolean*/{
	    if (this.props.overflowX === 'hidden') {
	      return false;
	    }
	
	    delta = Math.round(delta);
	    if (delta === 0) {
	      return false;
	    }
	
	    return delta < 0 && this.state.scrollX > 0 || delta >= 0 && this.state.scrollX < this.state.maxScrollX;
	  },
	  _shouldHandleWheelY: function _shouldHandleWheelY( /*number*/delta) /*boolean*/{
	    if (this.props.overflowY === 'hidden' || delta === 0) {
	      return false;
	    }
	
	    delta = Math.round(delta);
	    if (delta === 0) {
	      return false;
	    }
	
	    return delta < 0 && this.state.scrollY > 0 || delta >= 0 && this.state.scrollY < this.state.maxScrollY;
	  },
	  _reportContentHeight: function _reportContentHeight() {
	    var scrollContentHeight = this.state.scrollContentHeight;
	    var reservedHeight = this.state.reservedHeight;
	    var requiredHeight = scrollContentHeight + reservedHeight;
	    var contentHeight;
	    var useMaxHeight = this.props.height === undefined;
	    if (useMaxHeight && this.props.maxHeight > requiredHeight) {
	      contentHeight = requiredHeight;
	    } else if (this.state.height > requiredHeight && this.props.ownerHeight) {
	      contentHeight = Math.max(requiredHeight, this.props.ownerHeight);
	    } else {
	      contentHeight = this.state.height + this.state.maxScrollY;
	    }
	    if (contentHeight !== this._contentHeight && this.props.onContentHeightChange) {
	      this.props.onContentHeightChange(contentHeight);
	    }
	    this._contentHeight = contentHeight;
	  },
	  componentDidMount: function componentDidMount() {
	    this._reportContentHeight();
	  },
	  componentWillReceiveProps: function componentWillReceiveProps( /*object*/nextProps) {
	    var newOverflowX = nextProps.overflowX;
	    var newOverflowY = nextProps.overflowY;
	
	    // In the case of controlled scrolling, notify.
	    if (this.props.ownerHeight !== nextProps.ownerHeight || this.props.scrollTop !== nextProps.scrollTop || this.props.scrollLeft !== nextProps.scrollLeft) {
	      this._didScrollStart();
	    }
	
	    // Cancel any pending debounced scroll handling and handle immediately.
	    this._didScrollStop.reset();
	    this._didScrollStopSync();
	
	    this.setState(this._calculateState(nextProps, this.state));
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    this._reportContentHeight();
	  },
	  render: function render() /*object*/{
	    var state = this.state;
	    var props = this.props;
	
	    var onColumnReorder = props.onColumnReorderEndCallback ? this._onColumnReorder : null;
	
	    var groupHeader;
	    if (state.useGroupHeader) {
	      groupHeader = _React2.default.createElement(_FixedDataTableRow2.default, {
	        key: 'group_header',
	        isScrolling: this._isScrolling,
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/header'), (0, _cx2.default)('public/fixedDataTable/header')),
	        width: state.width,
	        height: state.groupHeaderHeight,
	        cellGroupWrapperHeight: state.cellGroupWrapperHeight,
	        index: 0,
	        zIndex: 1,
	        offsetTop: 0,
	        scrollLeft: state.scrollX,
	        fixedColumns: state.groupHeaderFixedColumns,
	        fixedRightColumns: state.groupHeaderFixedRightColumns,
	        scrollableColumns: state.groupHeaderScrollableColumns,
	        onColumnResize: this._onColumnResize,
	        onColumnReorder: onColumnReorder,
	        onColumnReorderMove: this._onColumnReorderMove
	      });
	    }
	
	    var maxScrollY = this.state.maxScrollY;
	    var showScrollbarX = state.maxScrollX > 0 && state.overflowX !== 'hidden' && state.showScrollbarX !== false;
	    var showScrollbarY = maxScrollY > 0 && state.overflowY !== 'hidden' && state.showScrollbarY !== false;
	    var scrollbarXHeight = showScrollbarX ? _Scrollbar2.default.SIZE : 0;
	    var scrollbarYHeight = state.height - scrollbarXHeight - 2 * BORDER_HEIGHT - state.footerHeight;
	
	    var headerOffsetTop = state.useGroupHeader ? state.groupHeaderHeight : 0;
	    var bodyOffsetTop = headerOffsetTop + state.headerHeight;
	    scrollbarYHeight -= bodyOffsetTop;
	    var bottomSectionOffset = 0;
	    var footOffsetTop = props.maxHeight != null ? bodyOffsetTop + state.bodyHeight : bodyOffsetTop + scrollbarYHeight;
	    var rowsContainerHeight = footOffsetTop + state.footerHeight;
	
	    if (props.ownerHeight !== undefined && props.ownerHeight < state.height) {
	      bottomSectionOffset = props.ownerHeight - state.height;
	
	      footOffsetTop = Math.min(footOffsetTop, props.ownerHeight - state.footerHeight - scrollbarXHeight);
	
	      scrollbarYHeight = Math.max(0, footOffsetTop - bodyOffsetTop);
	    }
	
	    var verticalScrollbar;
	    if (showScrollbarY) {
	      verticalScrollbar = _React2.default.createElement(_Scrollbar2.default, {
	        size: scrollbarYHeight,
	        contentSize: scrollbarYHeight + maxScrollY,
	        onScroll: this._onVerticalScroll,
	        verticalTop: bodyOffsetTop,
	        position: state.scrollY
	      });
	    }
	
	    var horizontalScrollbar;
	    if (showScrollbarX) {
	      var scrollbarXWidth = state.width;
	      horizontalScrollbar = _React2.default.createElement(HorizontalScrollbar, {
	        contentSize: scrollbarXWidth + state.maxScrollX,
	        offset: bottomSectionOffset,
	        onScroll: this._onHorizontalScroll,
	        position: state.scrollX,
	        size: scrollbarXWidth
	      });
	    }
	
	    var dragKnob = _React2.default.createElement(_FixedDataTableColumnResizeHandle2.default, {
	      height: state.height,
	      initialWidth: state.columnResizingData.width || 0,
	      minWidth: state.columnResizingData.minWidth || 0,
	      maxWidth: state.columnResizingData.maxWidth || Number.MAX_VALUE,
	      visible: !!state.isColumnResizing,
	      leftOffset: state.columnResizingData.left || 0,
	      knobHeight: state.headerHeight,
	      initialEvent: state.columnResizingData.initialEvent,
	      onColumnResizeEnd: props.onColumnResizeEndCallback,
	      columnKey: state.columnResizingData.key,
	      touchEnabled: state.touchScrollEnabled
	    });
	
	    var footer = null;
	    if (state.footerHeight) {
	      footer = _React2.default.createElement(_FixedDataTableRow2.default, {
	        key: 'footer',
	        isScrolling: this._isScrolling,
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/footer'), (0, _cx2.default)('public/fixedDataTable/footer')),
	        width: state.width,
	        height: state.footerHeight,
	        index: -1,
	        zIndex: 1,
	        offsetTop: footOffsetTop,
	        fixedColumns: state.footFixedColumns,
	        fixedRightColumns: state.footFixedRightColumns,
	        scrollableColumns: state.footScrollableColumns,
	        scrollLeft: state.scrollX
	      });
	    }
	
	    var rows = this._renderRows(bodyOffsetTop);
	
	    var header = _React2.default.createElement(_FixedDataTableRow2.default, {
	      key: 'header',
	      isScrolling: this._isScrolling,
	      className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/header'), (0, _cx2.default)('public/fixedDataTable/header')),
	      width: state.width,
	      height: state.headerHeight,
	      cellGroupWrapperHeight: state.cellGroupWrapperHeight,
	      index: -1,
	      zIndex: 1,
	      offsetTop: headerOffsetTop,
	      scrollLeft: state.scrollX,
	      fixedColumns: state.headFixedColumns,
	      fixedRightColumns: state.headFixedRightColumns,
	      scrollableColumns: state.headScrollableColumns,
	      touchEnabled: state.touchScrollEnabled,
	      onColumnResize: this._onColumnResize,
	      onColumnReorder: onColumnReorder,
	      onColumnReorderMove: this._onColumnReorderMove,
	      onColumnReorderEnd: this._onColumnReorderEnd,
	      isColumnReordering: !!state.isColumnReordering,
	      columnReorderingData: state.columnReorderingData
	    });
	
	    var topShadow;
	    var bottomShadow;
	    if (state.scrollY) {
	      topShadow = _React2.default.createElement('div', {
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/topShadow'), (0, _cx2.default)('public/fixedDataTable/topShadow')),
	        style: { top: bodyOffsetTop }
	      });
	    }
	
	    if (state.ownerHeight != null && state.ownerHeight < state.height && state.scrollContentHeight + state.reservedHeight > state.ownerHeight || state.scrollY < maxScrollY) {
	      bottomShadow = _React2.default.createElement('div', {
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/bottomShadow'), (0, _cx2.default)('public/fixedDataTable/bottomShadow')),
	        style: { top: footOffsetTop }
	      });
	    }
	
	    return _React2.default.createElement('div', {
	      className: (0, _joinClasses2.default)(this.state.className, (0, _cx2.default)('fixedDataTableLayout/main'), (0, _cx2.default)('public/fixedDataTable/main')),
	      onWheel: this._wheelHandler.onWheel,
	      onTouchStart: this._touchHandler.onTouchStart,
	      onTouchEnd: this._touchHandler.onTouchEnd,
	      onTouchMove: this._touchHandler.onTouchMove,
	      onTouchCancel: this._touchHandler.onTouchCancel,
	      style: { height: state.height, width: state.width } }, _React2.default.createElement('div', {
	      className: (0, _cx2.default)('fixedDataTableLayout/rowsContainer'),
	      style: { height: rowsContainerHeight, width: state.width } }, dragKnob, groupHeader, header, rows, footer, topShadow, bottomShadow), verticalScrollbar, horizontalScrollbar);
	  },
	  _renderRows: function _renderRows( /*number*/offsetTop) /*object*/{
	    var state = this.state;
	
	    return _React2.default.createElement(_FixedDataTableBufferedRows2.default, {
	      isScrolling: this._isScrolling,
	      defaultRowHeight: state.rowHeight,
	      firstRowIndex: state.firstRowIndex,
	      firstRowOffset: state.firstRowOffset,
	      fixedColumns: state.bodyFixedColumns,
	      fixedRightColumns: state.bodyFixedRightColumns,
	      height: state.bodyHeight,
	      offsetTop: offsetTop,
	      onRowClick: state.onRowClick,
	      onRowDoubleClick: state.onRowDoubleClick,
	      onRowMouseDown: state.onRowMouseDown,
	      onRowMouseUp: state.onRowMouseUp,
	      onRowMouseEnter: state.onRowMouseEnter,
	      onRowMouseLeave: state.onRowMouseLeave,
	      onRowTouchStart: state.touchScrollEnabled ? state.onRowTouchStart : null,
	      onRowTouchEnd: state.touchScrollEnabled ? state.onRowTouchEnd : null,
	      onRowTouchMove: state.touchScrollEnabled ? state.onRowTouchMove : null,
	      rowClassNameGetter: state.rowClassNameGetter,
	      rowsCount: state.rowsCount,
	      rowGetter: state.rowGetter,
	      rowHeightGetter: state.rowHeightGetter,
	      subRowHeight: state.subRowHeight,
	      subRowHeightGetter: state.subRowHeightGetter,
	      rowExpanded: state.rowExpanded,
	      rowKeyGetter: state.rowKeyGetter,
	      scrollLeft: state.scrollX,
	      scrollableColumns: state.bodyScrollableColumns,
	      showLastRowBorder: true,
	      width: state.width,
	      rowPositionGetter: this._scrollHelper.getRowPosition,
	      bufferRowCount: this.state.bufferRowCount
	    });
	  },
	
	  /**
	   * This is called when a cell that is in the header of a column has its
	   * resizer knob clicked on. It displays the resizer and puts in the correct
	   * location on the table.
	   */
	  _onColumnResize: function _onColumnResize(
	  /*number*/combinedWidth,
	  /*number*/leftOffset,
	  /*number*/cellWidth,
	  /*?number*/cellMinWidth,
	  /*?number*/cellMaxWidth,
	  /*number|string*/columnKey,
	  /*object*/event) {
	
	    var coordinates = _FixedDataTableEventHelper2.default.getCoordinatesFromEvent(event);
	    var x = coordinates.x;
	    var y = coordinates.y;
	
	    this.setState({
	      isColumnResizing: true,
	      columnResizingData: {
	        left: leftOffset + combinedWidth - cellWidth,
	        width: cellWidth,
	        minWidth: cellMinWidth,
	        maxWidth: cellMaxWidth,
	        initialEvent: {
	          clientX: x,
	          clientY: y,
	          preventDefault: _emptyFunction2.default
	        },
	        key: columnKey
	      }
	    });
	  },
	  _onColumnReorder: function _onColumnReorder(
	  /*string*/columnKey,
	  /*number*/width,
	  /*number*/left,
	  /*object*/event) {
	    // No native support in IE11 for find, findIndex, or includes, so using some.
	    var isFixed = this.state.headFixedColumns.some(function (column) {
	      return column.props.columnKey === columnKey;
	    });
	
	    this.setState({
	      isColumnReordering: true,
	      columnReorderingData: {
	        dragDistance: 0,
	        isFixed: isFixed,
	        scrollStart: this.state.scrollX,
	        columnKey: columnKey,
	        columnWidth: width,
	        originalLeft: left,
	        columnsBefore: [],
	        columnsAfter: []
	      }
	    });
	  },
	  _onColumnReorderMove: function _onColumnReorderMove(
	  /*number*/deltaX) {
	    //NOTE Need to clone this object when use pureRendering
	    var reorderingData = _extends({}, this.state.columnReorderingData);
	    reorderingData.dragDistance = deltaX;
	    reorderingData.columnBefore = undefined;
	    reorderingData.columnAfter = undefined;
	
	    var isFixedColumn = this.state.columnReorderingData.isFixed;
	    var scrollX = this.state.scrollX;
	
	    if (!isFixedColumn) {
	      //Relative dragX position on scroll
	      var dragX = reorderingData.originalLeft - reorderingData.scrollStart + reorderingData.dragDistance;
	
	      var fixedColumnsWidth = this.state.bodyFixedColumns.reduce(function (sum, column) {
	        return sum + column.props.width;
	      }, 0);
	      var relativeWidth = this.props.width - fixedColumnsWidth;
	
	      //Scroll the table left or right if we drag near the edges of the table
	      if (dragX > relativeWidth - DRAG_SCROLL_BUFFER) {
	        scrollX = Math.min(scrollX + DRAG_SCROLL_SPEED, this.state.maxScrollX);
	      } else if (dragX <= DRAG_SCROLL_BUFFER) {
	        scrollX = Math.max(scrollX - DRAG_SCROLL_SPEED, 0);
	      }
	
	      reorderingData.dragDistance += this.state.scrollX - reorderingData.scrollStart;
	    }
	
	    this.setState({
	      scrollX: scrollX,
	      columnReorderingData: reorderingData
	    });
	  },
	  _onColumnReorderEnd: function _onColumnReorderEnd(
	  /*object*/props,
	  /*object*/event) {
	
	    var columnBefore = this.state.columnReorderingData.columnBefore;
	    var columnAfter = this.state.columnReorderingData.columnAfter;
	    var reorderColumn = this.state.columnReorderingData.columnKey;
	    var cancelReorder = this.state.columnReorderingData.cancelReorder;
	
	    this.setState({
	      isColumnReordering: false,
	      columnReorderingData: {}
	    });
	
	    if (cancelReorder) {
	      return;
	    }
	
	    this.props.onColumnReorderEndCallback({
	      columnBefore: columnBefore, columnAfter: columnAfter, reorderColumn: reorderColumn
	    });
	
	    var onHorizontalScroll = this.props.onHorizontalScroll;
	    if (this.state.columnReorderingData.scrollStart !== this.state.scrollX && onHorizontalScroll) {
	      onHorizontalScroll(this.state.scrollX);
	    };
	  },
	  _areColumnSettingsIdentical: function _areColumnSettingsIdentical(oldColumns, newColumns) {
	    if (oldColumns.length !== newColumns.length) {
	      return false;
	    }
	    for (var index = 0; index < oldColumns.length; ++index) {
	      if (!(0, _shallowEqual2.default)(oldColumns[index].props, newColumns[index].props)) {
	        return false;
	      }
	    }
	    return true;
	  },
	  _populateColumnsAndColumnData: function _populateColumnsAndColumnData(columns, columnGroups, oldState) {
	    var canReuseColumnSettings = false;
	    var canReuseColumnGroupSettings = false;
	
	    if (oldState && oldState.columns) {
	      canReuseColumnSettings = this._areColumnSettingsIdentical(columns, oldState.columns);
	    }
	    if (oldState && oldState.columnGroups && columnGroups) {
	      canReuseColumnGroupSettings = this._areColumnSettingsIdentical(columnGroups, oldState.columnGroups);
	    }
	
	    var columnInfo = {};
	    if (canReuseColumnSettings) {
	      columnInfo.bodyFixedColumns = oldState.bodyFixedColumns;
	      columnInfo.bodyFixedRightColumns = oldState.bodyFixedRightColumns;
	      columnInfo.bodyScrollableColumns = oldState.bodyScrollableColumns;
	      columnInfo.headFixedColumns = oldState.headFixedColumns;
	      columnInfo.headFixedRightColumns = oldState.headFixedRightColumns;
	      columnInfo.headScrollableColumns = oldState.headScrollableColumns;
	      columnInfo.footFixedColumns = oldState.footFixedColumns;
	      columnInfo.footFixedRightColumns = oldState.footFixedRightColumns;
	      columnInfo.footScrollableColumns = oldState.footScrollableColumns;
	    } else {
	      var bodyColumnTypes = this._splitColumnTypes(columns);
	      columnInfo.bodyFixedColumns = bodyColumnTypes.fixed;
	      columnInfo.bodyFixedRightColumns = bodyColumnTypes.fixedRight;
	      columnInfo.bodyScrollableColumns = bodyColumnTypes.scrollable;
	
	      var headColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columns));
	      columnInfo.headFixedColumns = headColumnTypes.fixed;
	      columnInfo.headFixedRightColumns = headColumnTypes.fixedRight;
	      columnInfo.headScrollableColumns = headColumnTypes.scrollable;
	
	      var footColumnTypes = this._splitColumnTypes(this._selectColumnElement(FOOTER, columns));
	      columnInfo.footFixedColumns = footColumnTypes.fixed;
	      columnInfo.footFixedRightColumns = footColumnTypes.fixedRight;
	      columnInfo.footScrollableColumns = footColumnTypes.scrollable;
	    }
	
	    if (canReuseColumnGroupSettings) {
	      columnInfo.groupHeaderFixedColumns = oldState.groupHeaderFixedColumns;
	      columnInfo.groupHeaderFixedRightColumns = oldState.groupHeaderFixedRightColumns;
	      columnInfo.groupHeaderScrollableColumns = oldState.groupHeaderScrollableColumns;
	    } else {
	      if (columnGroups) {
	        var groupHeaderColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columnGroups));
	        columnInfo.groupHeaderFixedColumns = groupHeaderColumnTypes.fixed;
	        columnInfo.groupHeaderFixedRightColumns = groupHeaderColumnTypes.fixedRight;
	        columnInfo.groupHeaderScrollableColumns = groupHeaderColumnTypes.scrollable;
	      }
	    }
	
	    return columnInfo;
	  },
	  _calculateState: function _calculateState( /*object*/props, /*?object*/oldState) /*object*/{
	    (0, _invariant2.default)(props.height !== undefined || props.maxHeight !== undefined, 'You must set either a height or a maxHeight');
	
	    var children = [];
	    ReactChildren.forEach(props.children, function (child, index) {
	      if (child == null) {
	        return;
	      }
	      (0, _invariant2.default)(child.type.__TableColumnGroup__ || child.type.__TableColumn__, 'child type should be <FixedDataTableColumn /> or ' + '<FixedDataTableColumnGroup />');
	      children.push(child);
	    });
	
	    var scrollState;
	    var firstRowIndex = oldState && oldState.firstRowIndex || 0;
	    var firstRowOffset = oldState && oldState.firstRowOffset || 0;
	    var scrollY = oldState ? oldState.scrollY : 0;
	    var scrollX = oldState ? oldState.scrollX : 0;
	
	    var lastScrollLeft = oldState ? oldState.scrollLeft : 0;
	    if (props.scrollLeft !== undefined && props.scrollLeft !== lastScrollLeft) {
	      scrollX = props.scrollLeft;
	    }
	
	    if (oldState && (props.rowsCount !== oldState.rowsCount || props.rowHeight !== oldState.rowHeight || props.height !== oldState.height)) {
	      // Number of rows changed, try to scroll to the row from before the
	      // change
	      var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);
	
	      var oldViewportHeight = this._scrollHelper._viewportHeight;
	
	      this._scrollHelper = new _FixedDataTableScrollHelper2.default(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter, props.subRowHeight, props.subRowHeightGetter);
	      scrollState = this._scrollHelper.scrollToRow(firstRowIndex, firstRowOffset);
	      firstRowIndex = scrollState.index;
	      firstRowOffset = scrollState.offset;
	      scrollY = scrollState.position;
	    } else if (oldState) {
	      if (props.rowHeightGetter !== oldState.rowHeightGetter) {
	        this._scrollHelper.setRowHeightGetter(props.rowHeightGetter);
	      }
	      if (props.subRowHeightGetter !== oldState.subRowHeightGetter) {
	        this._scrollHelper.setSubRowHeightGetter(props.subRowHeightGetter);
	      }
	    }
	
	    // Figure out if the vertical scrollbar will be visible first, 
	    // because it will determine the width of the table
	    var useGroupHeader = false;
	    var groupHeaderHeight = 0;
	
	    if (children.length && children[0].type.__TableColumnGroup__) {
	      useGroupHeader = true;
	      groupHeaderHeight = props.groupHeaderHeight;
	    }
	
	    var useMaxHeight = props.height === undefined;
	    var height = Math.round(useMaxHeight ? props.maxHeight : props.height);
	    var totalHeightReserved = props.footerHeight + props.headerHeight + groupHeaderHeight + 2 * BORDER_HEIGHT;
	    var bodyHeight = height - totalHeightReserved;
	    var scrollContentHeight = this._scrollHelper.getContentHeight();
	    var totalHeightNeeded = scrollContentHeight + totalHeightReserved;
	    var maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);
	
	    // If vertical scrollbar is necessary, adjust the table width to give it room
	    var adjustedWidth = props.width;
	    if (maxScrollY) {
	      adjustedWidth = adjustedWidth - _Scrollbar2.default.SIZE - 1;
	    }
	
	    var lastScrollToRow = oldState ? oldState.scrollToRow : undefined;
	    if (props.scrollToRow != null && (props.scrollToRow !== lastScrollToRow || viewportHeight !== oldViewportHeight)) {
	      scrollState = this._scrollHelper.scrollRowIntoView(props.scrollToRow);
	      firstRowIndex = scrollState.index;
	      firstRowOffset = scrollState.offset;
	      scrollY = scrollState.position;
	    }
	
	    var lastScrollTop = oldState ? oldState.scrollTop : undefined;
	    if (props.scrollTop != null && props.scrollTop !== lastScrollTop) {
	      scrollState = this._scrollHelper.scrollTo(props.scrollTop);
	      firstRowIndex = scrollState.index;
	      firstRowOffset = scrollState.offset;
	      scrollY = scrollState.position;
	    }
	
	    var columnResizingData;
	    if (props.isColumnResizing) {
	      columnResizingData = oldState && oldState.columnResizingData;
	    } else {
	      columnResizingData = EMPTY_OBJECT;
	    }
	
	    var columns;
	    var columnGroups;
	
	    if (useGroupHeader) {
	      var columnGroupSettings = _FixedDataTableWidthHelper2.default.adjustColumnGroupWidths(children, adjustedWidth);
	      columns = columnGroupSettings.columns;
	      columnGroups = columnGroupSettings.columnGroups;
	    } else {
	      columns = _FixedDataTableWidthHelper2.default.adjustColumnWidths(children, adjustedWidth);
	    }
	
	    var columnInfo = this._populateColumnsAndColumnData(columns, columnGroups, oldState);
	
	    var lastScrollToColumn = oldState ? oldState.scrollToColumn : undefined;
	    if (props.scrollToColumn !== null && props.scrollToColumn !== lastScrollToColumn) {
	      // If selected column is a fixed column, don't scroll
	      var fixedColumnsCount = columnInfo.bodyFixedColumns.length;
	      if (props.scrollToColumn >= fixedColumnsCount) {
	        var totalFixedColumnsWidth = 0;
	        var i, column;
	        for (i = 0; i < columnInfo.bodyFixedColumns.length; ++i) {
	          column = columnInfo.bodyFixedColumns[i];
	          totalFixedColumnsWidth += column.props.width;
	        }
	
	        var j;
	        for (j = 0; j < columnInfo.bodyFixedRightColumns.length; ++j) {
	          column = columnInfo.bodyFixedRightColumns[j];
	          totalFixedColumnsWidth += column.props.width;
	        }
	
	        // Convert column index (0 indexed) to scrollable index (0 indexed)
	        // and clamp to max scrollable index
	        var scrollableColumnIndex = Math.min(props.scrollToColumn - fixedColumnsCount, columnInfo.bodyScrollableColumns.length - 1);
	
	        // Sum width for all columns before column
	        var previousColumnsWidth = 0;
	        for (i = 0; i < scrollableColumnIndex; ++i) {
	          column = columnInfo.bodyScrollableColumns[i];
	          previousColumnsWidth += column.props.width;
	        }
	
	        // Get width of scrollable columns in viewport
	        var availableScrollWidth = adjustedWidth - totalFixedColumnsWidth;
	
	        // Get width of specified column
	        var selectedColumnWidth = columnInfo.bodyScrollableColumns[scrollableColumnIndex].props.width;
	
	        // Must scroll at least far enough for end of column (prevColWidth + selColWidth)
	        // to be in viewport (availableScrollWidth = viewport width)
	        var minAcceptableScrollPosition = previousColumnsWidth + selectedColumnWidth - availableScrollWidth;
	
	        // If scrolled less than minimum amount, scroll to minimum amount
	        // so column on right of viewport
	        if (scrollX < minAcceptableScrollPosition) {
	          scrollX = minAcceptableScrollPosition;
	        }
	
	        // If scrolled more than previous columns, at least part of column will be offscreen to left
	        // Scroll so column is flush with left edge of viewport
	        if (scrollX > previousColumnsWidth) {
	          scrollX = previousColumnsWidth;
	        }
	      }
	    }
	
	    var scrollContentWidth = _FixedDataTableWidthHelper2.default.getTotalWidth(columns);
	
	    var horizontalScrollbarVisible = scrollContentWidth > adjustedWidth && props.overflowX !== 'hidden' && props.showScrollbarX !== false;
	
	    if (horizontalScrollbarVisible) {
	      bodyHeight -= _Scrollbar2.default.SIZE;
	      totalHeightNeeded += _Scrollbar2.default.SIZE;
	      totalHeightReserved += _Scrollbar2.default.SIZE;
	      // If the horizontal scrollbar appears, the vertical scrollbar may now be needed
	      // since the bottom row might be partially obscured by the horizontal scrollbar.
	      // We also need to make sure we don't double-dip and adjust the width twice
	      var notAdjusted = adjustedWidth === props.width;
	      maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);
	      if (notAdjusted && maxScrollY) {
	        adjustedWidth = adjustedWidth - _Scrollbar2.default.SIZE - 1;
	      }
	    }
	
	    var maxScrollX = Math.max(0, scrollContentWidth - adjustedWidth);
	    scrollX = Math.min(scrollX, maxScrollX);
	    scrollY = Math.min(scrollY, maxScrollY);
	
	    if (!maxScrollY) {
	      // no vertical scrollbar necessary, use the totals we tracked so we
	      // can shrink-to-fit vertically
	      if (useMaxHeight) {
	        height = totalHeightNeeded;
	      }
	      bodyHeight = totalHeightNeeded - totalHeightReserved;
	    }
	
	    this._scrollHelper.setViewportHeight(bodyHeight);
	
	    // This calculation is synonymous to Element.scrollTop
	    var scrollTop = Math.abs(firstRowOffset - this._scrollHelper.getRowPosition(firstRowIndex));
	    // This case can happen when the user is completely scrolled down and resizes the viewport to be taller vertically.
	    // This is because we set the viewport height after having calculated the rows
	    if (scrollTop !== scrollY) {
	      scrollTop = maxScrollY;
	      scrollState = this._scrollHelper.scrollTo(scrollTop);
	      firstRowIndex = scrollState.index;
	      firstRowOffset = scrollState.offset;
	      scrollY = scrollState.position;
	    }
	
	    var cellGroupWrapperHeight = props.cellGroupWrapperHeight;
	
	    // The order of elements in this object metters and bringing bodyHeight,
	    // height or useGroupHeader to the top can break various features
	    var newState = _extends({
	      isColumnResizing: oldState && oldState.isColumnResizing
	    }, columnInfo, props, {
	
	      columns: columns,
	      columnGroups: columnGroups,
	      columnResizingData: columnResizingData,
	      firstRowIndex: firstRowIndex,
	      firstRowOffset: firstRowOffset,
	      horizontalScrollbarVisible: horizontalScrollbarVisible,
	      maxScrollX: maxScrollX,
	      maxScrollY: maxScrollY,
	      reservedHeight: totalHeightReserved,
	      scrollContentHeight: scrollContentHeight,
	      scrollX: scrollX,
	      scrollY: scrollY,
	      // These properties may overwrite properties defined in
	      // columnInfo and props
	      bodyHeight: bodyHeight,
	      height: height,
	      cellGroupWrapperHeight: cellGroupWrapperHeight,
	      groupHeaderHeight: groupHeaderHeight,
	      useGroupHeader: useGroupHeader
	    });
	
	    return newState;
	  },
	  _selectColumnElement: function _selectColumnElement( /*string*/type, /*array*/columns) /*array*/{
	    var newColumns = [];
	    for (var i = 0; i < columns.length; ++i) {
	      var column = columns[i];
	      newColumns.push(_React2.default.cloneElement(column, {
	        cell: type ? column.props[type] : column.props[CELL]
	      }));
	    }
	    return newColumns;
	  },
	  _splitColumnTypes: function _splitColumnTypes( /*array*/columns) /*object*/{
	    var fixedColumns = [];
	    var fixedRightColumns = [];
	    var scrollableColumns = [];
	    for (var i = 0; i < columns.length; ++i) {
	      if (columns[i].props.fixed) {
	        fixedColumns.push(columns[i]);
	      } else if (columns[i].props.fixedRight) {
	        fixedRightColumns.push(columns[i]);
	      } else {
	        scrollableColumns.push(columns[i]);
	      }
	    }
	    return {
	      fixed: fixedColumns,
	      fixedRight: fixedRightColumns,
	      scrollable: scrollableColumns
	    };
	  },
	  _onScroll: function _onScroll( /*number*/deltaX, /*number*/deltaY) {
	    if (!this._isScrolling) {
	      this._didScrollStart();
	    }
	    var x = this.state.scrollX;
	    if (Math.abs(deltaY) > Math.abs(deltaX) && this.props.overflowY !== 'hidden') {
	      var scrollState = this._scrollHelper.scrollBy(Math.round(deltaY));
	      var onVerticalScroll = this.props.onVerticalScroll;
	      if (onVerticalScroll ? onVerticalScroll(scrollState.position) : true) {
	        var maxScrollY = Math.max(0, scrollState.contentHeight - this.state.bodyHeight);
	        this.setState({
	          firstRowIndex: scrollState.index,
	          firstRowOffset: scrollState.offset,
	          scrollY: scrollState.position,
	          scrollContentHeight: scrollState.contentHeight,
	          maxScrollY: maxScrollY
	        });
	      }
	    } else if (deltaX && this.props.overflowX !== 'hidden') {
	      x += deltaX;
	      x = x < 0 ? 0 : x;
	      x = x > this.state.maxScrollX ? this.state.maxScrollX : x;
	
	      //NOTE (asif) This is a hacky workaround to prevent FDT from setting its internal state
	      var onHorizontalScroll = this.props.onHorizontalScroll;
	      if (onHorizontalScroll ? onHorizontalScroll(x) : true) {
	        this.setState({
	          scrollX: x
	        });
	      }
	    }
	
	    this._didScrollStop();
	  },
	  _onHorizontalScroll: function _onHorizontalScroll( /*number*/scrollPos) {
	    if (scrollPos === this.state.scrollX) {
	      return;
	    }
	
	    if (!this._isScrolling) {
	      this._didScrollStart();
	    }
	    var onHorizontalScroll = this.props.onHorizontalScroll;
	    if (onHorizontalScroll ? onHorizontalScroll(scrollPos) : true) {
	      this.setState({
	        scrollX: scrollPos
	      });
	    }
	    this._didScrollStop();
	  },
	  _onVerticalScroll: function _onVerticalScroll( /*number*/scrollPos) {
	    if (scrollPos === this.state.scrollY) {
	      return;
	    }
	
	    if (!this._isScrolling) {
	      this._didScrollStart();
	    }
	    var scrollState = this._scrollHelper.scrollTo(Math.round(scrollPos));
	
	    var onVerticalScroll = this.props.onVerticalScroll;
	    if (onVerticalScroll ? onVerticalScroll(scrollState.position) : true) {
	      this.setState({
	        firstRowIndex: scrollState.index,
	        firstRowOffset: scrollState.offset,
	        scrollY: scrollState.position,
	        scrollContentHeight: scrollState.contentHeight
	      });
	      this._didScrollStop();
	    }
	  },
	  _didScrollStart: function _didScrollStart() {
	    if (this._isScrolling) {
	      return;
	    }
	
	    this._isScrolling = true;
	    if (this.props.onScrollStart) {
	      this.props.onScrollStart(this.state.scrollX, this.state.scrollY, this.state.firstRowIndex);
	    }
	  },
	
	  // We need two versions of this function, one to finish up synchronously (for
	  // example, in componentWillUnmount), and a debounced version for normal
	  // scroll handling.
	  _didScrollStopSync: function _didScrollStopSync() {
	    if (!this._isScrolling) {
	      return;
	    }
	
	    this._isScrolling = false;
	    this.setState({ redraw: true });
	    if (this.props.onScrollEnd) {
	      this.props.onScrollEnd(this.state.scrollX, this.state.scrollY, this.state.firstRowIndex);
	    }
	  }
	});
	
	var HorizontalScrollbar = (0, _createReactClass2.default)({
	  displayName: 'HorizontalScrollbar',
	  mixins: [_ReactComponentWithPureRenderMixin2.default],
	
	  propTypes: {
	    contentSize: _propTypes2.default.number.isRequired,
	    offset: _propTypes2.default.number.isRequired,
	    onScroll: _propTypes2.default.func.isRequired,
	    position: _propTypes2.default.number.isRequired,
	    size: _propTypes2.default.number.isRequired
	  },
	
	  componentWillMount: function componentWillMount() {
	    this._initialRender = true;
	  },
	  componentDidMount: function componentDidMount() {
	    this._initialRender = false;
	  },
	  render: function render() /*object*/{
	    var outerContainerStyle = {
	      height: _Scrollbar2.default.SIZE,
	      width: this.props.size
	    };
	    var innerContainerStyle = {
	      height: _Scrollbar2.default.SIZE,
	      position: 'absolute',
	      overflow: 'hidden',
	      width: this.props.size
	    };
	    (0, _FixedDataTableTranslateDOMPosition2.default)(innerContainerStyle, 0, this.props.offset, this._initialRender);
	
	    return _React2.default.createElement('div', {
	      className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/horizontalScrollbar'), (0, _cx2.default)('public/fixedDataTable/horizontalScrollbar')),
	      style: outerContainerStyle }, _React2.default.createElement('div', { style: innerContainerStyle }, _React2.default.createElement(_Scrollbar2.default, _extends({}, this.props, {
	      isOpaque: true,
	      orientation: 'horizontal',
	      offset: undefined
	    }))));
	  }
	});
	
	module.exports = FixedDataTable;

/***/ }),
/* 196 */
/*!*********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableBufferedRows.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _createReactClass = __webpack_require__(/*! create-react-class */ 21);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _FixedDataTableRowBuffer = __webpack_require__(/*! ./FixedDataTableRowBuffer */ 202);
	
	var _FixedDataTableRowBuffer2 = _interopRequireDefault(_FixedDataTableRowBuffer);
	
	var _FixedDataTableRow = __webpack_require__(/*! ./FixedDataTableRow */ 118);
	
	var _FixedDataTableRow2 = _interopRequireDefault(_FixedDataTableRow);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	var _emptyFunction = __webpack_require__(/*! ./emptyFunction */ 22);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	var _joinClasses = __webpack_require__(/*! ./joinClasses */ 35);
	
	var _joinClasses2 = _interopRequireDefault(_joinClasses);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableBufferedRows
	 * @typechecks
	 */
	
	var FixedDataTableBufferedRows = (0, _createReactClass2.default)({
	  displayName: 'FixedDataTableBufferedRows',
	
	  propTypes: {
	    bufferRowCount: _propTypes2.default.number,
	    isScrolling: _propTypes2.default.bool,
	    defaultRowHeight: _propTypes2.default.number.isRequired,
	    firstRowIndex: _propTypes2.default.number.isRequired,
	    firstRowOffset: _propTypes2.default.number.isRequired,
	    fixedColumns: _propTypes2.default.array.isRequired,
	    fixedRightColumns: _propTypes2.default.array.isRequired,
	    height: _propTypes2.default.number.isRequired,
	    offsetTop: _propTypes2.default.number.isRequired,
	    onRowClick: _propTypes2.default.func,
	    onRowDoubleClick: _propTypes2.default.func,
	    onRowMouseDown: _propTypes2.default.func,
	    onRowMouseUp: _propTypes2.default.func,
	    onRowMouseEnter: _propTypes2.default.func,
	    onRowMouseLeave: _propTypes2.default.func,
	    onRowTouchStart: _propTypes2.default.func,
	    onRowTouchEnd: _propTypes2.default.func,
	    onRowTouchMove: _propTypes2.default.func,
	    rowClassNameGetter: _propTypes2.default.func,
	    rowsCount: _propTypes2.default.number.isRequired,
	    rowHeightGetter: _propTypes2.default.func,
	    subRowHeight: _propTypes2.default.number,
	    subRowHeightGetter: _propTypes2.default.func,
	    rowExpanded: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.func]),
	    rowKeyGetter: _propTypes2.default.func,
	    rowPositionGetter: _propTypes2.default.func.isRequired,
	    scrollLeft: _propTypes2.default.number.isRequired,
	    scrollableColumns: _propTypes2.default.array.isRequired,
	    showLastRowBorder: _propTypes2.default.bool,
	    width: _propTypes2.default.number.isRequired
	  },
	
	  getInitialState: function getInitialState() /*object*/{
	    this._rowBuffer = new _FixedDataTableRowBuffer2.default(this.props.rowsCount, this.props.defaultRowHeight, this.props.height, this._getRowHeight, this.props.bufferRowCount);
	    return {
	      rowsToRender: this._rowBuffer.getRows(this.props.firstRowIndex, this.props.firstRowOffset)
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    this._staticRowArray = [];
	    this._initialRender = true;
	  },
	  componentDidMount: function componentDidMount() {
	    setTimeout(this._updateBuffer, 1000);
	    this._initialRender = false;
	  },
	  componentWillReceiveProps: function componentWillReceiveProps( /*object*/nextProps) {
	    if (nextProps.rowsCount !== this.props.rowsCount || nextProps.defaultRowHeight !== this.props.defaultRowHeight || nextProps.height !== this.props.height) {
	      this._rowBuffer = new _FixedDataTableRowBuffer2.default(nextProps.rowsCount, nextProps.defaultRowHeight, nextProps.height, this._getRowHeight, this.props.bufferRowCount);
	    }
	    if (this.props.isScrolling && !nextProps.isScrolling) {
	      this._updateBuffer();
	    } else {
	      this.setState({
	        rowsToRender: this._rowBuffer.getRows(nextProps.firstRowIndex, nextProps.firstRowOffset)
	      });
	    }
	  },
	  _updateBuffer: function _updateBuffer() {
	    if (this._rowBuffer) {
	      this.setState({
	        rowsToRender: this._rowBuffer.getRowsWithUpdatedBuffer()
	      });
	    }
	  },
	  shouldComponentUpdate: function shouldComponentUpdate() /*boolean*/{
	    // Don't add PureRenderMixin to this component please.
	    return true;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._rowBuffer = null;
	    this._staticRowArray.length = 0;
	  },
	  render: function render() /*object*/{
	    var props = this.props;
	    var rowClassNameGetter = props.rowClassNameGetter || _emptyFunction2.default;
	    var rowPositionGetter = props.rowPositionGetter;
	
	    var rowsToRender = this.state.rowsToRender;
	
	    //Sort the rows, we slice first to avoid changing original
	    var sortedRowsToRender = rowsToRender.slice().sort(function (a, b) {
	      return a - b;
	    });
	    var rowPositions = {};
	
	    //Row position calculation requires that rows are calculated in order
	    sortedRowsToRender.forEach(function (rowIndex) {
	      rowPositions[rowIndex] = rowPositionGetter(rowIndex);
	    });
	
	    this._staticRowArray.length = rowsToRender.length;
	
	    var baseOffsetTop = props.firstRowOffset - props.rowPositionGetter(props.firstRowIndex) + props.offsetTop;
	
	    for (var i = 0; i < rowsToRender.length; ++i) {
	      var rowIndex = rowsToRender[i];
	      var currentRowHeight = this._getRowHeight(rowIndex);
	      var currentSubRowHeight = this._getSubRowHeight(rowIndex);
	      var rowOffsetTop = baseOffsetTop + rowPositions[rowIndex];
	      var rowKey = props.rowKeyGetter ? props.rowKeyGetter(rowIndex) : i;
	
	      var hasBottomBorder = rowIndex === props.rowsCount - 1 && props.showLastRowBorder;
	
	      this._staticRowArray[i] = _React2.default.createElement(_FixedDataTableRow2.default, {
	        key: rowKey,
	        isScrolling: props.isScrolling,
	        index: rowIndex,
	        width: props.width,
	        height: currentRowHeight,
	        subRowHeight: currentSubRowHeight,
	        rowExpanded: props.rowExpanded,
	        scrollLeft: Math.round(props.scrollLeft),
	        offsetTop: Math.round(rowOffsetTop),
	        fixedColumns: props.fixedColumns,
	        fixedRightColumns: props.fixedRightColumns,
	        scrollableColumns: props.scrollableColumns,
	        onClick: props.onRowClick,
	        onDoubleClick: props.onRowDoubleClick,
	        onMouseDown: props.onRowMouseDown,
	        onMouseUp: props.onRowMouseUp,
	        onMouseEnter: props.onRowMouseEnter,
	        onMouseLeave: props.onRowMouseLeave,
	        onTouchStart: props.onRowTouchStart,
	        onTouchEnd: props.onRowTouchEnd,
	        onTouchMove: props.onRowTouchMove,
	        className: (0, _joinClasses2.default)(rowClassNameGetter(rowIndex), (0, _cx2.default)('public/fixedDataTable/bodyRow'), (0, _cx2.default)({
	          'fixedDataTableLayout/hasBottomBorder': hasBottomBorder,
	          'public/fixedDataTable/hasBottomBorder': hasBottomBorder
	        }))
	      });
	    }
	
	    return _React2.default.createElement('div', null, this._staticRowArray);
	  },
	  _getRowHeight: function _getRowHeight( /*number*/index) /*number*/{
	    return this.props.rowHeightGetter ? this.props.rowHeightGetter(index) : this.props.defaultRowHeight;
	  },
	  _getSubRowHeight: function _getSubRowHeight( /*number*/index) /*number*/{
	    return this.props.subRowHeightGetter ? this.props.subRowHeightGetter(index) : this.props.subRowHeight;
	  }
	});
	
	module.exports = FixedDataTableBufferedRows;

/***/ }),
/* 197 */
/*!*************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableCell.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _FixedDataTableCellDefault = __webpack_require__(/*! ./FixedDataTableCellDefault */ 114);
	
	var _FixedDataTableCellDefault2 = _interopRequireDefault(_FixedDataTableCellDefault);
	
	var _FixedDataTableColumnReorderHandle = __webpack_require__(/*! ././FixedDataTableColumnReorderHandle */ 199);
	
	var _FixedDataTableColumnReorderHandle2 = _interopRequireDefault(_FixedDataTableColumnReorderHandle);
	
	var _FixedDataTableHelper = __webpack_require__(/*! ./FixedDataTableHelper */ 117);
	
	var _FixedDataTableHelper2 = _interopRequireDefault(_FixedDataTableHelper);
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _createReactClass = __webpack_require__(/*! create-react-class */ 21);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	var _joinClasses = __webpack_require__(/*! ./joinClasses */ 35);
	
	var _joinClasses2 = _interopRequireDefault(_joinClasses);
	
	var _shallowEqual = __webpack_require__(/*! ./shallowEqual */ 121);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	} /**
	   * Copyright Schrodinger, LLC
	   * All rights reserved.
	   *
	   * This source code is licensed under the BSD-style license found in the
	   * LICENSE file in the root directory of this source tree. An additional grant
	   * of patent rights can be found in the PATENTS file in the same directory.
	   *
	   * @providesModule FixedDataTableCell
	   * @typechecks
	   */
	
	var DIR_SIGN = _FixedDataTableHelper2.default.DIR_SIGN;
	
	var DEFAULT_PROPS = {
	  align: 'left',
	  highlighted: false
	};
	
	var FixedDataTableCell = (0, _createReactClass2.default)({
	  displayName: 'FixedDataTableCell',
	
	  /**
	   * PropTypes are disabled in this component, because having them on slows
	   * down the FixedDataTable hugely in DEV mode. You can enable them back for
	   * development, but please don't commit this component with enabled propTypes.
	   */
	  propTypes_DISABLED_FOR_PERFORMANCE: {
	    isScrolling: _propTypes2.default.bool,
	    align: _propTypes2.default.oneOf(['left', 'center', 'right']),
	    className: _propTypes2.default.string,
	    highlighted: _propTypes2.default.bool,
	    width: _propTypes2.default.number.isRequired,
	    minWidth: _propTypes2.default.number,
	    maxWidth: _propTypes2.default.number,
	    height: _propTypes2.default.number.isRequired,
	
	    cell: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.element, _propTypes2.default.func]),
	
	    columnKey: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
	
	    /**
	     * The row index that will be passed to `cellRenderer` to render.
	     */
	    rowIndex: _propTypes2.default.number.isRequired,
	
	    /**
	     * Callback for when resizer knob (in FixedDataTableCell) is clicked
	     * to initialize resizing. Please note this is only on the cells
	     * in the header.
	     * @param number combinedWidth
	     * @param number left
	     * @param number width
	     * @param number minWidth
	     * @param number maxWidth
	     * @param number|string columnKey
	     * @param object event
	     */
	    onColumnResize: _propTypes2.default.func,
	    onColumnReorder: _propTypes2.default.func,
	
	    /**
	     * The left offset in pixels of the cell.
	     */
	    left: _propTypes2.default.number,
	
	    /**
	     * Flag for enhanced performance check
	     */
	    pureRendering: _propTypes2.default.bool,
	
	    /**
	     * Whether touch is enabled or not.
	     */
	    touchEnabled: _propTypes2.default.bool
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      isReorderingThisColumn: false,
	      displacement: 0,
	      reorderingDisplacement: 0
	    };
	  },
	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    if (nextProps.isScrolling && this.props.rowIndex === nextProps.rowIndex) {
	      return false;
	    }
	
	    //Performance check not enabled
	    if (!nextProps.pureRendering) {
	      return true;
	    }
	
	    var _props = this.props,
	        oldCell = _props.cell,
	        oldIsScrolling = _props.isScrolling,
	        oldProps = _objectWithoutProperties(_props, ['cell', 'isScrolling']);
	
	    var newCell = nextProps.cell,
	        newIsScrolling = nextProps.isScrolling,
	        newProps = _objectWithoutProperties(nextProps, ['cell', 'isScrolling']);
	
	    if (!(0, _shallowEqual2.default)(oldProps, newProps)) {
	      return true;
	    }
	
	    if (!oldCell || !newCell || oldCell.type !== newCell.type) {
	      return true;
	    }
	
	    if (!(0, _shallowEqual2.default)(oldCell.props, newCell.props)) {
	      return true;
	    }
	
	    return false;
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(props) {
	    var left = props.left + this.state.displacement;
	
	    var newState = {
	      isReorderingThisColumn: false
	    };
	
	    if (props.isColumnReordering) {
	      var originalLeft = props.columnReorderingData.originalLeft;
	      var reorderCellLeft = originalLeft + props.columnReorderingData.dragDistance;
	      var farthestPossiblePoint = props.columnGroupWidth - props.columnReorderingData.columnWidth;
	
	      // ensure the cell isn't being dragged out of the column group
	      reorderCellLeft = Math.max(reorderCellLeft, 0);
	      reorderCellLeft = Math.min(reorderCellLeft, farthestPossiblePoint);
	
	      if (props.columnKey === props.columnReorderingData.columnKey) {
	        newState.displacement = reorderCellLeft - props.left;
	        newState.isReorderingThisColumn = true;
	      } else {
	        var reorderCellRight = reorderCellLeft + props.columnReorderingData.columnWidth;
	        var reorderCellCenter = reorderCellLeft + props.columnReorderingData.columnWidth / 2;
	        var centerOfThisColumn = left + props.width / 2;
	
	        var cellIsBeforeOneBeingDragged = reorderCellCenter > centerOfThisColumn;
	        var cellWasOriginallyBeforeOneBeingDragged = originalLeft > props.left;
	        var changedPosition = false;
	
	        var dragPoint, thisCellPoint;
	        if (cellIsBeforeOneBeingDragged) {
	          if (reorderCellLeft < centerOfThisColumn) {
	            changedPosition = true;
	            if (cellWasOriginallyBeforeOneBeingDragged) {
	              newState.displacement = props.columnReorderingData.columnWidth;
	            } else {
	              newState.displacement = 0;
	            }
	          }
	        } else {
	          if (reorderCellRight > centerOfThisColumn) {
	            changedPosition = true;
	            if (cellWasOriginallyBeforeOneBeingDragged) {
	              newState.displacement = 0;
	            } else {
	              newState.displacement = props.columnReorderingData.columnWidth * -1;
	            }
	          }
	        }
	
	        if (changedPosition) {
	          if (cellIsBeforeOneBeingDragged) {
	            if (!props.columnReorderingData.columnAfter) {
	              props.columnReorderingData.columnAfter = props.columnKey;
	            }
	          } else {
	            props.columnReorderingData.columnBefore = props.columnKey;
	          }
	        } else if (cellIsBeforeOneBeingDragged) {
	          props.columnReorderingData.columnBefore = props.columnKey;
	        } else if (!props.columnReorderingData.columnAfter) {
	          props.columnReorderingData.columnAfter = props.columnKey;
	        }
	      }
	    } else {
	      newState.displacement = 0;
	    }
	
	    this.setState(newState);
	  },
	  getDefaultProps: function getDefaultProps() /*object*/{
	    return DEFAULT_PROPS;
	  },
	  render: function render() /*object*/{
	    var _props2 = this.props,
	        height = _props2.height,
	        width = _props2.width,
	        columnKey = _props2.columnKey,
	        props = _objectWithoutProperties(_props2, ['height', 'width', 'columnKey']);
	
	    var style = {
	      height: height,
	      width: width
	    };
	
	    if (DIR_SIGN === 1) {
	      style.left = props.left;
	    } else {
	      style.right = props.left;
	    }
	
	    if (this.state.isReorderingThisColumn) {
	      style.transform = 'translateX(' + this.state.displacement + 'px) translateZ(0)';
	      style.zIndex = 1;
	    }
	
	    var className = (0, _joinClasses2.default)((0, _cx2.default)({
	      'fixedDataTableCellLayout/main': true,
	      'fixedDataTableCellLayout/lastChild': props.lastChild,
	      'fixedDataTableCellLayout/alignRight': props.align === 'right',
	      'fixedDataTableCellLayout/alignCenter': props.align === 'center',
	      'public/fixedDataTableCell/alignRight': props.align === 'right',
	      'public/fixedDataTableCell/highlighted': props.highlighted,
	      'public/fixedDataTableCell/main': true,
	      'public/fixedDataTableCell/hasReorderHandle': !!props.onColumnReorder,
	      'public/fixedDataTableCell/reordering': this.state.isReorderingThisColumn
	    }), props.className);
	
	    var columnResizerComponent;
	    if (props.onColumnResize) {
	      var columnResizerStyle = {
	        height: height
	      };
	      columnResizerComponent = _React2.default.createElement('div', {
	        className: (0, _cx2.default)('fixedDataTableCellLayout/columnResizerContainer'),
	        style: columnResizerStyle,
	        onMouseDown: this._onColumnResizerMouseDown,
	        onTouchStart: this.props.touchEnabled ? this._onColumnResizerMouseDown : null,
	        onTouchEnd: this.props.touchEnabled ? function (e) {
	          return e.stopPropagation();
	        } : null,
	        onTouchMove: this.props.touchEnabled ? function (e) {
	          return e.stopPropagation();
	        } : null }, _React2.default.createElement('div', {
	        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableCellLayout/columnResizerKnob'), (0, _cx2.default)('public/fixedDataTableCell/columnResizerKnob')),
	        style: columnResizerStyle
	      }));
	    }
	
	    var columnReorderComponent;
	    if (props.onColumnReorder) {
	      //header row
	      columnReorderComponent = _React2.default.createElement(_FixedDataTableColumnReorderHandle2.default, _extends({
	        columnKey: this.columnKey,
	        touchEnabled: this.props.touchEnabled,
	        onMouseDown: this._onColumnReorderMouseDown,
	        onTouchStart: this._onColumnReorderMouseDown,
	        height: height
	      }, this.props));
	    }
	
	    var cellProps = {
	      columnKey: columnKey,
	      height: height,
	      width: width
	    };
	
	    if (props.rowIndex >= 0) {
	      cellProps.rowIndex = props.rowIndex;
	    }
	
	    var content;
	    if (_React2.default.isValidElement(props.cell)) {
	      content = _React2.default.cloneElement(props.cell, cellProps);
	    } else if (typeof props.cell === 'function') {
	      content = props.cell(cellProps);
	    } else {
	      content = _React2.default.createElement(_FixedDataTableCellDefault2.default, cellProps, props.cell);
	    }
	
	    return _React2.default.createElement('div', { className: className, style: style }, columnResizerComponent, columnReorderComponent, content);
	  },
	  _onColumnResizerMouseDown: function _onColumnResizerMouseDown( /*object*/event) {
	    this.props.onColumnResize(this.props.left, this.props.width, this.props.minWidth, this.props.maxWidth, this.props.columnKey, event);
	    /**
	     * This prevents the rows from moving around when we resize the
	     * headers on touch devices.
	     */
	    if (this.props.touchEnabled) {
	      event.stopPropagation();
	    }
	  },
	  _onColumnReorderMouseDown: function _onColumnReorderMouseDown( /*object*/event) {
	    this.props.onColumnReorder(this.props.columnKey, this.props.width, this.props.left, event);
	  }
	});
	
	module.exports = FixedDataTableCell;

/***/ }),
/* 198 */
/*!******************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableCellGroup.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableCellGroup
	 * @typechecks
	 */
	
	'use strict';
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _FixedDataTableHelper = __webpack_require__(/*! ./FixedDataTableHelper */ 117);
	
	var _FixedDataTableHelper2 = _interopRequireDefault(_FixedDataTableHelper);
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _createReactClass = __webpack_require__(/*! create-react-class */ 21);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _FixedDataTableCell = __webpack_require__(/*! ./FixedDataTableCell */ 197);
	
	var _FixedDataTableCell2 = _interopRequireDefault(_FixedDataTableCell);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	var _FixedDataTableTranslateDOMPosition = __webpack_require__(/*! ./FixedDataTableTranslateDOMPosition */ 45);
	
	var _FixedDataTableTranslateDOMPosition2 = _interopRequireDefault(_FixedDataTableTranslateDOMPosition);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var DIR_SIGN = _FixedDataTableHelper2.default.DIR_SIGN;
	
	var FixedDataTableCellGroupImpl = (0, _createReactClass2.default)({
	  displayName: 'FixedDataTableCellGroupImpl',
	
	  /**
	   * PropTypes are disabled in this component, because having them on slows
	   * down the FixedDataTable hugely in DEV mode. You can enable them back for
	   * development, but please don't commit this component with enabled propTypes.
	   */
	  propTypes_DISABLED_FOR_PERFORMANCE: {
	
	    /**
	     * Array of <FixedDataTableColumn />.
	     */
	    columns: _propTypes2.default.array.isRequired,
	
	    isScrolling: _propTypes2.default.bool,
	
	    left: _propTypes2.default.number,
	
	    onColumnResize: _propTypes2.default.func,
	
	    onColumnReorder: _propTypes2.default.func,
	    onColumnReorderMove: _propTypes2.default.func,
	    onColumnReorderEnd: _propTypes2.default.func,
	
	    height: _propTypes2.default.number.isRequired,
	
	    /**
	     * Height of fixedDataTableCellGroupLayout/cellGroupWrapper.
	     */
	    cellGroupWrapperHeight: _propTypes2.default.number,
	
	    rowHeight: _propTypes2.default.number.isRequired,
	
	    rowIndex: _propTypes2.default.number.isRequired,
	
	    width: _propTypes2.default.number.isRequired,
	
	    zIndex: _propTypes2.default.number.isRequired,
	
	    touchEnabled: _propTypes2.default.bool
	  },
	
	  componentWillMount: function componentWillMount() {
	    this._initialRender = true;
	  },
	  componentDidMount: function componentDidMount() {
	    this._initialRender = false;
	  },
	  render: function render() /*object*/{
	    var props = this.props;
	    var columns = props.columns;
	    var cells = new Array(columns.length);
	
	    var contentWidth = this._getColumnsWidth(columns);
	
	    var isColumnReordering = props.isColumnReordering && columns.reduce(function (acc, column) {
	      return acc || props.columnReorderingData.columnKey === column.props.columnKey;
	    }, false);
	
	    var currentPosition = 0;
	    for (var i = 0, j = columns.length; i < j; i++) {
	      var columnProps = columns[i].props;
	      var recycable = columnProps.allowCellsRecycling && !isColumnReordering;
	      if (!recycable || currentPosition - props.left <= props.width && currentPosition - props.left + columnProps.width >= 0) {
	        var key = columnProps.columnKey || 'cell_' + i;
	        cells[i] = this._renderCell(props.rowIndex, props.rowHeight, columnProps, currentPosition, key, contentWidth, isColumnReordering);
	      }
	      currentPosition += columnProps.width;
	    }
	    var style = {
	      height: props.height,
	      position: 'absolute',
	      width: contentWidth,
	      zIndex: props.zIndex
	    };
	    (0, _FixedDataTableTranslateDOMPosition2.default)(style, -1 * DIR_SIGN * props.left, 0, this._initialRender);
	
	    return _React2.default.createElement('div', {
	      className: (0, _cx2.default)('fixedDataTableCellGroupLayout/cellGroup'),
	      style: style }, cells);
	  },
	  _renderCell: function _renderCell(
	  /*number*/rowIndex,
	  /*number*/height,
	  /*object*/columnProps,
	  /*number*/left,
	  /*string*/key,
	  /*number*/columnGroupWidth,
	  /*boolean*/isColumnReordering) /*object*/{
	
	    var cellIsResizable = columnProps.isResizable && this.props.onColumnResize;
	    var onColumnResize = cellIsResizable ? this.props.onColumnResize : null;
	
	    var cellIsReorderable = columnProps.isReorderable && this.props.onColumnReorder && rowIndex === -1 && columnGroupWidth !== columnProps.width;
	    var onColumnReorder = cellIsReorderable ? this.props.onColumnReorder : null;
	
	    var className = columnProps.cellClassName;
	    var pureRendering = columnProps.pureRendering || false;
	
	    return _React2.default.createElement(_FixedDataTableCell2.default, {
	      isScrolling: this.props.isScrolling,
	      align: columnProps.align,
	      className: className,
	      height: height,
	      key: key,
	      maxWidth: columnProps.maxWidth,
	      minWidth: columnProps.minWidth,
	      touchEnabled: this.props.touchEnabled,
	      onColumnResize: onColumnResize,
	      onColumnReorder: onColumnReorder,
	      onColumnReorderMove: this.props.onColumnReorderMove,
	      onColumnReorderEnd: this.props.onColumnReorderEnd,
	      isColumnReordering: isColumnReordering,
	      columnReorderingData: this.props.columnReorderingData,
	      rowIndex: rowIndex,
	      columnKey: columnProps.columnKey,
	      width: columnProps.width,
	      left: left,
	      cell: columnProps.cell,
	      columnGroupWidth: columnGroupWidth,
	      pureRendering: pureRendering
	    });
	  },
	  _getColumnsWidth: function _getColumnsWidth( /*array*/columns) /*number*/{
	    var width = 0;
	    for (var i = 0; i < columns.length; ++i) {
	      width += columns[i].props.width;
	    }
	    return width;
	  }
	});
	
	var FixedDataTableCellGroup = (0, _createReactClass2.default)({
	  displayName: 'FixedDataTableCellGroup',
	
	  /**
	   * PropTypes are disabled in this component, because having them on slows
	   * down the FixedDataTable hugely in DEV mode. You can enable them back for
	   * development, but please don't commit this component with enabled propTypes.
	   */
	  propTypes_DISABLED_FOR_PERFORMANCE: {
	    isScrolling: _propTypes2.default.bool,
	    /**
	     * Height of the row.
	     */
	    height: _propTypes2.default.number.isRequired,
	
	    offsetLeft: _propTypes2.default.number,
	
	    left: _propTypes2.default.number,
	    /**
	     * Z-index on which the row will be displayed. Used e.g. for keeping
	     * header and footer in front of other rows.
	     */
	    zIndex: _propTypes2.default.number.isRequired
	  },
	
	  shouldComponentUpdate: function shouldComponentUpdate( /*object*/nextProps) /*boolean*/{
	    return !nextProps.isScrolling || this.props.rowIndex !== nextProps.rowIndex || this.props.left !== nextProps.left;
	  },
	  getDefaultProps: function getDefaultProps() /*object*/{
	    return {
	      left: 0,
	      offsetLeft: 0
	    };
	  },
	  render: function render() /*object*/{
	    var _props = this.props,
	        offsetLeft = _props.offsetLeft,
	        props = _objectWithoutProperties(_props, ['offsetLeft']);
	
	    var style = {
	      height: props.cellGroupWrapperHeight || props.height,
	      width: props.width
	    };
	
	    if (DIR_SIGN === 1) {
	      style.left = offsetLeft;
	    } else {
	      style.right = offsetLeft;
	    }
	
	    var onColumnResize = props.onColumnResize ? this._onColumnResize : null;
	
	    return _React2.default.createElement('div', {
	      style: style,
	      className: (0, _cx2.default)('fixedDataTableCellGroupLayout/cellGroupWrapper') }, _React2.default.createElement(FixedDataTableCellGroupImpl, _extends({}, props, {
	      onColumnResize: onColumnResize
	    })));
	  },
	  _onColumnResize: function _onColumnResize(
	  /*number*/left,
	  /*number*/width,
	  /*?number*/minWidth,
	  /*?number*/maxWidth,
	  /*string|number*/columnKey,
	  /*object*/event) {
	    this.props.onColumnResize && this.props.onColumnResize(this.props.offsetLeft, left - this.props.left + width, width, minWidth, maxWidth, columnKey, event);
	  }
	});
	
	module.exports = FixedDataTableCellGroup;

/***/ }),
/* 199 */
/*!****************************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableColumnReorderHandle.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _DOMMouseMoveTracker = __webpack_require__(/*! ./DOMMouseMoveTracker */ 67);
	
	var _DOMMouseMoveTracker2 = _interopRequireDefault(_DOMMouseMoveTracker);
	
	var _Locale = __webpack_require__(/*! ./Locale */ 69);
	
	var _Locale2 = _interopRequireDefault(_Locale);
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _createReactClass = __webpack_require__(/*! create-react-class */ 21);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _ReactComponentWithPureRenderMixin = __webpack_require__(/*! ./ReactComponentWithPureRenderMixin */ 46);
	
	var _ReactComponentWithPureRenderMixin2 = _interopRequireDefault(_ReactComponentWithPureRenderMixin);
	
	var _FixedDataTableEventHelper = __webpack_require__(/*! ./FixedDataTableEventHelper */ 68);
	
	var _FixedDataTableEventHelper2 = _interopRequireDefault(_FixedDataTableEventHelper);
	
	var _clamp = __webpack_require__(/*! ./clamp */ 47);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var FixedDataTableColumnReorderHandle = (0, _createReactClass2.default)({
	  displayName: 'FixedDataTableColumnReorderHandle',
	  mixins: [_ReactComponentWithPureRenderMixin2.default],
	
	  propTypes: {
	
	    /**
	     * When resizing is complete this is called.
	     */
	    onColumnReorderEnd: _propTypes2.default.func,
	
	    /**
	     * Column key for the column being reordered.
	     */
	    columnKey: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
	
	    /**
	     * Whether the reorder handle should respond to touch events or not.
	     */
	    touchEnabled: _propTypes2.default.bool
	  },
	
	  getInitialState: function getInitialState() /*object*/{
	    return {
	      dragDistance: 0
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps( /*object*/newProps) {},
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._mouseMoveTracker) {
	      cancelAnimationFrame(this.frameId);
	      this.frameId = null;
	      this._mouseMoveTracker.releaseMouseMoves();
	      this._mouseMoveTracker = null;
	    }
	  },
	  render: function render() /*object*/{
	    var style = {
	      height: this.props.height
	    };
	    return _React2.default.createElement('div', {
	      className: (0, _cx2.default)({
	        'fixedDataTableCellLayout/columnReorderContainer': true,
	        'fixedDataTableCellLayout/columnReorderContainer/active': false
	      }),
	      onMouseDown: this.onMouseDown,
	      onTouchStart: this.props.touchEnabled ? this.onMouseDown : null,
	      onTouchEnd: this.props.touchEnabled ? function (e) {
	        return e.stopPropagation();
	      } : null,
	      onTouchMove: this.props.touchEnabled ? function (e) {
	        return e.stopPropagation();
	      } : null,
	      style: style });
	  },
	  onMouseDown: function onMouseDown(event) {
	    var targetRect = event.target.getBoundingClientRect();
	    var coordinates = _FixedDataTableEventHelper2.default.getCoordinatesFromEvent(event);
	
	    var mouseLocationInElement = coordinates.x - targetRect.offsetLeft;
	    var mouseLocationInRelationToColumnGroup = mouseLocationInElement + event.target.parentElement.offsetLeft;
	
	    this._mouseMoveTracker = new _DOMMouseMoveTracker2.default(this._onMove, this._onColumnReorderEnd, document.body, this.props.touchEnabled);
	    this._mouseMoveTracker.captureMouseMoves(event);
	    this.setState({
	      dragDistance: 0
	    });
	    this.props.onMouseDown({
	      columnKey: this.props.columnKey,
	      mouseLocation: {
	        dragDistance: 0,
	        inElement: mouseLocationInElement,
	        inColumnGroup: mouseLocationInRelationToColumnGroup
	      }
	    });
	
	    this._distance = 0;
	    this._animating = true;
	    this.frameId = requestAnimationFrame(this._updateState);
	
	    /**
	     * This prevents the rows from moving around when we drag the
	     * headers on touch devices.
	     */
	    if (this.props.touchEnabled) {
	      event.stopPropagation();
	    }
	  },
	  _onMove: function _onMove( /*number*/deltaX) {
	    this._distance = this.state.dragDistance + deltaX;
	  },
	  _onColumnReorderEnd: function _onColumnReorderEnd( /*boolean*/cancelReorder) {
	    this._animating = false;
	    cancelAnimationFrame(this.frameId);
	    this.frameId = null;
	    this._mouseMoveTracker.releaseMouseMoves();
	    this.props.columnReorderingData.cancelReorder = cancelReorder;
	    this.props.onColumnReorderEnd();
	  },
	  _updateState: function _updateState() {
	    if (this._animating) {
	      this.frameId = requestAnimationFrame(this._updateState);
	    }
	    this.setState({
	      dragDistance: this._distance
	    });
	    this.props.onColumnReorderMove(this._distance);
	  }
	}); /**
	     * Copyright Schrodinger, LLC
	     * All rights reserved.
	     *
	     * This source code is licensed under the BSD-style license found in the
	     * LICENSE file in the root directory of this source tree. An additional grant
	     * of patent rights can be found in the PATENTS file in the same directory.
	     *
	     * This is to be used with the FixedDataTable. It is a header icon
	     * that allows you to reorder the corresponding column.
	     *
	     * @providesModule FixedDataTableColumnReorderHandle
	     * @typechecks
	     */
	
	module.exports = FixedDataTableColumnReorderHandle;

/***/ }),
/* 200 */
/*!***************************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableColumnResizeHandle.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _DOMMouseMoveTracker = __webpack_require__(/*! ./DOMMouseMoveTracker */ 67);
	
	var _DOMMouseMoveTracker2 = _interopRequireDefault(_DOMMouseMoveTracker);
	
	var _Locale = __webpack_require__(/*! ./Locale */ 69);
	
	var _Locale2 = _interopRequireDefault(_Locale);
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _createReactClass = __webpack_require__(/*! create-react-class */ 21);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _ReactComponentWithPureRenderMixin = __webpack_require__(/*! ./ReactComponentWithPureRenderMixin */ 46);
	
	var _ReactComponentWithPureRenderMixin2 = _interopRequireDefault(_ReactComponentWithPureRenderMixin);
	
	var _clamp = __webpack_require__(/*! ./clamp */ 47);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * This is to be used with the FixedDataTable. It is a read line
	 * that when you click on a column that is resizable appears and allows
	 * you to resize the corresponding column.
	 *
	 * @providesModule FixedDataTableColumnResizeHandle
	 * @typechecks
	 */
	
	var FixedDataTableColumnResizeHandle = (0, _createReactClass2.default)({
	  displayName: 'FixedDataTableColumnResizeHandle',
	  mixins: [_ReactComponentWithPureRenderMixin2.default],
	
	  propTypes: {
	    visible: _propTypes2.default.bool.isRequired,
	
	    /**
	     * This is the height of the line
	     */
	    height: _propTypes2.default.number.isRequired,
	
	    /**
	     * Offset from left border of the table, please note
	     * that the line is a border on diff. So this is really the
	     * offset of the column itself.
	     */
	    leftOffset: _propTypes2.default.number.isRequired,
	
	    /**
	     * Height of the clickable region of the line.
	     * This is assumed to be at the top of the line.
	     */
	    knobHeight: _propTypes2.default.number.isRequired,
	
	    /**
	     * The line is a border on a diff, so this is essentially
	     * the width of column.
	     */
	    initialWidth: _propTypes2.default.number,
	
	    /**
	     * The minimum width this dragger will collapse to
	     */
	    minWidth: _propTypes2.default.number,
	
	    /**
	     * The maximum width this dragger will collapse to
	     */
	    maxWidth: _propTypes2.default.number,
	
	    /**
	     * Initial click event on the header cell.
	     */
	    initialEvent: _propTypes2.default.object,
	
	    /**
	     * When resizing is complete this is called.
	     */
	    onColumnResizeEnd: _propTypes2.default.func,
	
	    /**
	     * Column key for the column being resized.
	     */
	    columnKey: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
	
	    /**
	     * Whether the resize handle should respond to touch events or not.
	     */
	    touchEnabled: _propTypes2.default.bool
	  },
	
	  getInitialState: function getInitialState() /*object*/{
	    return {
	      width: 0,
	      cursorDelta: 0
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps( /*object*/newProps) {
	    if (newProps.initialEvent && !this._mouseMoveTracker.isDragging()) {
	      this._mouseMoveTracker.captureMouseMoves(newProps.initialEvent);
	      this.setState({
	        width: newProps.initialWidth,
	        cursorDelta: newProps.initialWidth
	      });
	    }
	  },
	  componentDidMount: function componentDidMount() {
	    this._mouseMoveTracker = new _DOMMouseMoveTracker2.default(this._onMove, this._onColumnResizeEnd, document.body, this.props.touchEnabled);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._mouseMoveTracker.releaseMouseMoves();
	    this._mouseMoveTracker = null;
	  },
	  render: function render() /*object*/{
	    var style = {
	      width: this.state.width,
	      height: this.props.height
	    };
	    if (_Locale2.default.isRTL()) {
	      style.right = this.props.leftOffset;
	    } else {
	      style.left = this.props.leftOffset;
	    }
	    return _React2.default.createElement('div', {
	      className: (0, _cx2.default)({
	        'fixedDataTableColumnResizerLineLayout/main': true,
	        'fixedDataTableColumnResizerLineLayout/hiddenElem': !this.props.visible,
	        'public/fixedDataTableColumnResizerLine/main': true
	      }),
	      style: style }, _React2.default.createElement('div', {
	      className: (0, _cx2.default)('fixedDataTableColumnResizerLineLayout/mouseArea'),
	      style: { height: this.props.height }
	    }));
	  },
	  _onMove: function _onMove( /*number*/deltaX) {
	    if (_Locale2.default.isRTL()) {
	      deltaX = -deltaX;
	    }
	    var newWidth = this.state.cursorDelta + deltaX;
	    var newColumnWidth = (0, _clamp2.default)(newWidth, this.props.minWidth, this.props.maxWidth);
	
	    // Please note cursor delta is the different between the currently width
	    // and the new width.
	    this.setState({
	      width: newColumnWidth,
	      cursorDelta: newWidth
	    });
	  },
	  _onColumnResizeEnd: function _onColumnResizeEnd() {
	    this._mouseMoveTracker.releaseMouseMoves();
	    this.props.onColumnResizeEnd(this.state.width, this.props.columnKey);
	  }
	});
	
	module.exports = FixedDataTableColumnResizeHandle;

/***/ }),
/* 201 */
/*!*************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableRoot.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableRoot
	 */
	
	'use strict';
	
	var _FixedDataTable = __webpack_require__(/*! ./FixedDataTable */ 195);
	
	var _FixedDataTable2 = _interopRequireDefault(_FixedDataTable);
	
	var _FixedDataTableCellDefault = __webpack_require__(/*! ./FixedDataTableCellDefault */ 114);
	
	var _FixedDataTableCellDefault2 = _interopRequireDefault(_FixedDataTableCellDefault);
	
	var _FixedDataTableColumn = __webpack_require__(/*! ./FixedDataTableColumn */ 115);
	
	var _FixedDataTableColumn2 = _interopRequireDefault(_FixedDataTableColumn);
	
	var _FixedDataTableColumnGroup = __webpack_require__(/*! ./FixedDataTableColumnGroup */ 116);
	
	var _FixedDataTableColumnGroup2 = _interopRequireDefault(_FixedDataTableColumnGroup);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var FixedDataTableRoot = {
	  Cell: _FixedDataTableCellDefault2.default,
	  Column: _FixedDataTableColumn2.default,
	  ColumnGroup: _FixedDataTableColumnGroup2.default,
	  Table: _FixedDataTable2.default
	};
	
	FixedDataTableRoot.version = '0.8.5';
	module.exports = FixedDataTableRoot;

/***/ }),
/* 202 */
/*!******************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableRowBuffer.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableRowBuffer
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _IntegerBufferSet = __webpack_require__(/*! ./IntegerBufferSet */ 206);
	
	var _IntegerBufferSet2 = _interopRequireDefault(_IntegerBufferSet);
	
	var _clamp = __webpack_require__(/*! ./clamp */ 47);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _invariant = __webpack_require__(/*! ./invariant */ 34);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var MIN_BUFFER_ROWS = 3;
	var MAX_BUFFER_ROWS = 6;
	
	// FixedDataTableRowBuffer is a helper class that executes row buffering
	// logic for FixedDataTable. It figures out which rows should be rendered
	// and in which positions.
	
	var FixedDataTableRowBuffer = function () {
	  function FixedDataTableRowBuffer(
	  /*number*/rowsCount,
	  /*number*/defaultRowHeight,
	  /*number*/viewportHeight,
	  /*?function*/rowHeightGetter,
	  /*?number*/bufferRowCount) {
	    _classCallCheck(this, FixedDataTableRowBuffer);
	
	    (0, _invariant2.default)(defaultRowHeight !== 0, "defaultRowHeight musn't be equal 0 in FixedDataTableRowBuffer");
	
	    this._bufferSet = new _IntegerBufferSet2.default();
	    this._defaultRowHeight = defaultRowHeight;
	    this._viewportRowsBegin = 0;
	    this._viewportRowsEnd = 0;
	    this._maxVisibleRowCount = Math.ceil(viewportHeight / defaultRowHeight) + 1;
	    this._bufferRowsCount = bufferRowCount != null ? bufferRowCount : (0, _clamp2.default)(Math.floor(this._maxVisibleRowCount / 2), MIN_BUFFER_ROWS, MAX_BUFFER_ROWS);
	    this._rowsCount = rowsCount;
	    this._rowHeightGetter = rowHeightGetter;
	    this._rows = [];
	    this._viewportHeight = viewportHeight;
	
	    this.getRows = this.getRows.bind(this);
	    this.getRowsWithUpdatedBuffer = this.getRowsWithUpdatedBuffer.bind(this);
	  }
	
	  _createClass(FixedDataTableRowBuffer, [{
	    key: 'getRowsWithUpdatedBuffer',
	    value: function getRowsWithUpdatedBuffer() /*array*/{
	      var remainingBufferRows = 2 * this._bufferRowsCount;
	      var bufferRowIndex = Math.max(this._viewportRowsBegin - this._bufferRowsCount, 0);
	      while (bufferRowIndex < this._viewportRowsBegin) {
	        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);
	        bufferRowIndex++;
	        remainingBufferRows--;
	      }
	      bufferRowIndex = this._viewportRowsEnd;
	      while (bufferRowIndex < this._rowsCount && remainingBufferRows > 0) {
	        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);
	        bufferRowIndex++;
	        remainingBufferRows--;
	      }
	      return this._rows;
	    }
	  }, {
	    key: 'getRows',
	    value: function getRows(
	    /*number*/firstRowIndex,
	    /*number*/firstRowOffset) /*array*/{
	      var top = firstRowOffset;
	      var totalHeight = top;
	      var rowIndex = firstRowIndex;
	      var endIndex = Math.min(firstRowIndex + this._maxVisibleRowCount, this._rowsCount);
	
	      this._viewportRowsBegin = firstRowIndex;
	      while (rowIndex < endIndex || totalHeight < this._viewportHeight && rowIndex < this._rowsCount) {
	        this._addRowToBuffer(rowIndex, firstRowIndex, endIndex - 1);
	        totalHeight += this._rowHeightGetter(rowIndex);
	        ++rowIndex;
	        // Store index after the last viewport row as end, to be able to
	        // distinguish when there are no rows rendered in viewport
	        this._viewportRowsEnd = rowIndex;
	      }
	
	      return this._rows;
	    }
	  }, {
	    key: '_addRowToBuffer',
	    value: function _addRowToBuffer(
	    /*number*/rowIndex,
	    /*number*/firstViewportRowIndex,
	    /*number*/lastViewportRowIndex) {
	      var rowPosition = this._bufferSet.getValuePosition(rowIndex);
	      var viewportRowsCount = lastViewportRowIndex - firstViewportRowIndex + 1;
	      var allowedRowsCount = viewportRowsCount + this._bufferRowsCount * 2;
	      if (rowPosition === null && this._bufferSet.getSize() >= allowedRowsCount) {
	        rowPosition = this._bufferSet.replaceFurthestValuePosition(firstViewportRowIndex, lastViewportRowIndex, rowIndex);
	      }
	      if (rowPosition === null) {
	        // We can't reuse any of existing positions for this row. We have to
	        // create new position
	        rowPosition = this._bufferSet.getNewPositionForValue(rowIndex);
	        this._rows[rowPosition] = rowIndex;
	      } else {
	        // This row already is in the table with rowPosition position or it
	        // can replace row that is in that position
	        this._rows[rowPosition] = rowIndex;
	      }
	    }
	  }]);
	
	  return FixedDataTableRowBuffer;
	}();
	
	module.exports = FixedDataTableRowBuffer;

/***/ }),
/* 203 */
/*!*********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableScrollHelper.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableScrollHelper
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _PrefixIntervalTree = __webpack_require__(/*! ./PrefixIntervalTree */ 208);
	
	var _PrefixIntervalTree2 = _interopRequireDefault(_PrefixIntervalTree);
	
	var _clamp = __webpack_require__(/*! ./clamp */ 47);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var BUFFER_ROWS = 5;
	var NO_ROWS_SCROLL_RESULT = {
	  index: 0,
	  offset: 0,
	  position: 0,
	  contentHeight: 0
	};
	
	var FixedDataTableScrollHelper = function () {
	  function FixedDataTableScrollHelper(
	  /*number*/rowCount,
	  /*number*/defaultRowHeight,
	  /*number*/viewportHeight,
	  /*?function*/rowHeightGetter) {
	    var _this = this;
	
	    var defaultSubRowHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	    var
	    /*?function*/subRowHeightGetter = arguments[5];
	
	    _classCallCheck(this, FixedDataTableScrollHelper);
	
	    var defaultFullRowHeight = defaultRowHeight + defaultSubRowHeight;
	    this._rowOffsets = _PrefixIntervalTree2.default.uniform(rowCount, defaultFullRowHeight);
	    this._storedHeights = new Array(rowCount);
	    for (var i = 0; i < rowCount; ++i) {
	      this._storedHeights[i] = defaultFullRowHeight;
	    }
	    this._rowCount = rowCount;
	    this._position = 0;
	    this._contentHeight = rowCount * defaultFullRowHeight;
	
	    this._rowHeightGetter = rowHeightGetter;
	    this._subRowHeightGetter = subRowHeightGetter;
	    this._fullRowHeightGetter = function (rowIdx) {
	      var rowHeight = _this._rowHeightGetter ? _this._rowHeightGetter(rowIdx) : defaultRowHeight;
	      var subRowHeight = _this._subRowHeightGetter ? _this._subRowHeightGetter(rowIdx) : defaultSubRowHeight;
	      return rowHeight + subRowHeight;
	    };
	    this._viewportHeight = viewportHeight;
	    this.scrollRowIntoView = this.scrollRowIntoView.bind(this);
	    this.setViewportHeight = this.setViewportHeight.bind(this);
	    this.scrollBy = this.scrollBy.bind(this);
	    this.scrollTo = this.scrollTo.bind(this);
	    this.scrollToRow = this.scrollToRow.bind(this);
	    this.setRowHeightGetter = this.setRowHeightGetter.bind(this);
	    this.setSubRowHeightGetter = this.setSubRowHeightGetter.bind(this);
	    this.getContentHeight = this.getContentHeight.bind(this);
	    this.getRowPosition = this.getRowPosition.bind(this);
	
	    this._updateHeightsInViewport(0, 0);
	  }
	
	  _createClass(FixedDataTableScrollHelper, [{
	    key: 'setRowHeightGetter',
	    value: function setRowHeightGetter( /*function*/rowHeightGetter) {
	      this._rowHeightGetter = rowHeightGetter;
	    }
	  }, {
	    key: 'setSubRowHeightGetter',
	    value: function setSubRowHeightGetter( /*function*/subRowHeightGetter) {
	      this._subRowHeightGetter = subRowHeightGetter;
	    }
	  }, {
	    key: 'setViewportHeight',
	    value: function setViewportHeight( /*number*/viewportHeight) {
	      this._viewportHeight = viewportHeight;
	    }
	  }, {
	    key: 'getContentHeight',
	    value: function getContentHeight() /*number*/{
	      return this._contentHeight;
	    }
	  }, {
	    key: '_updateHeightsInViewport',
	    value: function _updateHeightsInViewport(
	    /*number*/firstRowIndex,
	    /*number*/firstRowOffset) {
	      var top = firstRowOffset;
	      var index = firstRowIndex;
	      while (top <= this._viewportHeight && index < this._rowCount) {
	        this._updateRowHeight(index);
	        top += this._storedHeights[index];
	        index++;
	      }
	    }
	  }, {
	    key: '_updateHeightsAboveViewport',
	    value: function _updateHeightsAboveViewport( /*number*/firstRowIndex) {
	      var index = firstRowIndex - 1;
	      while (index >= 0 && index >= firstRowIndex - BUFFER_ROWS) {
	        var delta = this._updateRowHeight(index);
	        this._position += delta;
	        index--;
	      }
	    }
	  }, {
	    key: '_updateRowHeight',
	    value: function _updateRowHeight( /*number*/rowIndex) /*number*/{
	      if (rowIndex < 0 || rowIndex >= this._rowCount) {
	        return 0;
	      }
	      var newHeight = this._fullRowHeightGetter(rowIndex);
	      if (newHeight !== this._storedHeights[rowIndex]) {
	        var change = newHeight - this._storedHeights[rowIndex];
	        this._rowOffsets.set(rowIndex, newHeight);
	        this._storedHeights[rowIndex] = newHeight;
	        this._contentHeight += change;
	        return change;
	      }
	      return 0;
	    }
	  }, {
	    key: 'getRowPosition',
	    value: function getRowPosition( /*number*/rowIndex) /*number*/{
	      this._updateRowHeight(rowIndex);
	      return this._rowOffsets.sumUntil(rowIndex);
	    }
	  }, {
	    key: 'scrollBy',
	    value: function scrollBy( /*number*/delta) /*object*/{
	      if (this._rowCount === 0) {
	        return NO_ROWS_SCROLL_RESULT;
	      }
	      var firstRow = this._rowOffsets.greatestLowerBound(this._position);
	      firstRow = (0, _clamp2.default)(firstRow, 0, Math.max(this._rowCount - 1, 0));
	      var firstRowPosition = this._rowOffsets.sumUntil(firstRow);
	      var rowIndex = firstRow;
	      var position = this._position;
	
	      var rowHeightChange = this._updateRowHeight(rowIndex);
	      if (firstRowPosition !== 0) {
	        position += rowHeightChange;
	      }
	      var visibleRowHeight = this._storedHeights[rowIndex] - (position - firstRowPosition);
	
	      if (delta >= 0) {
	
	        while (delta > 0 && rowIndex < this._rowCount) {
	          if (delta < visibleRowHeight) {
	            position += delta;
	            delta = 0;
	          } else {
	            delta -= visibleRowHeight;
	            position += visibleRowHeight;
	            rowIndex++;
	          }
	          if (rowIndex < this._rowCount) {
	            this._updateRowHeight(rowIndex);
	            visibleRowHeight = this._storedHeights[rowIndex];
	          }
	        }
	      } else if (delta < 0) {
	        delta = -delta;
	        var invisibleRowHeight = this._storedHeights[rowIndex] - visibleRowHeight;
	
	        while (delta > 0 && rowIndex >= 0) {
	          if (delta < invisibleRowHeight) {
	            position -= delta;
	            delta = 0;
	          } else {
	            position -= invisibleRowHeight;
	            delta -= invisibleRowHeight;
	            rowIndex--;
	          }
	          if (rowIndex >= 0) {
	            var change = this._updateRowHeight(rowIndex);
	            invisibleRowHeight = this._storedHeights[rowIndex];
	            position += change;
	          }
	        }
	      }
	
	      var maxPosition = this._contentHeight - this._viewportHeight;
	      position = (0, _clamp2.default)(position, 0, maxPosition);
	      this._position = position;
	      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);
	      firstRowIndex = (0, _clamp2.default)(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));
	      firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);
	      var firstRowOffset = firstRowPosition - position;
	
	      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);
	      this._updateHeightsAboveViewport(firstRowIndex);
	
	      return {
	        index: firstRowIndex,
	        offset: firstRowOffset,
	        position: this._position,
	        contentHeight: this._contentHeight
	      };
	    }
	  }, {
	    key: '_getRowAtEndPosition',
	    value: function _getRowAtEndPosition( /*number*/rowIndex) /*number*/{
	      // We need to update enough rows above the selected one to be sure that when
	      // we scroll to selected position all rows between first shown and selected
	      // one have most recent heights computed and will not resize
	      this._updateRowHeight(rowIndex);
	      var currentRowIndex = rowIndex;
	      var top = this._storedHeights[currentRowIndex];
	      while (top < this._viewportHeight && currentRowIndex >= 0) {
	        currentRowIndex--;
	        if (currentRowIndex >= 0) {
	          this._updateRowHeight(currentRowIndex);
	          top += this._storedHeights[currentRowIndex];
	        }
	      }
	      var position = this._rowOffsets.sumTo(rowIndex) - this._viewportHeight;
	      if (position < 0) {
	        position = 0;
	      }
	      return position;
	    }
	  }, {
	    key: 'scrollTo',
	    value: function scrollTo( /*number*/position) /*object*/{
	      if (this._rowCount === 0) {
	        return NO_ROWS_SCROLL_RESULT;
	      }
	      if (position <= 0) {
	        // If position less than or equal to 0 first row should be fully visible
	        // on top
	        this._position = 0;
	        this._updateHeightsInViewport(0, 0);
	
	        return {
	          index: 0,
	          offset: 0,
	          position: this._position,
	          contentHeight: this._contentHeight
	        };
	      } else if (position >= this._contentHeight - this._viewportHeight) {
	        // If position is equal to or greater than max scroll value, we need
	        // to make sure to have bottom border of last row visible.
	        var rowIndex = this._rowCount - 1;
	        position = this._getRowAtEndPosition(rowIndex);
	      }
	      this._position = position;
	
	      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);
	      firstRowIndex = (0, _clamp2.default)(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));
	      var firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);
	      var firstRowOffset = firstRowPosition - position;
	
	      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);
	      this._updateHeightsAboveViewport(firstRowIndex);
	
	      return {
	        index: firstRowIndex,
	        offset: firstRowOffset,
	        position: this._position,
	        contentHeight: this._contentHeight
	      };
	    }
	
	    /**
	     * Allows to scroll to selected row with specified offset. It always
	     * brings that row to top of viewport with that offset
	     */
	
	  }, {
	    key: 'scrollToRow',
	    value: function scrollToRow( /*number*/rowIndex, /*number*/offset) /*object*/{
	      rowIndex = (0, _clamp2.default)(rowIndex, 0, Math.max(this._rowCount - 1, 0));
	      offset = (0, _clamp2.default)(offset, -this._storedHeights[rowIndex], 0);
	      var firstRow = this._rowOffsets.sumUntil(rowIndex);
	      return this.scrollTo(firstRow - offset);
	    }
	
	    /**
	     * Allows to scroll to selected row by bringing it to viewport with minimal
	     * scrolling. This that if row is fully visible, scroll will not be changed.
	     * If top border of row is above top of viewport it will be scrolled to be
	     * fully visible on the top of viewport. If the bottom border of row is
	     * below end of viewport, it will be scrolled up to be fully visible on the
	     * bottom of viewport.
	     */
	
	  }, {
	    key: 'scrollRowIntoView',
	    value: function scrollRowIntoView( /*number*/rowIndex) /*object*/{
	      rowIndex = (0, _clamp2.default)(rowIndex, 0, Math.max(this._rowCount - 1, 0));
	      this._updateRowHeight(rowIndex);
	      var rowBegin = this._rowOffsets.sumUntil(rowIndex);
	      var rowEnd = rowBegin + this._storedHeights[rowIndex];
	      if (rowBegin < this._position) {
	        return this.scrollTo(rowBegin);
	      } else if (this._position + this._viewportHeight < rowEnd) {
	        var position = this._getRowAtEndPosition(rowIndex);
	        return this.scrollTo(position);
	      }
	      return this.scrollTo(this._position);
	    }
	  }]);
	
	  return FixedDataTableScrollHelper;
	}();
	
	module.exports = FixedDataTableScrollHelper;

/***/ }),
/* 204 */
/*!********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/FixedDataTableWidthHelper.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FixedDataTableWidthHelper
	 * @typechecks
	 */
	
	'use strict';
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getTotalWidth( /*array*/columns) /*number*/{
	  var totalWidth = 0;
	  for (var i = 0; i < columns.length; ++i) {
	    totalWidth += columns[i].props.width;
	  }
	  return totalWidth;
	}
	
	function getTotalFlexGrow( /*array*/columns) /*number*/{
	  var totalFlexGrow = 0;
	  for (var i = 0; i < columns.length; ++i) {
	    totalFlexGrow += columns[i].props.flexGrow || 0;
	  }
	  return totalFlexGrow;
	}
	
	function distributeFlexWidth(
	/*array*/columns,
	/*number*/flexWidth) /*object*/{
	  if (flexWidth <= 0) {
	    return {
	      columns: columns,
	      width: getTotalWidth(columns)
	    };
	  }
	  var remainingFlexGrow = getTotalFlexGrow(columns);
	  var remainingFlexWidth = flexWidth;
	  var newColumns = [];
	  var totalWidth = 0;
	  for (var i = 0; i < columns.length; ++i) {
	    var column = columns[i];
	    if (!column.props.flexGrow) {
	      totalWidth += column.props.width;
	      newColumns.push(column);
	      continue;
	    }
	    var columnFlexWidth = Math.floor(column.props.flexGrow / remainingFlexGrow * remainingFlexWidth);
	    var newColumnWidth = Math.floor(column.props.width + columnFlexWidth);
	    totalWidth += newColumnWidth;
	
	    remainingFlexGrow -= column.props.flexGrow;
	    remainingFlexWidth -= columnFlexWidth;
	
	    newColumns.push(_React2.default.cloneElement(column, { width: newColumnWidth }));
	  }
	
	  return {
	    columns: newColumns,
	    width: totalWidth
	  };
	}
	
	function adjustColumnGroupWidths(
	/*array*/columnGroups,
	/*number*/expectedWidth) /*object*/{
	  var allColumns = [];
	  var i;
	  for (i = 0; i < columnGroups.length; ++i) {
	    _React2.default.Children.forEach(columnGroups[i].props.children, function (column) {
	      allColumns.push(column);
	    });
	  }
	  var columnsWidth = getTotalWidth(allColumns);
	  var remainingFlexGrow = getTotalFlexGrow(allColumns);
	  var remainingFlexWidth = Math.max(expectedWidth - columnsWidth, 0);
	
	  var newAllColumns = [];
	  var newColumnGroups = [];
	
	  for (i = 0; i < columnGroups.length; ++i) {
	    var columnGroup = columnGroups[i];
	    var currentColumns = [];
	
	    _React2.default.Children.forEach(columnGroup.props.children, function (column) {
	      currentColumns.push(column);
	    });
	
	    var columnGroupFlexGrow = getTotalFlexGrow(currentColumns);
	    var columnGroupFlexWidth = Math.floor(columnGroupFlexGrow / remainingFlexGrow * remainingFlexWidth);
	
	    var newColumnSettings = distributeFlexWidth(currentColumns, columnGroupFlexWidth);
	
	    remainingFlexGrow -= columnGroupFlexGrow;
	    remainingFlexWidth -= columnGroupFlexWidth;
	
	    for (var j = 0; j < newColumnSettings.columns.length; ++j) {
	      newAllColumns.push(newColumnSettings.columns[j]);
	    }
	
	    newColumnGroups.push(_React2.default.cloneElement(columnGroup, { width: newColumnSettings.width }));
	  }
	
	  return {
	    columns: newAllColumns,
	    columnGroups: newColumnGroups
	  };
	}
	
	function adjustColumnWidths(
	/*array*/columns,
	/*number*/expectedWidth) /*array*/{
	  var columnsWidth = getTotalWidth(columns);
	  if (columnsWidth < expectedWidth) {
	    return distributeFlexWidth(columns, expectedWidth - columnsWidth).columns;
	  }
	  return columns;
	}
	
	var FixedDataTableWidthHelper = {
	  getTotalWidth: getTotalWidth,
	  getTotalFlexGrow: getTotalFlexGrow,
	  distributeFlexWidth: distributeFlexWidth,
	  adjustColumnWidths: adjustColumnWidths,
	  adjustColumnGroupWidths: adjustColumnGroupWidths
	};
	
	module.exports = FixedDataTableWidthHelper;

/***/ }),
/* 205 */
/*!***********************************************!*\
  !*** ./~/fixed-data-table-2/internal/Heap.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Heap
	 * @typechecks
	 * @preventMunge
	 */
	
	'use strict';
	
	/*
	 * @param {*} a
	 * @param {*} b
	 * @return {boolean}
	 */
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	function defaultComparator(a, b) {
	  return a < b;
	}
	
	var Heap = function () {
	  function Heap(items, comparator) {
	    _classCallCheck(this, Heap);
	
	    this._items = items || [];
	    this._size = this._items.length;
	    this._comparator = comparator || defaultComparator;
	    this._heapify();
	  }
	
	  /*
	   * @return {boolean}
	   */
	
	  _createClass(Heap, [{
	    key: 'empty',
	    value: function empty() {
	      return this._size === 0;
	    }
	
	    /*
	     * @return {*}
	     */
	
	  }, {
	    key: 'pop',
	    value: function pop() {
	      if (this._size === 0) {
	        return;
	      }
	
	      var elt = this._items[0];
	
	      var lastElt = this._items.pop();
	      this._size--;
	
	      if (this._size > 0) {
	        this._items[0] = lastElt;
	        this._sinkDown(0);
	      }
	
	      return elt;
	    }
	
	    /*
	     * @param {*} item
	     */
	
	  }, {
	    key: 'push',
	    value: function push(item) {
	      this._items[this._size++] = item;
	      this._bubbleUp(this._size - 1);
	    }
	
	    /*
	     * @return {number}
	     */
	
	  }, {
	    key: 'size',
	    value: function size() {
	      return this._size;
	    }
	
	    /*
	     * @return {*}
	     */
	
	  }, {
	    key: 'peek',
	    value: function peek() {
	      if (this._size === 0) {
	        return;
	      }
	
	      return this._items[0];
	    }
	  }, {
	    key: '_heapify',
	    value: function _heapify() {
	      for (var index = Math.floor((this._size + 1) / 2); index >= 0; index--) {
	        this._sinkDown(index);
	      }
	    }
	
	    /*
	     * @parent {number} index
	     */
	
	  }, {
	    key: '_bubbleUp',
	    value: function _bubbleUp(index) {
	      var elt = this._items[index];
	      while (index > 0) {
	        var parentIndex = Math.floor((index + 1) / 2) - 1;
	        var parentElt = this._items[parentIndex];
	
	        // if parentElt < elt, stop
	        if (this._comparator(parentElt, elt)) {
	          return;
	        }
	
	        // swap
	        this._items[parentIndex] = elt;
	        this._items[index] = parentElt;
	        index = parentIndex;
	      }
	    }
	
	    /*
	     * @parent {number} index
	     */
	
	  }, {
	    key: '_sinkDown',
	    value: function _sinkDown(index) {
	      var elt = this._items[index];
	
	      while (true) {
	        var leftChildIndex = 2 * (index + 1) - 1;
	        var rightChildIndex = 2 * (index + 1);
	        var swapIndex = -1;
	
	        if (leftChildIndex < this._size) {
	          var leftChild = this._items[leftChildIndex];
	          if (this._comparator(leftChild, elt)) {
	            swapIndex = leftChildIndex;
	          }
	        }
	
	        if (rightChildIndex < this._size) {
	          var rightChild = this._items[rightChildIndex];
	          if (this._comparator(rightChild, elt)) {
	            if (swapIndex === -1 || this._comparator(rightChild, this._items[swapIndex])) {
	              swapIndex = rightChildIndex;
	            }
	          }
	        }
	
	        // if we don't have a swap, stop
	        if (swapIndex === -1) {
	          return;
	        }
	
	        this._items[index] = this._items[swapIndex];
	        this._items[swapIndex] = elt;
	        index = swapIndex;
	      }
	    }
	  }]);
	
	  return Heap;
	}();
	
	module.exports = Heap;

/***/ }),
/* 206 */
/*!***********************************************************!*\
  !*** ./~/fixed-data-table-2/internal/IntegerBufferSet.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule IntegerBufferSet
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _Heap = __webpack_require__(/*! ./Heap */ 205);
	
	var _Heap2 = _interopRequireDefault(_Heap);
	
	var _invariant = __webpack_require__(/*! ./invariant */ 34);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	// Data structure that allows to store values and assign positions to them
	// in a way to minimize changing positions of stored values when new ones are
	// added or when some values are replaced. Stored elements are alwasy assigned
	// a consecutive set of positoins startin from 0 up to count of elements less 1
	// Following actions can be executed
	// * get position assigned to given value (null if value is not stored)
	// * create new entry for new value and get assigned position back
	// * replace value that is furthest from specified value range with new value
	//   and get it's position back
	// All operations take amortized log(n) time where n is number of elements in
	// the set.
	var IntegerBufferSet = function () {
	  function IntegerBufferSet() {
	    _classCallCheck(this, IntegerBufferSet);
	
	    this._valueToPositionMap = {};
	    this._size = 0;
	    this._smallValues = new _Heap2.default([], // Initial data in the heap
	    this._smallerComparator);
	    this._largeValues = new _Heap2.default([], // Initial data in the heap
	    this._greaterComparator);
	
	    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);
	    this.getValuePosition = this.getValuePosition.bind(this);
	    this.getSize = this.getSize.bind(this);
	    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);
	  }
	
	  _createClass(IntegerBufferSet, [{
	    key: 'getSize',
	    value: function getSize() /*number*/{
	      return this._size;
	    }
	  }, {
	    key: 'getValuePosition',
	    value: function getValuePosition( /*number*/value) /*?number*/{
	      if (this._valueToPositionMap[value] === undefined) {
	        return null;
	      }
	      return this._valueToPositionMap[value];
	    }
	  }, {
	    key: 'getNewPositionForValue',
	    value: function getNewPositionForValue( /*number*/value) /*number*/{
	      (0, _invariant2.default)(this._valueToPositionMap[value] === undefined, "Shouldn't try to find new position for value already stored in BufferSet");
	      var newPosition = this._size;
	      this._size++;
	      this._pushToHeaps(newPosition, value);
	      this._valueToPositionMap[value] = newPosition;
	      return newPosition;
	    }
	  }, {
	    key: 'replaceFurthestValuePosition',
	    value: function replaceFurthestValuePosition(
	    /*number*/lowValue,
	    /*number*/highValue,
	    /*number*/newValue) /*?number*/{
	      (0, _invariant2.default)(this._valueToPositionMap[newValue] === undefined, "Shouldn't try to replace values with value already stored value in " + "BufferSet");
	
	      this._cleanHeaps();
	      if (this._smallValues.empty() || this._largeValues.empty()) {
	        // Threre are currently no values stored. We will have to create new
	        // position for this value.
	        return null;
	      }
	
	      var minValue = this._smallValues.peek().value;
	      var maxValue = this._largeValues.peek().value;
	      if (minValue >= lowValue && maxValue <= highValue) {
	        // All values currently stored are necessary, we can't reuse any of them.
	        return null;
	      }
	
	      var valueToReplace;
	      if (lowValue - minValue > maxValue - highValue) {
	        // minValue is further from provided range. We will reuse it's position.
	        valueToReplace = minValue;
	        this._smallValues.pop();
	      } else {
	        valueToReplace = maxValue;
	        this._largeValues.pop();
	      }
	      var position = this._valueToPositionMap[valueToReplace];
	      delete this._valueToPositionMap[valueToReplace];
	      this._valueToPositionMap[newValue] = position;
	      this._pushToHeaps(position, newValue);
	
	      return position;
	    }
	  }, {
	    key: '_pushToHeaps',
	    value: function _pushToHeaps( /*number*/position, /*number*/value) {
	      var element = {
	        position: position,
	        value: value
	      };
	      // We can reuse the same object in both heaps, because we don't mutate them
	      this._smallValues.push(element);
	      this._largeValues.push(element);
	    }
	  }, {
	    key: '_cleanHeaps',
	    value: function _cleanHeaps() {
	      // We not usually only remove object from one heap while moving value.
	      // Here we make sure that there is no stale data on top of heaps.
	      this._cleanHeap(this._smallValues);
	      this._cleanHeap(this._largeValues);
	      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());
	      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());
	      if (maxHeapSize > 10 * minHeapSize) {
	        // There are many old values in one of heaps. We nned to get rid of them
	        // to not use too avoid memory leaks
	        this._recreateHeaps();
	      }
	    }
	  }, {
	    key: '_recreateHeaps',
	    value: function _recreateHeaps() {
	      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;
	      var newSmallValues = new _Heap2.default([], // Initial data in the heap
	      this._smallerComparator);
	      var newLargeValues = new _Heap2.default([], // Initial datat in the heap
	      this._greaterComparator);
	      while (!sourceHeap.empty()) {
	        var element = sourceHeap.pop();
	        // Push all stil valid elements to new heaps
	        if (this._valueToPositionMap[element.value] !== undefined) {
	          newSmallValues.push(element);
	          newLargeValues.push(element);
	        }
	      }
	      this._smallValues = newSmallValues;
	      this._largeValues = newLargeValues;
	    }
	  }, {
	    key: '_cleanHeap',
	    value: function _cleanHeap( /*object*/heap) {
	      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {
	        heap.pop();
	      }
	    }
	  }, {
	    key: '_smallerComparator',
	    value: function _smallerComparator( /*object*/lhs, /*object*/rhs) /*boolean*/{
	      return lhs.value < rhs.value;
	    }
	  }, {
	    key: '_greaterComparator',
	    value: function _greaterComparator( /*object*/lhs, /*object*/rhs) /*boolean*/{
	      return lhs.value > rhs.value;
	    }
	  }]);
	
	  return IntegerBufferSet;
	}();
	
	module.exports = IntegerBufferSet;

/***/ }),
/* 207 */
/*!***********************************************!*\
  !*** ./~/fixed-data-table-2/internal/Keys.js ***!
  \***********************************************/
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Keys
	 */
	
	module.exports = {
	  BACKSPACE: 8,
	  TAB: 9,
	  RETURN: 13,
	  ALT: 18,
	  ESC: 27,
	  SPACE: 32,
	  PAGE_UP: 33,
	  PAGE_DOWN: 34,
	  END: 35,
	  HOME: 36,
	  LEFT: 37,
	  UP: 38,
	  RIGHT: 39,
	  DOWN: 40,
	  DELETE: 46,
	  COMMA: 188,
	  PERIOD: 190,
	  A: 65,
	  Z: 90,
	  ZERO: 48,
	  NUMPAD_0: 96,
	  NUMPAD_9: 105
	};

/***/ }),
/* 208 */
/*!*************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/PrefixIntervalTree.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PrefixIntervalTree
	 * 
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _invariant = __webpack_require__(/*! ./invariant */ 34);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var parent = function parent(node) {
	  return Math.floor(node / 2);
	};
	
	var Int32Array = global.Int32Array || function (size) {
	  var xs = [];
	  for (var i = size - 1; i >= 0; --i) {
	    xs[i] = 0;
	  }
	  return xs;
	};
	
	/**
	 * Computes the next power of 2 after or equal to x.
	 */
	function ceilLog2(x) {
	  var y = 1;
	  while (y < x) {
	    y *= 2;
	  }
	  return y;
	}
	
	/**
	 * A prefix interval tree stores an numeric array and the partial sums of that
	 * array. It is optimized for updating the values of the array without
	 * recomputing all of the partial sums.
	 *
	 *   - O(ln n) update
	 *   - O(1) lookup
	 *   - O(ln n) compute a partial sum
	 *   - O(n) space
	 *
	 * Note that the sequence of partial sums is one longer than the array, so that
	 * the first partial sum is always 0, and the last partial sum is the sum of the
	 * entire array.
	 */
	
	var PrefixIntervalTree = function () {
	  function PrefixIntervalTree(xs) {
	    _classCallCheck(this, PrefixIntervalTree);
	
	    /**
	     * Number of elements in the array
	     *
	     * @type {number}
	     * @private
	     */
	    this._size = xs.length;
	
	    /**
	     * Half the size of the heap. It is also the number of non-leaf nodes, and the
	     * index of the first element in the heap. Always a power of 2.
	     *
	     * @type {number}
	     * @private
	     */
	    this._half = ceilLog2(this._size);
	
	    /**
	     * Binary heap
	     *
	     * @type {!Array.<number>}
	     * @const
	     * @private
	     */
	    this._heap = new Int32Array(2 * this._half);
	
	    var i;
	    for (i = 0; i < this._size; ++i) {
	      this._heap[this._half + i] = xs[i];
	    }
	
	    for (i = this._half - 1; i > 0; --i) {
	      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];
	    }
	  }
	
	  _createClass(PrefixIntervalTree, [{
	    key: 'set',
	    value: function set(index, value) {
	      (0, _invariant2.default)(0 <= index && index < this._size, 'Index out of range %s', index);
	
	      var node = this._half + index;
	      this._heap[node] = value;
	
	      node = parent(node);
	      for (; node !== 0; node = parent(node)) {
	        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];
	      }
	    }
	  }, {
	    key: 'get',
	    value: function get(index) {
	      (0, _invariant2.default)(0 <= index && index < this._size, 'Index out of range %s', index);
	
	      var node = this._half + index;
	      return this._heap[node];
	    }
	  }, {
	    key: 'getSize',
	    value: function getSize() {
	      return this._size;
	    }
	
	    /**
	     * Returns the sum get(0) + get(1) + ... + get(end - 1).
	     */
	
	  }, {
	    key: 'sumUntil',
	    value: function sumUntil(end) {
	      (0, _invariant2.default)(0 <= end && end < this._size + 1, 'Index out of range %s', end);
	
	      if (end === 0) {
	        return 0;
	      }
	
	      var node = this._half + end - 1;
	      var sum = this._heap[node];
	      for (; node !== 1; node = parent(node)) {
	        if (node % 2 === 1) {
	          sum += this._heap[node - 1];
	        }
	      }
	
	      return sum;
	    }
	
	    /**
	     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).
	     */
	
	  }, {
	    key: 'sumTo',
	    value: function sumTo(inclusiveEnd) {
	      (0, _invariant2.default)(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);
	      return this.sumUntil(inclusiveEnd + 1);
	    }
	
	    /**
	     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).
	     */
	
	  }, {
	    key: 'sum',
	    value: function sum(begin, end) {
	      (0, _invariant2.default)(begin <= end, 'Begin must precede end');
	      return this.sumUntil(end) - this.sumUntil(begin);
	    }
	
	    /**
	     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or
	     * -1 if no such i exists.
	     */
	
	  }, {
	    key: 'greatestLowerBound',
	    value: function greatestLowerBound(t) {
	      if (t < 0) {
	        return -1;
	      }
	
	      var node = 1;
	      if (this._heap[node] <= t) {
	        return this._size;
	      }
	
	      while (node < this._half) {
	        var leftSum = this._heap[2 * node];
	        if (t < leftSum) {
	          node = 2 * node;
	        } else {
	          node = 2 * node + 1;
	          t -= leftSum;
	        }
	      }
	
	      return node - this._half;
	    }
	
	    /**
	     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or
	     * -1 if no such i exists.
	     */
	
	  }, {
	    key: 'greatestStrictLowerBound',
	    value: function greatestStrictLowerBound(t) {
	      if (t <= 0) {
	        return -1;
	      }
	
	      var node = 1;
	      if (this._heap[node] < t) {
	        return this._size;
	      }
	
	      while (node < this._half) {
	        var leftSum = this._heap[2 * node];
	        if (t <= leftSum) {
	          node = 2 * node;
	        } else {
	          node = 2 * node + 1;
	          t -= leftSum;
	        }
	      }
	
	      return node - this._half;
	    }
	
	    /**
	     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or
	     * size + 1 if no such i exists.
	     */
	
	  }, {
	    key: 'leastUpperBound',
	    value: function leastUpperBound(t) {
	      return this.greatestStrictLowerBound(t) + 1;
	    }
	
	    /**
	     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or
	     * size + 1 if no such i exists.
	     */
	
	  }, {
	    key: 'leastStrictUpperBound',
	    value: function leastStrictUpperBound(t) {
	      return this.greatestLowerBound(t) + 1;
	    }
	  }], [{
	    key: 'uniform',
	    value: function uniform(size, initialValue) {
	      var xs = [];
	      for (var i = size - 1; i >= 0; --i) {
	        xs[i] = initialValue;
	      }
	
	      return new PrefixIntervalTree(xs);
	    }
	  }, {
	    key: 'empty',
	    value: function empty(size) {
	      return PrefixIntervalTree.uniform(size, 0);
	    }
	  }]);
	
	  return PrefixIntervalTree;
	}();
	
	module.exports = PrefixIntervalTree;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 209 */
/*!***************************************************!*\
  !*** ./~/fixed-data-table-2/internal/ReactDOM.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	module.exports = __webpack_require__(/*! react-dom */ 11);

/***/ }),
/* 210 */
/*!************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/ReactTouchHandler.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * This is utility that handles touch events and calls provided touch
	 * callback with correct frame rate.
	 * Deceleration logic based on http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html
	 *
	 * @providesModule ReactTouchHandler
	 * @typechecks
	 */
	
	'use strict';
	
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();
	
	var _emptyFunction = __webpack_require__(/*! ./emptyFunction */ 22);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	var _requestAnimationFramePolyfill = __webpack_require__(/*! ./requestAnimationFramePolyfill */ 70);
	
	var _requestAnimationFramePolyfill2 = _interopRequireDefault(_requestAnimationFramePolyfill);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var MOVE_AMPLITUDE = 1.6;
	var DECELERATION_AMPLITUDE = 1.6;
	var DECELERATION_FACTOR = 325;
	var TRACKER_TIMEOUT = 100;
	
	var ReactTouchHandler = function () {
	  /**
	   * onTouchScroll is the callback that will be called with right frame rate if
	   * any touch events happened
	   * onTouchScroll should is to be called with two arguments: deltaX and deltaY in
	   * this order
	   */
	  function ReactTouchHandler(
	  /*function*/onTouchScroll,
	  /*boolean|function*/handleScrollX,
	  /*boolean|function*/handleScrollY,
	  /*?boolean|?function*/stopPropagation) {
	    _classCallCheck(this, ReactTouchHandler);
	
	    // The animation frame id for the drag scroll
	    this._dragAnimationId = null;
	
	    // The interval id for tracking the drag velocity
	    this._trackerId = null;
	
	    // Used to track the drag scroll delta while waiting for an animation frame
	    this._deltaX = 0;
	    this._deltaY = 0;
	
	    // The last touch we processed while dragging.  Used to compute the delta and velocity above
	    this._lastTouchX = 0;
	    this._lastTouchY = 0;
	
	    // Used to track a moving average of the scroll velocity while dragging
	    this._velocityX = 0;
	    this._velocityY = 0;
	
	    // An accummulated drag scroll delta used to calculate velocity
	    this._accumulatedDeltaX = 0;
	    this._accumulatedDeltaY = 0;
	
	    // Timestamp from the last interval frame we used to track velocity
	    this._lastFrameTimestamp = Date.now();
	
	    // Timestamp from the last animation frame we used to autoscroll after drag stop
	    this._autoScrollTimestamp = Date.now();
	
	    if (typeof handleScrollX !== 'function') {
	      handleScrollX = handleScrollX ? _emptyFunction2.default.thatReturnsTrue : _emptyFunction2.default.thatReturnsFalse;
	    }
	
	    if (typeof handleScrollY !== 'function') {
	      handleScrollY = handleScrollY ? _emptyFunction2.default.thatReturnsTrue : _emptyFunction2.default.thatReturnsFalse;
	    }
	
	    // TODO (jordan) Is configuring this necessary
	    if (typeof stopPropagation !== 'function') {
	      stopPropagation = stopPropagation ? _emptyFunction2.default.thatReturnsTrue : _emptyFunction2.default.thatReturnsFalse;
	    }
	
	    this._handleScrollX = handleScrollX;
	    this._handleScrollY = handleScrollY;
	    this._stopPropagation = stopPropagation;
	    this._onTouchScrollCallback = onTouchScroll;
	
	    this._didTouchMove = this._didTouchMove.bind(this);
	    this._track = this._track.bind(this);
	    this._autoScroll = this._autoScroll.bind(this);
	    this._startAutoScroll = this._startAutoScroll.bind(this);
	    this.onTouchStart = this.onTouchStart.bind(this);
	    this.onTouchEnd = this.onTouchEnd.bind(this);
	    this.onTouchMove = this.onTouchMove.bind(this);
	    this.onTouchCancel = this.onTouchCancel.bind(this);
	  }
	
	  _createClass(ReactTouchHandler, [{
	    key: 'onTouchStart',
	    value: function onTouchStart( /*object*/event) {
	      // Start tracking drag delta for scrolling
	      this._lastTouchX = event.touches[0].pageX;
	      this._lastTouchY = event.touches[0].pageY;
	
	      // Reset our velocity and intermediate data used to compute velocity
	      this._velocityX = 0;
	      this._velocityY = 0;
	      this._accumulatedDeltaX = 0;
	      this._accumulatedDeltaY = 0;
	      this._lastFrameTimestamp = Date.now();
	
	      // Setup interval for tracking velocity
	      clearInterval(this._trackerId);
	      this._trackerId = setInterval(this._track, TRACKER_TIMEOUT);
	
	      if (this._stopPropagation()) {
	        event.stopPropagation();
	      }
	    }
	  }, {
	    key: 'onTouchEnd',
	    value: function onTouchEnd( /*object*/event) {
	
	      // Stop tracking velocity
	      clearInterval(this._trackerId);
	      this._trackerId = null;
	
	      // Initialize decelerating autoscroll on drag stop
	      (0, _requestAnimationFramePolyfill2.default)(this._startAutoScroll);
	
	      if (this._stopPropagation()) {
	        event.stopPropagation();
	      }
	    }
	  }, {
	    key: 'onTouchCancel',
	    value: function onTouchCancel( /*object*/event) {
	
	      // Stop tracking velocity
	      clearInterval(this._trackerId);
	      this._trackerId = null;
	
	      if (this._stopPropagation()) {
	        event.stopPropagation();
	      }
	    }
	  }, {
	    key: 'onTouchMove',
	    value: function onTouchMove( /*object*/event) {
	      var moveX = event.touches[0].pageX;
	      var moveY = event.touches[0].pageY;
	
	      // Compute delta scrolled since last drag
	      // Mobile, scrolling is inverted
	      this._deltaX = MOVE_AMPLITUDE * (this._lastTouchX - moveX);
	      this._deltaY = MOVE_AMPLITUDE * (this._lastTouchY - moveY);
	
	      var handleScrollX = this._handleScrollX(this._deltaX, this._deltaY);
	      var handleScrollY = this._handleScrollY(this._deltaY, this._deltaX);
	      if (!handleScrollX && !handleScrollY) {
	        return;
	      }
	
	      // If we can handle scroll update last touch for computing delta
	      if (handleScrollX) {
	        this._lastTouchX = moveX;
	      } else {
	        this._deltaX = 0;
	      }
	      if (handleScrollY) {
	        this._lastTouchY = moveY;
	      } else {
	        this._deltaY = 0;
	      }
	
	      event.preventDefault();
	
	      // Ensure minimum delta magnitude is met to avoid jitter
	      var changed = false;
	      if (Math.abs(this._deltaX) > 2 || Math.abs(this._deltaY) > 2) {
	        if (this._stopPropagation()) {
	          event.stopPropagation();
	        }
	        changed = true;
	      }
	
	      // Request animation frame to trigger scroll of computed delta
	      if (changed === true && this._dragAnimationId === null) {
	        this._dragAnimationId = (0, _requestAnimationFramePolyfill2.default)(this._didTouchMove);
	      }
	    }
	
	    /**
	     * Fire scroll callback based on computed drag delta.
	     * Also track accummulated delta so we can calculate velocity
	     */
	
	  }, {
	    key: '_didTouchMove',
	    value: function _didTouchMove() {
	      this._dragAnimationId = null;
	
	      this._onTouchScrollCallback(this._deltaX, this._deltaY);
	      this._accumulatedDeltaX += this._deltaX;
	      this._accumulatedDeltaY += this._deltaY;
	      this._deltaX = 0;
	      this._deltaY = 0;
	    }
	
	    /**
	     * Compute velocity based on a weighted average of drag over last 100 ms and
	     * previous velocity.  Combining into a moving average results in a smoother scroll.
	     */
	
	  }, {
	    key: '_track',
	    value: function _track() {
	      var now = Date.now();
	      var elapsed = now - this._lastFrameTimestamp;
	      var oldVelocityX = this._velocityX;
	      var oldVelocityY = this._velocityY;
	
	      // We compute velocity using a weighted average of the current velocity and the previous velocity
	      // If the previous velocity is 0, put the full weight on the last 100 ms
	      var weight = 0.8;
	      if (elapsed < TRACKER_TIMEOUT) {
	        weight *= elapsed / TRACKER_TIMEOUT;
	      }
	      if (oldVelocityX === 0 && oldVelocityY === 0) {
	        weight = 1;
	      }
	
	      // Formula for computing weighted average of velocity
	      this._velocityX = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaX / (1 + elapsed));
	      if (weight < 1) {
	        this._velocityX += (1 - weight) * oldVelocityX;
	      }
	
	      this._velocityY = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaY / (1 + elapsed));
	      if (weight < 1) {
	        this._velocityY += (1 - weight) * oldVelocityY;
	      }
	
	      this._accumulatedDeltaX = 0;
	      this._accumulatedDeltaY = 0;
	      this._lastFrameTimestamp = now;
	    }
	
	    /**
	     * To kick off deceleration / momentum scrolling,
	     * handle any scrolling from a drag which was waiting for an animation frame
	     * Then update our velocity
	     * Finally start the momentum scrolling handler (autoScroll)
	     */
	
	  }, {
	    key: '_startAutoScroll',
	    value: function _startAutoScroll() {
	      this._autoScrollTimestamp = Date.now();
	      if (this._deltaX > 0 || this.deltaY > 0) {
	        this._didTouchMove();
	      }
	      this._track();
	      this._autoScroll();
	    }
	
	    /**
	     * Compute a scroll delta with an exponential decay based on time elapsed since drag was released.
	     * This is called recursively on animation frames until the delta is below a threshold (5 pixels)
	     */
	
	  }, {
	    key: '_autoScroll',
	    value: function _autoScroll() {
	      var elapsed = Date.now() - this._autoScrollTimestamp;
	      var factor = DECELERATION_AMPLITUDE * Math.exp(-elapsed / DECELERATION_FACTOR);
	      var deltaX = factor * this._velocityX;
	      var deltaY = factor * this._velocityY;
	
	      if (Math.abs(deltaX) <= 5 || !this._handleScrollX(deltaX, deltaY)) {
	        deltaX = 0;
	      }
	      if (Math.abs(deltaY) <= 5 || !this._handleScrollY(deltaY, deltaX)) {
	        deltaY = 0;
	      }
	
	      if (deltaX !== 0 || deltaY !== 0) {
	        this._onTouchScrollCallback(deltaX, deltaY);
	        (0, _requestAnimationFramePolyfill2.default)(this._autoScroll);
	      }
	    }
	  }]);
	
	  return ReactTouchHandler;
	}();
	
	module.exports = ReactTouchHandler;

/***/ }),
/* 211 */
/*!****************************************************!*\
  !*** ./~/fixed-data-table-2/internal/Scrollbar.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _DOMMouseMoveTracker = __webpack_require__(/*! ./DOMMouseMoveTracker */ 67);
	
	var _DOMMouseMoveTracker2 = _interopRequireDefault(_DOMMouseMoveTracker);
	
	var _Keys = __webpack_require__(/*! ./Keys */ 207);
	
	var _Keys2 = _interopRequireDefault(_Keys);
	
	var _React = __webpack_require__(/*! ./React */ 13);
	
	var _React2 = _interopRequireDefault(_React);
	
	var _createReactClass = __webpack_require__(/*! create-react-class */ 21);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var _propTypes = __webpack_require__(/*! prop-types */ 8);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _ReactDOM = __webpack_require__(/*! ./ReactDOM */ 209);
	
	var _ReactDOM2 = _interopRequireDefault(_ReactDOM);
	
	var _ReactComponentWithPureRenderMixin = __webpack_require__(/*! ./ReactComponentWithPureRenderMixin */ 46);
	
	var _ReactComponentWithPureRenderMixin2 = _interopRequireDefault(_ReactComponentWithPureRenderMixin);
	
	var _ReactWheelHandler = __webpack_require__(/*! ./ReactWheelHandler */ 119);
	
	var _ReactWheelHandler2 = _interopRequireDefault(_ReactWheelHandler);
	
	var _cssVar = __webpack_require__(/*! ./cssVar */ 215);
	
	var _cssVar2 = _interopRequireDefault(_cssVar);
	
	var _cx = __webpack_require__(/*! ./cx */ 16);
	
	var _cx2 = _interopRequireDefault(_cx);
	
	var _emptyFunction = __webpack_require__(/*! ./emptyFunction */ 22);
	
	var _emptyFunction2 = _interopRequireDefault(_emptyFunction);
	
	var _FixedDataTableTranslateDOMPosition = __webpack_require__(/*! ./FixedDataTableTranslateDOMPosition */ 45);
	
	var _FixedDataTableTranslateDOMPosition2 = _interopRequireDefault(_FixedDataTableTranslateDOMPosition);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Scrollbar
	 * @typechecks
	 */
	
	var UNSCROLLABLE_STATE = {
	  position: 0,
	  scrollable: false
	};
	
	var FACE_MARGIN = parseInt((0, _cssVar2.default)('scrollbar-face-margin'), 10);
	var FACE_MARGIN_2 = FACE_MARGIN * 2;
	var FACE_SIZE_MIN = 30;
	var KEYBOARD_SCROLL_AMOUNT = 40;
	
	var _lastScrolledScrollbar = null;
	
	var Scrollbar = (0, _createReactClass2.default)({
	  displayName: 'Scrollbar',
	  mixins: [_ReactComponentWithPureRenderMixin2.default],
	
	  propTypes: {
	    contentSize: _propTypes2.default.number.isRequired,
	    defaultPosition: _propTypes2.default.number,
	    isOpaque: _propTypes2.default.bool,
	    orientation: _propTypes2.default.oneOf(['vertical', 'horizontal']),
	    onScroll: _propTypes2.default.func,
	    position: _propTypes2.default.number,
	    size: _propTypes2.default.number.isRequired,
	    trackColor: _propTypes2.default.oneOf(['gray']),
	    zIndex: _propTypes2.default.number,
	    verticalTop: _propTypes2.default.number
	  },
	
	  getInitialState: function getInitialState() /*object*/{
	    var props = this.props;
	    return this._calculateState(props.position || props.defaultPosition || 0, props.size, props.contentSize, props.orientation);
	  },
	  componentWillReceiveProps: function componentWillReceiveProps( /*object*/nextProps) {
	    var controlledPosition = nextProps.position;
	    if (controlledPosition === undefined) {
	      this._setNextState(this._calculateState(this.state.position, nextProps.size, nextProps.contentSize, nextProps.orientation));
	    } else {
	      this._setNextState(this._calculateState(controlledPosition, nextProps.size, nextProps.contentSize, nextProps.orientation), nextProps);
	    }
	  },
	  getDefaultProps: function getDefaultProps() /*object*/{
	    return {
	      defaultPosition: 0,
	      isOpaque: false,
	      onScroll: _emptyFunction2.default,
	      orientation: 'vertical',
	      zIndex: 99
	    };
	  },
	  render: function render() /*?object*/{
	    if (!this.state.scrollable) {
	      return null;
	    }
	
	    var size = this.props.size;
	    var mainStyle;
	    var faceStyle;
	    var isHorizontal = this.state.isHorizontal;
	    var isVertical = !isHorizontal;
	    var isActive = this.state.focused || this.state.isDragging;
	    var faceSize = this.state.faceSize;
	    var isOpaque = this.props.isOpaque;
	    var verticalTop = this.props.verticalTop || 0;
	
	    var mainClassName = (0, _cx2.default)({
	      'ScrollbarLayout/main': true,
	      'ScrollbarLayout/mainVertical': isVertical,
	      'ScrollbarLayout/mainHorizontal': isHorizontal,
	      'public/Scrollbar/main': true,
	      'public/Scrollbar/mainOpaque': isOpaque,
	      'public/Scrollbar/mainActive': isActive
	    });
	
	    var faceClassName = (0, _cx2.default)({
	      'ScrollbarLayout/face': true,
	      'ScrollbarLayout/faceHorizontal': isHorizontal,
	      'ScrollbarLayout/faceVertical': isVertical,
	      'public/Scrollbar/faceActive': isActive,
	      'public/Scrollbar/face': true
	    });
	
	    var position = this.state.position * this.state.scale + FACE_MARGIN;
	
	    if (isHorizontal) {
	      mainStyle = {
	        width: size
	      };
	      faceStyle = {
	        width: faceSize - FACE_MARGIN_2
	      };
	      (0, _FixedDataTableTranslateDOMPosition2.default)(faceStyle, position, 0, this._initialRender);
	    } else {
	      mainStyle = {
	        top: verticalTop,
	        height: size
	      };
	      faceStyle = {
	        height: faceSize - FACE_MARGIN_2
	      };
	      (0, _FixedDataTableTranslateDOMPosition2.default)(faceStyle, 0, position, this._initialRender);
	    }
	
	    mainStyle.zIndex = this.props.zIndex;
	
	    if (this.props.trackColor === 'gray') {
	      mainStyle.backgroundColor = (0, _cssVar2.default)('fbui-desktop-background-light');
	    }
	
	    return _React2.default.createElement('div', {
	      onFocus: this._onFocus,
	      onBlur: this._onBlur,
	      onKeyDown: this._onKeyDown,
	      onMouseDown: this._onMouseDown,
	      onWheel: this._wheelHandler.onWheel,
	      className: mainClassName,
	      style: mainStyle,
	      tabIndex: 0 }, _React2.default.createElement('div', {
	      ref: 'face',
	      className: faceClassName,
	      style: faceStyle
	    }));
	  },
	  componentWillMount: function componentWillMount() {
	    var isHorizontal = this.props.orientation === 'horizontal';
	    var onWheel = isHorizontal ? this._onWheelX : this._onWheelY;
	
	    this._wheelHandler = new _ReactWheelHandler2.default(onWheel, this._shouldHandleX, // Should hanlde horizontal scroll
	    this._shouldHandleY // Should handle vertical scroll
	    );
	    this._initialRender = true;
	  },
	  componentDidMount: function componentDidMount() {
	    this._mouseMoveTracker = new _DOMMouseMoveTracker2.default(this._onMouseMove, this._onMouseMoveEnd, document.documentElement);
	
	    if (this.props.position !== undefined && this.state.position !== this.props.position) {
	      this._didScroll();
	    }
	    this._initialRender = false;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    this._nextState = null;
	    this._mouseMoveTracker.releaseMouseMoves();
	    if (_lastScrolledScrollbar === this) {
	      _lastScrolledScrollbar = null;
	    }
	    delete this._mouseMoveTracker;
	  },
	  scrollBy: function scrollBy( /*number*/delta) {
	    this._onWheel(delta);
	  },
	  _shouldHandleX: function _shouldHandleX( /*number*/delta) /*boolean*/{
	    return this.props.orientation === 'horizontal' ? this._shouldHandleChange(delta) : false;
	  },
	  _shouldHandleY: function _shouldHandleY( /*number*/delta) /*boolean*/{
	    return this.props.orientation !== 'horizontal' ? this._shouldHandleChange(delta) : false;
	  },
	  _shouldHandleChange: function _shouldHandleChange( /*number*/delta) /*boolean*/{
	    var nextState = this._calculateState(this.state.position + delta, this.props.size, this.props.contentSize, this.props.orientation);
	    return nextState.position !== this.state.position;
	  },
	  _calculateState: function _calculateState(
	  /*number*/position,
	  /*number*/size,
	  /*number*/contentSize,
	  /*string*/orientation) /*object*/{
	    if (size < 1 || contentSize <= size) {
	      return UNSCROLLABLE_STATE;
	    }
	
	    var stateKey = position + '_' + size + '_' + contentSize + '_' + orientation;
	    if (this._stateKey === stateKey) {
	      return this._stateForKey;
	    }
	
	    // There are two types of positions here.
	    // 1) Phisical position: changed by mouse / keyboard
	    // 2) Logical position: changed by props.
	    // The logical position will be kept as as internal state and the `render()`
	    // function will translate it into physical position to render.
	
	    var isHorizontal = orientation === 'horizontal';
	    var scale = size / contentSize;
	    var faceSize = size * scale;
	
	    if (faceSize < FACE_SIZE_MIN) {
	      scale = (size - FACE_SIZE_MIN) / (contentSize - size);
	      faceSize = FACE_SIZE_MIN;
	    }
	
	    var scrollable = true;
	    var maxPosition = contentSize - size;
	
	    if (position < 0) {
	      position = 0;
	    } else if (position > maxPosition) {
	      position = maxPosition;
	    }
	
	    var isDragging = this._mouseMoveTracker ? this._mouseMoveTracker.isDragging() : false;
	
	    // This function should only return flat values that can be compared quiclky
	    // by `ReactComponentWithPureRenderMixin`.
	    var state = {
	      faceSize: faceSize,
	      isDragging: isDragging,
	      isHorizontal: isHorizontal,
	      position: position,
	      scale: scale,
	      scrollable: scrollable
	    };
	
	    // cache the state for later use.
	    this._stateKey = stateKey;
	    this._stateForKey = state;
	    return state;
	  },
	  _onWheelY: function _onWheelY( /*number*/deltaX, /*number*/deltaY) {
	    this._onWheel(deltaY);
	  },
	  _onWheelX: function _onWheelX( /*number*/deltaX, /*number*/deltaY) {
	    this._onWheel(deltaX);
	  },
	  _onWheel: function _onWheel( /*number*/delta) {
	    var props = this.props;
	
	    // The mouse may move faster then the animation frame does.
	    // Use `requestAnimationFrame` to avoid over-updating.
	    this._setNextState(this._calculateState(this.state.position + delta, props.size, props.contentSize, props.orientation));
	  },
	  _onMouseDown: function _onMouseDown( /*object*/event) {
	    var nextState;
	
	    if (event.target !== _ReactDOM2.default.findDOMNode(this.refs.face)) {
	      // Both `offsetX` and `layerX` are non-standard DOM property but they are
	      // magically available for browsers somehow.
	      var nativeEvent = event.nativeEvent;
	      var position = this.state.isHorizontal ? nativeEvent.offsetX || nativeEvent.layerX : nativeEvent.offsetY || nativeEvent.layerY;
	
	      // MouseDown on the scroll-track directly, move the center of the
	      // scroll-face to the mouse position.
	      var props = this.props;
	      position /= this.state.scale;
	      nextState = this._calculateState(position - this.state.faceSize * 0.5 / this.state.scale, props.size, props.contentSize, props.orientation);
	    } else {
	      nextState = {};
	    }
	
	    nextState.focused = true;
	    this._setNextState(nextState);
	
	    this._mouseMoveTracker.captureMouseMoves(event);
	    // Focus the node so it may receive keyboard event.
	    _ReactDOM2.default.findDOMNode(this).focus();
	  },
	  _onMouseMove: function _onMouseMove( /*number*/deltaX, /*number*/deltaY) {
	    var props = this.props;
	    var delta = this.state.isHorizontal ? deltaX : deltaY;
	    delta /= this.state.scale;
	
	    this._setNextState(this._calculateState(this.state.position + delta, props.size, props.contentSize, props.orientation));
	  },
	  _onMouseMoveEnd: function _onMouseMoveEnd() {
	    this._nextState = null;
	    this._mouseMoveTracker.releaseMouseMoves();
	    this.setState({ isDragging: false });
	  },
	  _onKeyDown: function _onKeyDown( /*object*/event) {
	    var keyCode = event.keyCode;
	
	    if (keyCode === _Keys2.default.TAB) {
	      // Let focus move off the scrollbar.
	      return;
	    }
	
	    var distance = KEYBOARD_SCROLL_AMOUNT;
	    var direction = 0;
	
	    if (this.state.isHorizontal) {
	      switch (keyCode) {
	        case _Keys2.default.HOME:
	          direction = -1;
	          distance = this.props.contentSize;
	          break;
	
	        case _Keys2.default.LEFT:
	          direction = -1;
	          break;
	
	        case _Keys2.default.RIGHT:
	          direction = 1;
	          break;
	
	        default:
	          return;
	      }
	    }
	
	    if (!this.state.isHorizontal) {
	      switch (keyCode) {
	        case _Keys2.default.SPACE:
	          if (event.shiftKey) {
	            direction = -1;
	          } else {
	            direction = 1;
	          }
	          break;
	
	        case _Keys2.default.HOME:
	          direction = -1;
	          distance = this.props.contentSize;
	          break;
	
	        case _Keys2.default.UP:
	          direction = -1;
	          break;
	
	        case _Keys2.default.DOWN:
	          direction = 1;
	          break;
	
	        case _Keys2.default.PAGE_UP:
	          direction = -1;
	          distance = this.props.size;
	          break;
	
	        case _Keys2.default.PAGE_DOWN:
	          direction = 1;
	          distance = this.props.size;
	          break;
	
	        default:
	          return;
	      }
	    }
	
	    event.preventDefault();
	
	    var props = this.props;
	    this._setNextState(this._calculateState(this.state.position + distance * direction, props.size, props.contentSize, props.orientation));
	  },
	  _onFocus: function _onFocus() {
	    this.setState({
	      focused: true
	    });
	  },
	  _onBlur: function _onBlur() {
	    this.setState({
	      focused: false
	    });
	  },
	  _blur: function _blur() {
	    var el = _ReactDOM2.default.findDOMNode(this);
	    if (!el) {
	      return;
	    }
	
	    try {
	      this._onBlur();
	      el.blur();
	    } catch (oops) {
	      // pass
	    }
	  },
	  _setNextState: function _setNextState( /*object*/nextState, /*?object*/props) {
	    props = props || this.props;
	    var controlledPosition = props.position;
	    var willScroll = this.state.position !== nextState.position;
	    if (controlledPosition === undefined) {
	      var callback = willScroll ? this._didScroll : undefined;
	      this.setState(nextState, callback);
	    } else if (controlledPosition === nextState.position) {
	      this.setState(nextState);
	    } else {
	      // Scrolling is controlled. Don't update the state and let the owner
	      // to update the scrollbar instead.
	      if (nextState.position !== undefined && nextState.position !== this.state.position) {
	        this.props.onScroll(nextState.position);
	      }
	      return;
	    }
	
	    if (willScroll && _lastScrolledScrollbar !== this) {
	      _lastScrolledScrollbar && _lastScrolledScrollbar._blur();
	      _lastScrolledScrollbar = this;
	    }
	  },
	  _didScroll: function _didScroll() {
	    this.props.onScroll(this.state.position);
	  }
	});
	
	Scrollbar.KEYBOARD_SCROLL_AMOUNT = KEYBOARD_SCROLL_AMOUNT;
	Scrollbar.SIZE = parseInt((0, _cssVar2.default)('scrollbar-size'), 10);
	Scrollbar.OFFSET = 1;
	
	module.exports = Scrollbar;

/***/ }),
/* 212 */
/*!***************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/UserAgent_DEPRECATED.js ***!
  \***************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Copyright Schrodinger, LLC
	 *
	 * @providesModule UserAgent_DEPRECATED
	 */
	
	/**
	 *  Provides entirely client-side User Agent and OS detection. You should prefer
	 *  the non-deprecated UserAgent module when possible, which exposes our
	 *  authoritative server-side PHP-based detection to the client.
	 *
	 *  Usage is straightforward:
	 *
	 *    if (UserAgent_DEPRECATED.ie()) {
	 *      //  IE
	 *    }
	 *
	 *  You can also do version checks:
	 *
	 *    if (UserAgent_DEPRECATED.ie() >= 7) {
	 *      //  IE7 or better
	 *    }
	 *
	 *  The browser functions will return NaN if the browser does not match, so
	 *  you can also do version compares the other way:
	 *
	 *    if (UserAgent_DEPRECATED.ie() < 7) {
	 *      //  IE6 or worse
	 *    }
	 *
	 *  Note that the version is a float and may include a minor version number,
	 *  so you should always use range operators to perform comparisons, not
	 *  strict equality.
	 *
	 *  **Note:** You should **strongly** prefer capability detection to browser
	 *  version detection where it's reasonable:
	 *
	 *    http://www.quirksmode.org/js/support.html
	 *
	 *  Further, we have a large number of mature wrapper functions and classes
	 *  which abstract away many browser irregularities. Check the documentation,
	 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
	 *  another copy of "event || window.event".
	 *
	 */
	
	var _populated = false;
	
	// Browsers
	var _ie, _firefox, _opera, _webkit, _chrome;
	
	// Actual IE browser for compatibility mode
	var _ie_real_version;
	
	// Platforms
	var _osx, _windows, _linux, _android;
	
	// Architectures
	var _win64;
	
	// Devices
	var _iphone, _ipad, _native;
	
	var _mobile;
	
	function _populate() {
	  if (_populated) {
	    return;
	  }
	
	  _populated = true;
	
	  // To work around buggy JS libraries that can't handle multi-digit
	  // version numbers, Opera 10's user agent string claims it's Opera
	  // 9, then later includes a Version/X.Y field:
	  //
	  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
	  var uas = navigator.userAgent;
	  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
	  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
	
	  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
	  _ipad = /\b(iP[ao]d)/.exec(uas);
	  _android = /Android/i.exec(uas);
	  _native = /FBAN\/\w+;/i.exec(uas);
	  _mobile = /Mobile/i.exec(uas);
	
	  // Note that the IE team blog would have you believe you should be checking
	  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
	  // from either x64 or ia64;  so ultimately, you should just check for Win64
	  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
	  // Windows will send 'WOW64' instead.
	  _win64 = !!/Win64/.exec(uas);
	
	  if (agent) {
	    _ie = agent[1] ? parseFloat(agent[1]) : agent[5] ? parseFloat(agent[5]) : NaN;
	    // IE compatibility mode
	    if (_ie && document && document.documentMode) {
	      _ie = document.documentMode;
	    }
	    // grab the "true" ie version from the trident token if available
	    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
	    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
	
	    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
	    _opera = agent[3] ? parseFloat(agent[3]) : NaN;
	    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
	    if (_webkit) {
	      // We do not add the regexp to the above test, because it will always
	      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
	      // the userAgent string.
	      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
	      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
	    } else {
	      _chrome = NaN;
	    }
	  } else {
	    _ie = _firefox = _opera = _chrome = _webkit = NaN;
	  }
	
	  if (os) {
	    if (os[1]) {
	      // Detect OS X version.  If no version number matches, set _osx to true.
	      // Version examples:  10, 10_6_1, 10.7
	      // Parses version number as a float, taking only first two sets of
	      // digits.  If only one set of digits is found, returns just the major
	      // version number.
	      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
	
	      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
	    } else {
	      _osx = false;
	    }
	    _windows = !!os[2];
	    _linux = !!os[3];
	  } else {
	    _osx = _windows = _linux = false;
	  }
	}
	
	var UserAgent_DEPRECATED = {
	
	  /**
	   *  Check if the UA is Internet Explorer.
	   *
	   *
	   *  @return float|NaN Version number (if match) or NaN.
	   */
	  ie: function ie() {
	    return _populate() || _ie;
	  },
	
	  /**
	   * Check if we're in Internet Explorer compatibility mode.
	   *
	   * @return bool true if in compatibility mode, false if
	   * not compatibility mode or not ie
	   */
	  ieCompatibilityMode: function ieCompatibilityMode() {
	    return _populate() || _ie_real_version > _ie;
	  },
	
	  /**
	   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
	   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
	   * this when we don't need it -- tracked by #601957.
	   */
	  ie64: function ie64() {
	    return UserAgent_DEPRECATED.ie() && _win64;
	  },
	
	  /**
	   *  Check if the UA is Firefox.
	   *
	   *
	   *  @return float|NaN Version number (if match) or NaN.
	   */
	  firefox: function firefox() {
	    return _populate() || _firefox;
	  },
	
	  /**
	   *  Check if the UA is Opera.
	   *
	   *
	   *  @return float|NaN Version number (if match) or NaN.
	   */
	  opera: function opera() {
	    return _populate() || _opera;
	  },
	
	  /**
	   *  Check if the UA is WebKit.
	   *
	   *
	   *  @return float|NaN Version number (if match) or NaN.
	   */
	  webkit: function webkit() {
	    return _populate() || _webkit;
	  },
	
	  /**
	   *  For Push
	   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
	   */
	  safari: function safari() {
	    return UserAgent_DEPRECATED.webkit();
	  },
	
	  /**
	   *  Check if the UA is a Chrome browser.
	   *
	   *
	   *  @return float|NaN Version number (if match) or NaN.
	   */
	  chrome: function chrome() {
	    return _populate() || _chrome;
	  },
	
	  /**
	   *  Check if the user is running Windows.
	   *
	   *  @return bool `true' if the user's OS is Windows.
	   */
	  windows: function windows() {
	    return _populate() || _windows;
	  },
	
	  /**
	   *  Check if the user is running Mac OS X.
	   *
	   *  @return float|bool   Returns a float if a version number is detected,
	   *                       otherwise true/false.
	   */
	  osx: function osx() {
	    return _populate() || _osx;
	  },
	
	  /**
	   * Check if the user is running Linux.
	   *
	   * @return bool `true' if the user's OS is some flavor of Linux.
	   */
	  linux: function linux() {
	    return _populate() || _linux;
	  },
	
	  /**
	   * Check if the user is running on an iPhone or iPod platform.
	   *
	   * @return bool `true' if the user is running some flavor of the
	   *    iPhone OS.
	   */
	  iphone: function iphone() {
	    return _populate() || _iphone;
	  },
	
	  mobile: function mobile() {
	    return _populate() || _iphone || _ipad || _android || _mobile;
	  },
	
	  nativeApp: function nativeApp() {
	    // webviews inside of the native apps
	    return _populate() || _native;
	  },
	
	  android: function android() {
	    return _populate() || _android;
	  },
	
	  ipad: function ipad() {
	    return _populate() || _ipad;
	  }
	};
	
	module.exports = UserAgent_DEPRECATED;

/***/ }),
/* 213 */
/*!***************************************************!*\
  !*** ./~/fixed-data-table-2/internal/camelize.js ***!
  \***************************************************/
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ }),
/* 214 */
/*!***********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/cancelAnimationFramePolyfill.js ***!
  \***********************************************************************/
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule cancelAnimationFramePolyfill
	 */
	
	/**
	 * Here is the native and polyfill version of cancelAnimationFrame.
	 * Please don't use it directly and use cancelAnimationFrame module instead.
	 */
	
	var cancelAnimationFrame = global.cancelAnimationFrame || global.webkitCancelAnimationFrame || global.mozCancelAnimationFrame || global.oCancelAnimationFrame || global.msCancelAnimationFrame || global.clearTimeout;
	
	module.exports = cancelAnimationFrame;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 215 */
/*!*************************************************!*\
  !*** ./~/fixed-data-table-2/internal/cssVar.js ***!
  \*************************************************/
/***/ (function(module, exports) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule cssVar
	 * @typechecks
	 */
	
	"use strict";
	
	// If you change these, you'll need to restart the dev server for it to take effect.
	
	var CSS_VARS = {
	  'scrollbar-face-active-color': '#7d7d7d',
	  'scrollbar-face-color': '#c2c2c2',
	  'scrollbar-face-margin': '4px',
	  'scrollbar-face-radius': '6px',
	  'scrollbar-size': '15px',
	  'scrollbar-size-large': '17px',
	  'scrollbar-track-color': '#fff',
	  'border-color': '#d3d3d3',
	  'fbui-white': '#fff',
	  'fbui-desktop-background-light': '#f6f7f8'
	};
	
	/**
	 * @param {string} name
	 */
	function cssVar(name) {
	  if (CSS_VARS.hasOwnProperty(name)) {
	    return CSS_VARS[name];
	  }
	
	  throw new Error('cssVar' + '("' + name + '"): Unexpected class transformation.');
	}
	
	cssVar.CSS_VARS = CSS_VARS;
	
	module.exports = cssVar;

/***/ }),
/* 216 */
/*!*******************************************************!*\
  !*** ./~/fixed-data-table-2/internal/debounceCore.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule debounceCore
	 * @typechecks
	 */
	
	/**
	 * Invokes the given callback after a specified number of milliseconds have
	 * elapsed, ignoring subsequent calls.
	 *
	 * For example, if you wanted to update a preview after the user stops typing
	 * you could do the following:
	 *
	 *   elem.addEventListener('keyup', debounce(this.updatePreview, 250), false);
	 *
	 * The returned function has a reset method which can be called to cancel a
	 * pending invocation.
	 *
	 *   var debouncedUpdatePreview = debounce(this.updatePreview, 250);
	 *   elem.addEventListener('keyup', debouncedUpdatePreview, false);
	 *
	 *   // later, to cancel pending calls
	 *   debouncedUpdatePreview.reset();
	 *
	 * @param {function} func - the function to debounce
	 * @param {number} wait - how long to wait in milliseconds
	 * @param {*} context - optional context to invoke the function in
	 * @param {?function} setTimeoutFunc - an implementation of setTimeout
	 *  if nothing is passed in the default setTimeout function is used
	  * @param {?function} clearTimeoutFunc - an implementation of clearTimeout
	 *  if nothing is passed in the default clearTimeout function is used
	 */
	
	function debounce(func, wait, context, setTimeoutFunc, clearTimeoutFunc) {
	  setTimeoutFunc = setTimeoutFunc || setTimeout;
	  clearTimeoutFunc = clearTimeoutFunc || clearTimeout;
	  var timeout;
	
	  function debouncer() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    debouncer.reset();
	
	    var callback = function callback() {
	      func.apply(context, args);
	    };
	    callback.__SMmeta = func.__SMmeta;
	    timeout = setTimeoutFunc(callback, wait);
	  }
	
	  debouncer.reset = function () {
	    clearTimeoutFunc(timeout);
	  };
	
	  return debouncer;
	}
	
	module.exports = debounce;

/***/ }),
/* 217 */
/*!***********************************************************!*\
  !*** ./~/fixed-data-table-2/internal/isEventSupported.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var _ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 113);
	
	var _ExecutionEnvironment2 = _interopRequireDefault(_ExecutionEnvironment);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var useHasFeature;
	if (_ExecutionEnvironment2.default.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!_ExecutionEnvironment2.default.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ }),
/* 218 */
/*!**********************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/nativeRequestAnimationFrame.js ***!
  \**********************************************************************/
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule nativeRequestAnimationFrame
	 */
	
	var nativeRequestAnimationFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame || global.msRequestAnimationFrame;
	
	module.exports = nativeRequestAnimationFrame;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 219 */
/*!*********************************************************!*\
  !*** ./~/fixed-data-table-2/internal/normalizeWheel.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule normalizeWheel
	 * @typechecks
	 */
	
	'use strict';
	
	var _UserAgent_DEPRECATED = __webpack_require__(/*! ./UserAgent_DEPRECATED */ 212);
	
	var _UserAgent_DEPRECATED2 = _interopRequireDefault(_UserAgent_DEPRECATED);
	
	var _isEventSupported = __webpack_require__(/*! ./isEventSupported */ 217);
	
	var _isEventSupported2 = _interopRequireDefault(_isEventSupported);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	// Reasonable defaults
	var PIXEL_STEP = 10;
	var LINE_HEIGHT = 40;
	var PAGE_HEIGHT = 800;
	
	/**
	 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
	 * complicated, thus this doc is long and (hopefully) detailed enough to answer
	 * your questions.
	 *
	 * If you need to react to the mouse wheel in a predictable way, this code is
	 * like your bestest friend. * hugs *
	 *
	 * As of today, there are 4 DOM event types you can listen to:
	 *
	 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
	 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
	 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
	 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
	 *
	 * So what to do?  The is the best:
	 *
	 *   normalizeWheel.getEventType();
	 *
	 * In your event callback, use this code to get sane interpretation of the
	 * deltas.  This code will return an object with properties:
	 *
	 *   spinX   -- normalized spin speed (use for zoom) - x plane
	 *   spinY   -- " - y plane
	 *   pixelX  -- normalized distance (to pixels) - x plane
	 *   pixelY  -- " - y plane
	 *
	 * Wheel values are provided by the browser assuming you are using the wheel to
	 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
	 * significantly on different platforms and browsers, forgetting that you can
	 * scroll at different speeds.  Some devices (like trackpads) emit more events
	 * at smaller increments with fine granularity, and some emit massive jumps with
	 * linear speed or acceleration.
	 *
	 * This code does its best to normalize the deltas for you:
	 *
	 *   - spin is trying to normalize how far the wheel was spun (or trackpad
	 *     dragged).  This is super useful for zoom support where you want to
	 *     throw away the chunky scroll steps on the PC and make those equal to
	 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
	 *     resolve a single slow step on a wheel to 1.
	 *
	 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
	 *     get the crazy differences between browsers, but at least it'll be in
	 *     pixels!
	 *
	 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
	 *     should translate to positive value zooming IN, negative zooming OUT.
	 *     This matches the newer 'wheel' event.
	 *
	 * Why are there spinX, spinY (or pixels)?
	 *
	 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
	 *     with a mouse.  It results in side-scrolling in the browser by default.
	 *
	 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
	 *
	 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
	 *     probably is by browsers in conjunction with fancy 3D controllers .. but
	 *     you know.
	 *
	 * Implementation info:
	 *
	 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
	 * average mouse:
	 *
	 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
	 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
	 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
	 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
	 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
	 *
	 * On the trackpad:
	 *
	 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
	 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
	 *
	 * On other/older browsers.. it's more complicated as there can be multiple and
	 * also missing delta values.
	 *
	 * The 'wheel' event is more standard:
	 *
	 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
	 *
	 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
	 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
	 * backward compatibility with older events.  Those other values help us
	 * better normalize spin speed.  Example of what the browsers provide:
	 *
	 *                          | event.wheelDelta | event.detail
	 *        ------------------+------------------+--------------
	 *          Safari v5/OS X  |       -120       |       0
	 *          Safari v5/Win7  |       -120       |       0
	 *         Chrome v17/OS X  |       -120       |       0
	 *         Chrome v17/Win7  |       -120       |       0
	 *                IE9/Win7  |       -120       |   undefined
	 *         Firefox v4/OS X  |     undefined    |       1
	 *         Firefox v4/Win7  |     undefined    |       3
	 *
	 */
	function normalizeWheel( /*object*/event) /*object*/{
	  var sX = 0,
	      sY = 0,
	
	  // spinX, spinY
	  pX = 0,
	      pY = 0; // pixelX, pixelY
	
	  // Legacy
	  if ('detail' in event) {
	    sY = event.detail;
	  }
	  if ('wheelDelta' in event) {
	    sY = -event.wheelDelta / 120;
	  }
	  if ('wheelDeltaY' in event) {
	    sY = -event.wheelDeltaY / 120;
	  }
	  if ('wheelDeltaX' in event) {
	    sX = -event.wheelDeltaX / 120;
	  }
	
	  // side scrolling on FF with DOMMouseScroll
	  if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
	    sX = sY;
	    sY = 0;
	  }
	
	  pX = sX * PIXEL_STEP;
	  pY = sY * PIXEL_STEP;
	
	  if ('deltaY' in event) {
	    pY = event.deltaY;
	  }
	  if ('deltaX' in event) {
	    pX = event.deltaX;
	  }
	
	  if ((pX || pY) && event.deltaMode) {
	    if (event.deltaMode == 1) {
	      // delta in LINE units
	      pX *= LINE_HEIGHT;
	      pY *= LINE_HEIGHT;
	    } else {
	      // delta in PAGE units
	      pX *= PAGE_HEIGHT;
	      pY *= PAGE_HEIGHT;
	    }
	  }
	
	  // Fall-back if spin cannot be determined
	  if (pX && !sX) {
	    sX = pX < 1 ? -1 : 1;
	  }
	  if (pY && !sY) {
	    sY = pY < 1 ? -1 : 1;
	  }
	
	  return { spinX: sX,
	    spinY: sY,
	    pixelX: pX,
	    pixelY: pY };
	}
	
	/**
	 * The best combination if you prefer spinX + spinY normalization.  It favors
	 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
	 * 'wheel' event, making spin speed determination impossible.
	 */
	normalizeWheel.getEventType = function () /*string*/{
	  return _UserAgent_DEPRECATED2.default.firefox() ? 'DOMMouseScroll' : (0, _isEventSupported2.default)('wheel') ? 'wheel' : 'mousewheel';
	};
	
	module.exports = normalizeWheel;

/***/ }),
/* 220 */
/*!*****************************************************************!*\
  !*** ./~/fixed-data-table-2/internal/translateDOMPositionXY.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright Schrodinger, LLC
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule translateDOMPositionXY
	 * @typechecks
	 */
	
	'use strict';
	
	var _BrowserSupportCore = __webpack_require__(/*! ./BrowserSupportCore */ 193);
	
	var _BrowserSupportCore2 = _interopRequireDefault(_BrowserSupportCore);
	
	var _getVendorPrefixedName = __webpack_require__(/*! ./getVendorPrefixedName */ 120);
	
	var _getVendorPrefixedName2 = _interopRequireDefault(_getVendorPrefixedName);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var TRANSFORM = (0, _getVendorPrefixedName2.default)('transform');
	var BACKFACE_VISIBILITY = (0, _getVendorPrefixedName2.default)('backfaceVisibility');
	
	var translateDOMPositionXY = function () {
	  if (_BrowserSupportCore2.default.hasCSSTransforms()) {
	    var ua = global.window ? global.window.navigator.userAgent : 'UNKNOWN';
	    var isSafari = /Safari\//.test(ua) && !/Chrome\//.test(ua);
	    // It appears that Safari messes up the composition order
	    // of GPU-accelerated layers
	    // (see bug https://bugs.webkit.org/show_bug.cgi?id=61824).
	    // Use 2D translation instead.
	    if (!isSafari && _BrowserSupportCore2.default.hasCSS3DTransforms()) {
	      return function ( /*object*/style, /*number*/x, /*number*/y) {
	        style[TRANSFORM] = 'translate3d(' + x + 'px,' + y + 'px,0)';
	        style[BACKFACE_VISIBILITY] = 'hidden';
	      };
	    } else {
	      return function ( /*object*/style, /*number*/x, /*number*/y) {
	        style[TRANSFORM] = 'translate(' + x + 'px,' + y + 'px)';
	      };
	    }
	  } else {
	    return function ( /*object*/style, /*number*/x, /*number*/y) {
	      style.left = x + 'px';
	      style.top = y + 'px';
	    };
	  }
	}();
	
	module.exports = translateDOMPositionXY;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 221 */
/*!**********************************!*\
  !*** ./~/flux/lib/Dispatcher.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Dispatcher
	 * 
	 * @preventMunge
	 */
	
	'use strict';
	
	exports.__esModule = true;
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError('Cannot call a class as a function');
	  }
	}
	
	var invariant = __webpack_require__(/*! fbjs/lib/invariant */ 222);
	
	var _prefix = 'ID_';
	
	/**
	 * Dispatcher is used to broadcast payloads to registered callbacks. This is
	 * different from generic pub-sub systems in two ways:
	 *
	 *   1) Callbacks are not subscribed to particular events. Every payload is
	 *      dispatched to every registered callback.
	 *   2) Callbacks can be deferred in whole or part until other callbacks have
	 *      been executed.
	 *
	 * For example, consider this hypothetical flight destination form, which
	 * selects a default city when a country is selected:
	 *
	 *   var flightDispatcher = new Dispatcher();
	 *
	 *   // Keeps track of which country is selected
	 *   var CountryStore = {country: null};
	 *
	 *   // Keeps track of which city is selected
	 *   var CityStore = {city: null};
	 *
	 *   // Keeps track of the base flight price of the selected city
	 *   var FlightPriceStore = {price: null}
	 *
	 * When a user changes the selected city, we dispatch the payload:
	 *
	 *   flightDispatcher.dispatch({
	 *     actionType: 'city-update',
	 *     selectedCity: 'paris'
	 *   });
	 *
	 * This payload is digested by `CityStore`:
	 *
	 *   flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'city-update') {
	 *       CityStore.city = payload.selectedCity;
	 *     }
	 *   });
	 *
	 * When the user selects a country, we dispatch the payload:
	 *
	 *   flightDispatcher.dispatch({
	 *     actionType: 'country-update',
	 *     selectedCountry: 'australia'
	 *   });
	 *
	 * This payload is digested by both stores:
	 *
	 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'country-update') {
	 *       CountryStore.country = payload.selectedCountry;
	 *     }
	 *   });
	 *
	 * When the callback to update `CountryStore` is registered, we save a reference
	 * to the returned token. Using this token with `waitFor()`, we can guarantee
	 * that `CountryStore` is updated before the callback that updates `CityStore`
	 * needs to query its data.
	 *
	 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
	 *     if (payload.actionType === 'country-update') {
	 *       // `CountryStore.country` may not be updated.
	 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
	 *       // `CountryStore.country` is now guaranteed to be updated.
	 *
	 *       // Select the default city for the new country
	 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
	 *     }
	 *   });
	 *
	 * The usage of `waitFor()` can be chained, for example:
	 *
	 *   FlightPriceStore.dispatchToken =
	 *     flightDispatcher.register(function(payload) {
	 *       switch (payload.actionType) {
	 *         case 'country-update':
	 *         case 'city-update':
	 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
	 *           FlightPriceStore.price =
	 *             getFlightPriceStore(CountryStore.country, CityStore.city);
	 *           break;
	 *     }
	 *   });
	 *
	 * The `country-update` payload will be guaranteed to invoke the stores'
	 * registered callbacks in order: `CountryStore`, `CityStore`, then
	 * `FlightPriceStore`.
	 */
	
	var Dispatcher = function () {
	  function Dispatcher() {
	    _classCallCheck(this, Dispatcher);
	
	    this._callbacks = {};
	    this._isDispatching = false;
	    this._isHandled = {};
	    this._isPending = {};
	    this._lastID = 1;
	  }
	
	  /**
	   * Registers a callback to be invoked with every dispatched payload. Returns
	   * a token that can be used with `waitFor()`.
	   */
	
	  Dispatcher.prototype.register = function register(callback) {
	    var id = _prefix + this._lastID++;
	    this._callbacks[id] = callback;
	    return id;
	  };
	
	  /**
	   * Removes a callback based on its token.
	   */
	
	  Dispatcher.prototype.unregister = function unregister(id) {
	    !this._callbacks[id] ?  true ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
	    delete this._callbacks[id];
	  };
	
	  /**
	   * Waits for the callbacks specified to be invoked before continuing execution
	   * of the current callback. This method should only be used by a callback in
	   * response to a dispatched payload.
	   */
	
	  Dispatcher.prototype.waitFor = function waitFor(ids) {
	    !this._isDispatching ?  true ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
	    for (var ii = 0; ii < ids.length; ii++) {
	      var id = ids[ii];
	      if (this._isPending[id]) {
	        !this._isHandled[id] ?  true ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
	        continue;
	      }
	      !this._callbacks[id] ?  true ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
	      this._invokeCallback(id);
	    }
	  };
	
	  /**
	   * Dispatches a payload to all registered callbacks.
	   */
	
	  Dispatcher.prototype.dispatch = function dispatch(payload) {
	    !!this._isDispatching ?  true ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
	    this._startDispatching(payload);
	    try {
	      for (var id in this._callbacks) {
	        if (this._isPending[id]) {
	          continue;
	        }
	        this._invokeCallback(id);
	      }
	    } finally {
	      this._stopDispatching();
	    }
	  };
	
	  /**
	   * Is this Dispatcher currently dispatching.
	   */
	
	  Dispatcher.prototype.isDispatching = function isDispatching() {
	    return this._isDispatching;
	  };
	
	  /**
	   * Call the callback stored with the given id. Also do some internal
	   * bookkeeping.
	   *
	   * @internal
	   */
	
	  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
	    this._isPending[id] = true;
	    this._callbacks[id](this._pendingPayload);
	    this._isHandled[id] = true;
	  };
	
	  /**
	   * Set up bookkeeping needed when dispatching.
	   *
	   * @internal
	   */
	
	  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
	    for (var id in this._callbacks) {
	      this._isPending[id] = false;
	      this._isHandled[id] = false;
	    }
	    this._pendingPayload = payload;
	    this._isDispatching = true;
	  };
	
	  /**
	   * Clear bookkeeping used for dispatching.
	   *
	   * @internal
	   */
	
	  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
	    delete this._pendingPayload;
	    this._isDispatching = false;
	  };
	
	  return Dispatcher;
	}();
	
	module.exports = Dispatcher;

/***/ }),
/* 222 */
/*!****************************************!*\
  !*** ./~/flux/~/fbjs/lib/invariant.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	"use strict";
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (true) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;

/***/ }),
/* 223 */,
/* 224 */
/*!**************************************!*\
  !*** ./~/jquery-ui/ui/datepicker.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * jQuery UI Datepicker 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/datepicker/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3), __webpack_require__(/*! ./core */ 19)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
	
		$.extend($.ui, { datepicker: { version: "1.11.4" } });
	
		var datepicker_instActive;
	
		function datepicker_getZindex(elem) {
			var position, value;
			while (elem.length && elem[0] !== document) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css("position");
				if (position === "absolute" || position === "relative" || position === "fixed") {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt(elem.css("zIndex"), 10);
					if (!isNaN(value) && value !== 0) {
						return value;
					}
				}
				elem = elem.parent();
			}
	
			return 0;
		}
		/* Date picker manager.
	    Use the singleton instance of this class, $.datepicker, to interact with the date picker.
	    Settings for (groups of) date pickers are maintained in an instance object,
	    allowing multiple different settings on the same page. */
	
		function Datepicker() {
			this._curInst = null; // The current instance in use
			this._keyEvent = false; // If the last event was a key event
			this._disabledInputs = []; // List of date picker inputs that have been disabled
			this._datepickerShowing = false; // True if the popup picker is showing , false if not
			this._inDialog = false; // True if showing within a "dialog", false if not
			this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
			this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
			this._appendClass = "ui-datepicker-append"; // The name of the append marker class
			this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
			this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
			this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
			this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
			this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
			this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
			this.regional = []; // Available regional settings, indexed by language code
			this.regional[""] = { // Default regional settings
				closeText: "Done", // Display text for close link
				prevText: "Prev", // Display text for previous month link
				nextText: "Next", // Display text for next month link
				currentText: "Today", // Display text for current month link
				monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], // Names of months for drop-down and formatting
				monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
				dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
				dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
				dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
				weekHeader: "Wk", // Column header for week of the year
				dateFormat: "mm/dd/yy", // See format options on parseDate
				firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
				isRTL: false, // True if right-to-left language, false if left-to-right
				showMonthAfterYear: false, // True if the year select precedes month, false for month then year
				yearSuffix: "" // Additional text to append to the year in the month headers
			};
			this._defaults = { // Global defaults for all the date picker instances
				showOn: "focus", // "focus" for popup on focus,
				// "button" for trigger button, or "both" for either
				showAnim: "fadeIn", // Name of jQuery animation for popup
				showOptions: {}, // Options for enhanced animations
				defaultDate: null, // Used when field is blank: actual date,
				// +/-number for offset from today, null for today
				appendText: "", // Display text following the input box, e.g. showing the format
				buttonText: "...", // Text for trigger button
				buttonImage: "", // URL for trigger button image
				buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
				hideIfNoPrevNext: false, // True to hide next/previous month links
				// if not applicable, false to just disable them
				navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
				gotoCurrent: false, // True if today link goes back to current selection instead
				changeMonth: false, // True if month can be selected directly, false if only prev/next
				changeYear: false, // True if year can be selected directly, false if only prev/next
				yearRange: "c-10:c+10", // Range of years to display in drop-down,
				// either relative to today's year (-nn:+nn), relative to currently displayed year
				// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
				showOtherMonths: false, // True to show dates in other months, false to leave blank
				selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
				showWeek: false, // True to show week of the year, false to not show it
				calculateWeek: this.iso8601Week, // How to calculate the week of the year,
				// takes a Date and returns the number of the week for it
				shortYearCutoff: "+10", // Short year values < this are in the current century,
				// > this are in the previous century,
				// string value starting with "+" for current year + value
				minDate: null, // The earliest selectable date, or null for no limit
				maxDate: null, // The latest selectable date, or null for no limit
				duration: "fast", // Duration of display/closure
				beforeShowDay: null, // Function that takes a date and returns an array with
				// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
				// [2] = cell title (optional), e.g. $.datepicker.noWeekends
				beforeShow: null, // Function that takes an input field and
				// returns a set of custom settings for the date picker
				onSelect: null, // Define a callback function when a date is selected
				onChangeMonthYear: null, // Define a callback function when the month or year is changed
				onClose: null, // Define a callback function when the datepicker is closed
				numberOfMonths: 1, // Number of months to show at a time
				showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
				stepMonths: 1, // Number of months to step back/forward
				stepBigMonths: 12, // Number of months to step back/forward for the big links
				altField: "", // Selector for an alternate field to store selected dates into
				altFormat: "", // The date format to use for the alternate field
				constrainInput: true, // The input is constrained by the current date format
				showButtonPanel: false, // True to show button panel, false to not show it
				autoSize: false, // True to size the input for the date format, false to leave as is
				disabled: false // The initial disabled state
			};
			$.extend(this._defaults, this.regional[""]);
			this.regional.en = $.extend(true, {}, this.regional[""]);
			this.regional["en-US"] = $.extend(true, {}, this.regional.en);
			this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
		}
	
		$.extend(Datepicker.prototype, {
			/* Class name added to elements to indicate already configured with a date picker. */
			markerClassName: "hasDatepicker",
	
			//Keep track of the maximum number of rows displayed (see #7043)
			maxRows: 4,
	
			// TODO rename to "widget" when switching to widget factory
			_widgetDatepicker: function _widgetDatepicker() {
				return this.dpDiv;
			},
	
			/* Override the default settings for all instances of the date picker.
	   * @param  settings  object - the new settings to use as defaults (anonymous object)
	   * @return the manager object
	   */
			setDefaults: function setDefaults(settings) {
				datepicker_extendRemove(this._defaults, settings || {});
				return this;
			},
	
			/* Attach the date picker to a jQuery selection.
	   * @param  target	element - the target input field or division or span
	   * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	   */
			_attachDatepicker: function _attachDatepicker(target, settings) {
				var nodeName, inline, inst;
				nodeName = target.nodeName.toLowerCase();
				inline = nodeName === "div" || nodeName === "span";
				if (!target.id) {
					this.uuid += 1;
					target.id = "dp" + this.uuid;
				}
				inst = this._newInst($(target), inline);
				inst.settings = $.extend({}, settings || {});
				if (nodeName === "input") {
					this._connectDatepicker(target, inst);
				} else if (inline) {
					this._inlineDatepicker(target, inst);
				}
			},
	
			/* Create a new instance object. */
			_newInst: function _newInst(target, inline) {
				var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
				return { id: id, input: target, // associated target
					selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
					drawMonth: 0, drawYear: 0, // month being drawn
					inline: inline, // is datepicker inline or not
					dpDiv: !inline ? this.dpDiv : // presentation div
					datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) };
			},
	
			/* Attach the date picker to an input field. */
			_connectDatepicker: function _connectDatepicker(target, inst) {
				var input = $(target);
				inst.append = $([]);
				inst.trigger = $([]);
				if (input.hasClass(this.markerClassName)) {
					return;
				}
				this._attachments(input, inst);
				input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
				this._autoSize(inst);
				$.data(target, "datepicker", inst);
				//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
				if (inst.settings.disabled) {
					this._disableDatepicker(target);
				}
			},
	
			/* Make attachments based on settings. */
			_attachments: function _attachments(input, inst) {
				var showOn,
				    buttonText,
				    buttonImage,
				    appendText = this._get(inst, "appendText"),
				    isRTL = this._get(inst, "isRTL");
	
				if (inst.append) {
					inst.append.remove();
				}
				if (appendText) {
					inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
					input[isRTL ? "before" : "after"](inst.append);
				}
	
				input.unbind("focus", this._showDatepicker);
	
				if (inst.trigger) {
					inst.trigger.remove();
				}
	
				showOn = this._get(inst, "showOn");
				if (showOn === "focus" || showOn === "both") {
					// pop-up date picker when in the marked field
					input.focus(this._showDatepicker);
				}
				if (showOn === "button" || showOn === "both") {
					// pop-up date picker when button clicked
					buttonText = this._get(inst, "buttonText");
					buttonImage = this._get(inst, "buttonImage");
					inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({ src: buttonImage, alt: buttonText, title: buttonText }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({ src: buttonImage, alt: buttonText, title: buttonText })));
					input[isRTL ? "before" : "after"](inst.trigger);
					inst.trigger.click(function () {
						if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
							$.datepicker._hideDatepicker();
						} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
							$.datepicker._hideDatepicker();
							$.datepicker._showDatepicker(input[0]);
						} else {
							$.datepicker._showDatepicker(input[0]);
						}
						return false;
					});
				}
			},
	
			/* Apply the maximum length for the date format. */
			_autoSize: function _autoSize(inst) {
				if (this._get(inst, "autoSize") && !inst.inline) {
					var findMax,
					    max,
					    maxI,
					    i,
					    date = new Date(2009, 12 - 1, 20),
					    // Ensure double digits
					dateFormat = this._get(inst, "dateFormat");
	
					if (dateFormat.match(/[DM]/)) {
						findMax = function findMax(names) {
							max = 0;
							maxI = 0;
							for (i = 0; i < names.length; i++) {
								if (names[i].length > max) {
									max = names[i].length;
									maxI = i;
								}
							}
							return maxI;
						};
						date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
						date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
					}
					inst.input.attr("size", this._formatDate(inst, date).length);
				}
			},
	
			/* Attach an inline date picker to a div. */
			_inlineDatepicker: function _inlineDatepicker(target, inst) {
				var divSpan = $(target);
				if (divSpan.hasClass(this.markerClassName)) {
					return;
				}
				divSpan.addClass(this.markerClassName).append(inst.dpDiv);
				$.data(target, "datepicker", inst);
				this._setDate(inst, this._getDefaultDate(inst), true);
				this._updateDatepicker(inst);
				this._updateAlternate(inst);
				//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
				if (inst.settings.disabled) {
					this._disableDatepicker(target);
				}
				// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
				// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
				inst.dpDiv.css("display", "block");
			},
	
			/* Pop-up the date picker in a "dialog" box.
	   * @param  input element - ignored
	   * @param  date	string or Date - the initial date to display
	   * @param  onSelect  function - the function to call when a date is selected
	   * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   * @param  pos int[2] - coordinates for the dialog's position within the screen or
	   *					event - with x/y coordinates or
	   *					leave empty for default (screen centre)
	   * @return the manager object
	   */
			_dialogDatepicker: function _dialogDatepicker(input, date, onSelect, settings, pos) {
				var id,
				    browserWidth,
				    browserHeight,
				    scrollX,
				    scrollY,
				    inst = this._dialogInst; // internal instance
	
				if (!inst) {
					this.uuid += 1;
					id = "dp" + this.uuid;
					this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
					this._dialogInput.keydown(this._doKeyDown);
					$("body").append(this._dialogInput);
					inst = this._dialogInst = this._newInst(this._dialogInput, false);
					inst.settings = {};
					$.data(this._dialogInput[0], "datepicker", inst);
				}
				datepicker_extendRemove(inst.settings, settings || {});
				date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
				this._dialogInput.val(date);
	
				this._pos = pos ? pos.length ? pos : [pos.pageX, pos.pageY] : null;
				if (!this._pos) {
					browserWidth = document.documentElement.clientWidth;
					browserHeight = document.documentElement.clientHeight;
					scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
					scrollY = document.documentElement.scrollTop || document.body.scrollTop;
					this._pos = // should use actual width/height below
					[browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY];
				}
	
				// move input on screen for focus, but hidden behind dialog
				this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
				inst.settings.onSelect = onSelect;
				this._inDialog = true;
				this.dpDiv.addClass(this._dialogClass);
				this._showDatepicker(this._dialogInput[0]);
				if ($.blockUI) {
					$.blockUI(this.dpDiv);
				}
				$.data(this._dialogInput[0], "datepicker", inst);
				return this;
			},
	
			/* Detach a datepicker from its control.
	   * @param  target	element - the target input field or division or span
	   */
			_destroyDatepicker: function _destroyDatepicker(target) {
				var nodeName,
				    $target = $(target),
				    inst = $.data(target, "datepicker");
	
				if (!$target.hasClass(this.markerClassName)) {
					return;
				}
	
				nodeName = target.nodeName.toLowerCase();
				$.removeData(target, "datepicker");
				if (nodeName === "input") {
					inst.append.remove();
					inst.trigger.remove();
					$target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp);
				} else if (nodeName === "div" || nodeName === "span") {
					$target.removeClass(this.markerClassName).empty();
				}
	
				if (datepicker_instActive === inst) {
					datepicker_instActive = null;
				}
			},
	
			/* Enable the date picker to a jQuery selection.
	   * @param  target	element - the target input field or division or span
	   */
			_enableDatepicker: function _enableDatepicker(target) {
				var nodeName,
				    inline,
				    $target = $(target),
				    inst = $.data(target, "datepicker");
	
				if (!$target.hasClass(this.markerClassName)) {
					return;
				}
	
				nodeName = target.nodeName.toLowerCase();
				if (nodeName === "input") {
					target.disabled = false;
					inst.trigger.filter("button").each(function () {
						this.disabled = false;
					}).end().filter("img").css({ opacity: "1.0", cursor: "" });
				} else if (nodeName === "div" || nodeName === "span") {
					inline = $target.children("." + this._inlineClass);
					inline.children().removeClass("ui-state-disabled");
					inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
				}
				this._disabledInputs = $.map(this._disabledInputs, function (value) {
					return value === target ? null : value;
				}); // delete entry
			},
	
			/* Disable the date picker to a jQuery selection.
	   * @param  target	element - the target input field or division or span
	   */
			_disableDatepicker: function _disableDatepicker(target) {
				var nodeName,
				    inline,
				    $target = $(target),
				    inst = $.data(target, "datepicker");
	
				if (!$target.hasClass(this.markerClassName)) {
					return;
				}
	
				nodeName = target.nodeName.toLowerCase();
				if (nodeName === "input") {
					target.disabled = true;
					inst.trigger.filter("button").each(function () {
						this.disabled = true;
					}).end().filter("img").css({ opacity: "0.5", cursor: "default" });
				} else if (nodeName === "div" || nodeName === "span") {
					inline = $target.children("." + this._inlineClass);
					inline.children().addClass("ui-state-disabled");
					inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
				}
				this._disabledInputs = $.map(this._disabledInputs, function (value) {
					return value === target ? null : value;
				}); // delete entry
				this._disabledInputs[this._disabledInputs.length] = target;
			},
	
			/* Is the first field in a jQuery collection disabled as a datepicker?
	   * @param  target	element - the target input field or division or span
	   * @return boolean - true if disabled, false if enabled
	   */
			_isDisabledDatepicker: function _isDisabledDatepicker(target) {
				if (!target) {
					return false;
				}
				for (var i = 0; i < this._disabledInputs.length; i++) {
					if (this._disabledInputs[i] === target) {
						return true;
					}
				}
				return false;
			},
	
			/* Retrieve the instance data for the target control.
	   * @param  target  element - the target input field or division or span
	   * @return  object - the associated instance data
	   * @throws  error if a jQuery problem getting data
	   */
			_getInst: function _getInst(target) {
				try {
					return $.data(target, "datepicker");
				} catch (err) {
					throw "Missing instance data for this datepicker";
				}
			},
	
			/* Update or retrieve the settings for a date picker attached to an input field or division.
	   * @param  target  element - the target input field or division or span
	   * @param  name	object - the new settings to update or
	   *				string - the name of the setting to change or retrieve,
	   *				when retrieving also "all" for all instance settings or
	   *				"defaults" for all global defaults
	   * @param  value   any - the new value for the setting
	   *				(omit if above is an object or to retrieve a value)
	   */
			_optionDatepicker: function _optionDatepicker(target, name, value) {
				var settings,
				    date,
				    minDate,
				    maxDate,
				    inst = this._getInst(target);
	
				if (arguments.length === 2 && typeof name === "string") {
					return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
				}
	
				settings = name || {};
				if (typeof name === "string") {
					settings = {};
					settings[name] = value;
				}
	
				if (inst) {
					if (this._curInst === inst) {
						this._hideDatepicker();
					}
	
					date = this._getDateDatepicker(target, true);
					minDate = this._getMinMaxDate(inst, "min");
					maxDate = this._getMinMaxDate(inst, "max");
					datepicker_extendRemove(inst.settings, settings);
					// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
					if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
						inst.settings.minDate = this._formatDate(inst, minDate);
					}
					if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
						inst.settings.maxDate = this._formatDate(inst, maxDate);
					}
					if ("disabled" in settings) {
						if (settings.disabled) {
							this._disableDatepicker(target);
						} else {
							this._enableDatepicker(target);
						}
					}
					this._attachments($(target), inst);
					this._autoSize(inst);
					this._setDate(inst, date);
					this._updateAlternate(inst);
					this._updateDatepicker(inst);
				}
			},
	
			// change method deprecated
			_changeDatepicker: function _changeDatepicker(target, name, value) {
				this._optionDatepicker(target, name, value);
			},
	
			/* Redraw the date picker attached to an input field or division.
	   * @param  target  element - the target input field or division or span
	   */
			_refreshDatepicker: function _refreshDatepicker(target) {
				var inst = this._getInst(target);
				if (inst) {
					this._updateDatepicker(inst);
				}
			},
	
			/* Set the dates for a jQuery selection.
	   * @param  target element - the target input field or division or span
	   * @param  date	Date - the new date
	   */
			_setDateDatepicker: function _setDateDatepicker(target, date) {
				var inst = this._getInst(target);
				if (inst) {
					this._setDate(inst, date);
					this._updateDatepicker(inst);
					this._updateAlternate(inst);
				}
			},
	
			/* Get the date(s) for the first entry in a jQuery selection.
	   * @param  target element - the target input field or division or span
	   * @param  noDefault boolean - true if no default date is to be used
	   * @return Date - the current date
	   */
			_getDateDatepicker: function _getDateDatepicker(target, noDefault) {
				var inst = this._getInst(target);
				if (inst && !inst.inline) {
					this._setDateFromField(inst, noDefault);
				}
				return inst ? this._getDate(inst) : null;
			},
	
			/* Handle keystrokes. */
			_doKeyDown: function _doKeyDown(event) {
				var onSelect,
				    dateStr,
				    sel,
				    inst = $.datepicker._getInst(event.target),
				    handled = true,
				    isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
	
				inst._keyEvent = true;
				if ($.datepicker._datepickerShowing) {
					switch (event.keyCode) {
						case 9:
							$.datepicker._hideDatepicker();
							handled = false;
							break; // hide on tab out
						case 13:
							sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
							if (sel[0]) {
								$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							}
	
							onSelect = $.datepicker._get(inst, "onSelect");
							if (onSelect) {
								dateStr = $.datepicker._formatDate(inst);
	
								// trigger custom callback
								onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]);
							} else {
								$.datepicker._hideDatepicker();
							}
	
							return false; // don't submit the form
						case 27:
							$.datepicker._hideDatepicker();
							break; // hide on escape
						case 33:
							$.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
							break; // previous month/year on page up/+ ctrl
						case 34:
							$.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
							break; // next month/year on page down/+ ctrl
						case 35:
							if (event.ctrlKey || event.metaKey) {
								$.datepicker._clearDate(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // clear on ctrl or command +end
						case 36:
							if (event.ctrlKey || event.metaKey) {
								$.datepicker._gotoToday(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // current on ctrl or command +home
						case 37:
							if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// -1 day on ctrl or command +left
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
							}
							// next month/year on alt +left on Mac
							break;
						case 38:
							if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, -7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // -1 week on ctrl or command +up
						case 39:
							if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// +1 day on ctrl or command +right
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
							}
							// next month/year on alt +right
							break;
						case 40:
							if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, +7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // +1 week on ctrl or command +down
						default:
							handled = false;
					}
				} else if (event.keyCode === 36 && event.ctrlKey) {
					// display the date picker on ctrl+home
					$.datepicker._showDatepicker(this);
				} else {
					handled = false;
				}
	
				if (handled) {
					event.preventDefault();
					event.stopPropagation();
				}
			},
	
			/* Filter entered characters - based on date format. */
			_doKeyPress: function _doKeyPress(event) {
				var chars,
				    chr,
				    inst = $.datepicker._getInst(event.target);
	
				if ($.datepicker._get(inst, "constrainInput")) {
					chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
					chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
					return event.ctrlKey || event.metaKey || chr < " " || !chars || chars.indexOf(chr) > -1;
				}
			},
	
			/* Synchronise manual entry and field/alternate field. */
			_doKeyUp: function _doKeyUp(event) {
				var date,
				    inst = $.datepicker._getInst(event.target);
	
				if (inst.input.val() !== inst.lastVal) {
					try {
						date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
	
						if (date) {
							// only if valid
							$.datepicker._setDateFromField(inst);
							$.datepicker._updateAlternate(inst);
							$.datepicker._updateDatepicker(inst);
						}
					} catch (err) {}
				}
				return true;
			},
	
			/* Pop-up the date picker for a given input field.
	   * If false returned from beforeShow event handler do not show.
	   * @param  input  element - the input field attached to the date picker or
	   *					event - if triggered by focus
	   */
			_showDatepicker: function _showDatepicker(input) {
				input = input.target || input;
				if (input.nodeName.toLowerCase() !== "input") {
					// find from button/image trigger
					input = $("input", input.parentNode)[0];
				}
	
				if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
					// already here
					return;
				}
	
				var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
	
				inst = $.datepicker._getInst(input);
				if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
					$.datepicker._curInst.dpDiv.stop(true, true);
					if (inst && $.datepicker._datepickerShowing) {
						$.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
					}
				}
	
				beforeShow = $.datepicker._get(inst, "beforeShow");
				beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
				if (beforeShowSettings === false) {
					return;
				}
				datepicker_extendRemove(inst.settings, beforeShowSettings);
	
				inst.lastVal = null;
				$.datepicker._lastInput = input;
				$.datepicker._setDateFromField(inst);
	
				if ($.datepicker._inDialog) {
					// hide cursor
					input.value = "";
				}
				if (!$.datepicker._pos) {
					// position below input
					$.datepicker._pos = $.datepicker._findPos(input);
					$.datepicker._pos[1] += input.offsetHeight; // add the height
				}
	
				isFixed = false;
				$(input).parents().each(function () {
					isFixed |= $(this).css("position") === "fixed";
					return !isFixed;
				});
	
				offset = { left: $.datepicker._pos[0], top: $.datepicker._pos[1] };
				$.datepicker._pos = null;
				//to avoid flashes on Firefox
				inst.dpDiv.empty();
				// determine sizing offscreen
				inst.dpDiv.css({ position: "absolute", display: "block", top: "-1000px" });
				$.datepicker._updateDatepicker(inst);
				// fix width for dynamic number of date pickers
				// and adjust position before showing
				offset = $.datepicker._checkOffset(inst, offset, isFixed);
				inst.dpDiv.css({ position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute", display: "none",
					left: offset.left + "px", top: offset.top + "px" });
	
				if (!inst.inline) {
					showAnim = $.datepicker._get(inst, "showAnim");
					duration = $.datepicker._get(inst, "duration");
					inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
					$.datepicker._datepickerShowing = true;
	
					if ($.effects && $.effects.effect[showAnim]) {
						inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
					} else {
						inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
					}
	
					if ($.datepicker._shouldFocusInput(inst)) {
						inst.input.focus();
					}
	
					$.datepicker._curInst = inst;
				}
			},
	
			/* Generate the date picker content. */
			_updateDatepicker: function _updateDatepicker(inst) {
				this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
				datepicker_instActive = inst; // for delegate hover events
				inst.dpDiv.empty().append(this._generateHTML(inst));
				this._attachHandlers(inst);
	
				var origyearshtml,
				    numMonths = this._getNumberOfMonths(inst),
				    cols = numMonths[1],
				    width = 17,
				    activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
	
				if (activeCell.length > 0) {
					datepicker_handleMouseover.apply(activeCell.get(0));
				}
	
				inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
				if (cols > 1) {
					inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
				}
				inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
				inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
	
				if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
					inst.input.focus();
				}
	
				// deffered render of the years select (to avoid flashes on Firefox)
				if (inst.yearshtml) {
					origyearshtml = inst.yearshtml;
					setTimeout(function () {
						//assure that inst.yearshtml didn't change.
						if (origyearshtml === inst.yearshtml && inst.yearshtml) {
							inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
						}
						origyearshtml = inst.yearshtml = null;
					}, 0);
				}
			},
	
			// #6694 - don't focus the input if it's already focused
			// this breaks the change event in IE
			// Support: IE and jQuery <1.9
			_shouldFocusInput: function _shouldFocusInput(inst) {
				return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
			},
	
			/* Check positioning to remain on screen. */
			_checkOffset: function _checkOffset(inst, offset, isFixed) {
				var dpWidth = inst.dpDiv.outerWidth(),
				    dpHeight = inst.dpDiv.outerHeight(),
				    inputWidth = inst.input ? inst.input.outerWidth() : 0,
				    inputHeight = inst.input ? inst.input.outerHeight() : 0,
				    viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
				    viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
	
				offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
				offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
				offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
	
				// now check if datepicker is showing outside window viewport - move to a better place if so.
				offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
				offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
	
				return offset;
			},
	
			/* Find an object's position on the screen. */
			_findPos: function _findPos(obj) {
				var position,
				    inst = this._getInst(obj),
				    isRTL = this._get(inst, "isRTL");
	
				while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
					obj = obj[isRTL ? "previousSibling" : "nextSibling"];
				}
	
				position = $(obj).offset();
				return [position.left, position.top];
			},
	
			/* Hide the date picker from view.
	   * @param  input  element - the input field attached to the date picker
	   */
			_hideDatepicker: function _hideDatepicker(input) {
				var showAnim,
				    duration,
				    postProcess,
				    onClose,
				    inst = this._curInst;
	
				if (!inst || input && inst !== $.data(input, "datepicker")) {
					return;
				}
	
				if (this._datepickerShowing) {
					showAnim = this._get(inst, "showAnim");
					duration = this._get(inst, "duration");
					postProcess = function postProcess() {
						$.datepicker._tidyDialog(inst);
					};
	
					// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
					if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
						inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
					} else {
						inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
					}
	
					if (!showAnim) {
						postProcess();
					}
					this._datepickerShowing = false;
	
					onClose = this._get(inst, "onClose");
					if (onClose) {
						onClose.apply(inst.input ? inst.input[0] : null, [inst.input ? inst.input.val() : "", inst]);
					}
	
					this._lastInput = null;
					if (this._inDialog) {
						this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
						if ($.blockUI) {
							$.unblockUI();
							$("body").append(this.dpDiv);
						}
					}
					this._inDialog = false;
				}
			},
	
			/* Tidy up after a dialog display. */
			_tidyDialog: function _tidyDialog(inst) {
				inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
			},
	
			/* Close date picker if clicked elsewhere. */
			_checkExternalClick: function _checkExternalClick(event) {
				if (!$.datepicker._curInst) {
					return;
				}
	
				var $target = $(event.target),
				    inst = $.datepicker._getInst($target[0]);
	
				if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
					$.datepicker._hideDatepicker();
				}
			},
	
			/* Adjust one of the date sub-fields. */
			_adjustDate: function _adjustDate(id, offset, period) {
				var target = $(id),
				    inst = this._getInst(target[0]);
	
				if (this._isDisabledDatepicker(target[0])) {
					return;
				}
				this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
				period);
				this._updateDatepicker(inst);
			},
	
			/* Action for current link. */
			_gotoToday: function _gotoToday(id) {
				var date,
				    target = $(id),
				    inst = this._getInst(target[0]);
	
				if (this._get(inst, "gotoCurrent") && inst.currentDay) {
					inst.selectedDay = inst.currentDay;
					inst.drawMonth = inst.selectedMonth = inst.currentMonth;
					inst.drawYear = inst.selectedYear = inst.currentYear;
				} else {
					date = new Date();
					inst.selectedDay = date.getDate();
					inst.drawMonth = inst.selectedMonth = date.getMonth();
					inst.drawYear = inst.selectedYear = date.getFullYear();
				}
				this._notifyChange(inst);
				this._adjustDate(target);
			},
	
			/* Action for selecting a new month/year. */
			_selectMonthYear: function _selectMonthYear(id, select, period) {
				var target = $(id),
				    inst = this._getInst(target[0]);
	
				inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
	
				this._notifyChange(inst);
				this._adjustDate(target);
			},
	
			/* Action for selecting a day. */
			_selectDay: function _selectDay(id, month, year, td) {
				var inst,
				    target = $(id);
	
				if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
					return;
				}
	
				inst = this._getInst(target[0]);
				inst.selectedDay = inst.currentDay = $("a", td).html();
				inst.selectedMonth = inst.currentMonth = month;
				inst.selectedYear = inst.currentYear = year;
				this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
			},
	
			/* Erase the input field and hide the date picker. */
			_clearDate: function _clearDate(id) {
				var target = $(id);
				this._selectDate(target, "");
			},
	
			/* Update the input field with the selected date. */
			_selectDate: function _selectDate(id, dateStr) {
				var onSelect,
				    target = $(id),
				    inst = this._getInst(target[0]);
	
				dateStr = dateStr != null ? dateStr : this._formatDate(inst);
				if (inst.input) {
					inst.input.val(dateStr);
				}
				this._updateAlternate(inst);
	
				onSelect = this._get(inst, "onSelect");
				if (onSelect) {
					onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]); // trigger custom callback
				} else if (inst.input) {
					inst.input.trigger("change"); // fire the change event
				}
	
				if (inst.inline) {
					this._updateDatepicker(inst);
				} else {
					this._hideDatepicker();
					this._lastInput = inst.input[0];
					if (_typeof(inst.input[0]) !== "object") {
						inst.input.focus(); // restore focus
					}
					this._lastInput = null;
				}
			},
	
			/* Update any alternate field to synchronise with the main field. */
			_updateAlternate: function _updateAlternate(inst) {
				var altFormat,
				    date,
				    dateStr,
				    altField = this._get(inst, "altField");
	
				if (altField) {
					// update alternate field too
					altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
					date = this._getDate(inst);
					dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
					$(altField).each(function () {
						$(this).val(dateStr);
					});
				}
			},
	
			/* Set as beforeShowDay function to prevent selection of weekends.
	   * @param  date  Date - the date to customise
	   * @return [boolean, string] - is this date selectable?, what is its CSS class?
	   */
			noWeekends: function noWeekends(date) {
				var day = date.getDay();
				return [day > 0 && day < 6, ""];
			},
	
			/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   * @param  date  Date - the date to get the week for
	   * @return  number - the number of the week within the year that contains this date
	   */
			iso8601Week: function iso8601Week(date) {
				var time,
				    checkDate = new Date(date.getTime());
	
				// Find Thursday of this week starting on Monday
				checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
	
				time = checkDate.getTime();
				checkDate.setMonth(0); // Compare with Jan 1
				checkDate.setDate(1);
				return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
			},
	
			/* Parse a string value into a date object.
	   * See formatDate below for the possible formats.
	   *
	   * @param  format string - the expected format of the date
	   * @param  value string - the date in the above format
	   * @param  settings Object - attributes include:
	   *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	   *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	   *					dayNames		string[7] - names of the days from Sunday (optional)
	   *					monthNamesShort string[12] - abbreviated names of the months (optional)
	   *					monthNames		string[12] - names of the months (optional)
	   * @return  Date - the extracted date value or null if value is blank
	   */
			parseDate: function parseDate(format, value, settings) {
				if (format == null || value == null) {
					throw "Invalid arguments";
				}
	
				value = (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" ? value.toString() : value + "";
				if (value === "") {
					return null;
				}
	
				var iFormat,
				    dim,
				    extra,
				    iValue = 0,
				    shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
				    shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10),
				    dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
				    year = -1,
				    month = -1,
				    day = -1,
				    doy = -1,
				    literal = false,
				    date,
	
				// Check whether a format character is doubled
				lookAhead = function lookAhead(match) {
					var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
					if (matches) {
						iFormat++;
					}
					return matches;
				},
	
				// Extract a number from the string value
				getNumber = function getNumber(match) {
					var isDoubled = lookAhead(match),
					    size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2,
					    minSize = match === "y" ? size : 1,
					    digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
					    num = value.substring(iValue).match(digits);
					if (!num) {
						throw "Missing number at position " + iValue;
					}
					iValue += num[0].length;
					return parseInt(num[0], 10);
				},
	
				// Extract a name from the string value and convert to an index
				getName = function getName(match, shortNames, longNames) {
					var index = -1,
					    names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [[k, v]];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});
	
					$.each(names, function (i, pair) {
						var name = pair[1];
						if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
							index = pair[0];
							iValue += name.length;
							return false;
						}
					});
					if (index !== -1) {
						return index + 1;
					} else {
						throw "Unknown name at position " + iValue;
					}
				},
	
				// Confirm that a literal character matches the string value
				checkLiteral = function checkLiteral() {
					if (value.charAt(iValue) !== format.charAt(iFormat)) {
						throw "Unexpected literal at position " + iValue;
					}
					iValue++;
				};
	
				for (iFormat = 0; iFormat < format.length; iFormat++) {
					if (literal) {
						if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
							literal = false;
						} else {
							checkLiteral();
						}
					} else {
						switch (format.charAt(iFormat)) {
							case "d":
								day = getNumber("d");
								break;
							case "D":
								getName("D", dayNamesShort, dayNames);
								break;
							case "o":
								doy = getNumber("o");
								break;
							case "m":
								month = getNumber("m");
								break;
							case "M":
								month = getName("M", monthNamesShort, monthNames);
								break;
							case "y":
								year = getNumber("y");
								break;
							case "@":
								date = new Date(getNumber("@"));
								year = date.getFullYear();
								month = date.getMonth() + 1;
								day = date.getDate();
								break;
							case "!":
								date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
								year = date.getFullYear();
								month = date.getMonth() + 1;
								day = date.getDate();
								break;
							case "'":
								if (lookAhead("'")) {
									checkLiteral();
								} else {
									literal = true;
								}
								break;
							default:
								checkLiteral();
						}
					}
				}
	
				if (iValue < value.length) {
					extra = value.substr(iValue);
					if (!/^\s+/.test(extra)) {
						throw "Extra/unparsed characters found in date: " + extra;
					}
				}
	
				if (year === -1) {
					year = new Date().getFullYear();
				} else if (year < 100) {
					year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
				}
	
				if (doy > -1) {
					month = 1;
					day = doy;
					do {
						dim = this._getDaysInMonth(year, month - 1);
						if (day <= dim) {
							break;
						}
						month++;
						day -= dim;
					} while (true);
				}
	
				date = this._daylightSavingAdjust(new Date(year, month - 1, day));
				if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
					throw "Invalid date"; // E.g. 31/02/00
				}
				return date;
			},
	
			/* Standard date formats. */
			ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
			COOKIE: "D, dd M yy",
			ISO_8601: "yy-mm-dd",
			RFC_822: "D, d M y",
			RFC_850: "DD, dd-M-y",
			RFC_1036: "D, d M y",
			RFC_1123: "D, d M yy",
			RFC_2822: "D, d M yy",
			RSS: "D, d M y", // RFC 822
			TICKS: "!",
			TIMESTAMP: "@",
			W3C: "yy-mm-dd", // ISO 8601
	
			_ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,
	
			/* Format a date object into a string value.
	   * The format can be combinations of the following:
	   * d  - day of month (no leading zero)
	   * dd - day of month (two digit)
	   * o  - day of year (no leading zeros)
	   * oo - day of year (three digit)
	   * D  - day name short
	   * DD - day name long
	   * m  - month of year (no leading zero)
	   * mm - month of year (two digit)
	   * M  - month name short
	   * MM - month name long
	   * y  - year (two digit)
	   * yy - year (four digit)
	   * @ - Unix timestamp (ms since 01/01/1970)
	   * ! - Windows ticks (100ns since 01/01/0001)
	   * "..." - literal text
	   * '' - single quote
	   *
	   * @param  format string - the desired format of the date
	   * @param  date Date - the date value to format
	   * @param  settings Object - attributes include:
	   *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	   *					dayNames		string[7] - names of the days from Sunday (optional)
	   *					monthNamesShort string[12] - abbreviated names of the months (optional)
	   *					monthNames		string[12] - names of the months (optional)
	   * @return  string - the date in the above format
	   */
			formatDate: function formatDate(format, date, settings) {
				if (!date) {
					return "";
				}
	
				var iFormat,
				    dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
	
				// Check whether a format character is doubled
				lookAhead = function lookAhead(match) {
					var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
					if (matches) {
						iFormat++;
					}
					return matches;
				},
	
				// Format a number, with leading zero if necessary
				formatNumber = function formatNumber(match, value, len) {
					var num = "" + value;
					if (lookAhead(match)) {
						while (num.length < len) {
							num = "0" + num;
						}
					}
					return num;
				},
	
				// Format a name, short or long as requested
				formatName = function formatName(match, value, shortNames, longNames) {
					return lookAhead(match) ? longNames[value] : shortNames[value];
				},
				    output = "",
				    literal = false;
	
				if (date) {
					for (iFormat = 0; iFormat < format.length; iFormat++) {
						if (literal) {
							if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
								literal = false;
							} else {
								output += format.charAt(iFormat);
							}
						} else {
							switch (format.charAt(iFormat)) {
								case "d":
									output += formatNumber("d", date.getDate(), 2);
									break;
								case "D":
									output += formatName("D", date.getDay(), dayNamesShort, dayNames);
									break;
								case "o":
									output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
									break;
								case "m":
									output += formatNumber("m", date.getMonth() + 1, 2);
									break;
								case "M":
									output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
									break;
								case "y":
									output += lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100;
									break;
								case "@":
									output += date.getTime();
									break;
								case "!":
									output += date.getTime() * 10000 + this._ticksTo1970;
									break;
								case "'":
									if (lookAhead("'")) {
										output += "'";
									} else {
										literal = true;
									}
									break;
								default:
									output += format.charAt(iFormat);
							}
						}
					}
				}
				return output;
			},
	
			/* Extract all possible characters from the date format. */
			_possibleChars: function _possibleChars(format) {
				var iFormat,
				    chars = "",
				    literal = false,
	
				// Check whether a format character is doubled
				lookAhead = function lookAhead(match) {
					var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
					if (matches) {
						iFormat++;
					}
					return matches;
				};
	
				for (iFormat = 0; iFormat < format.length; iFormat++) {
					if (literal) {
						if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
							literal = false;
						} else {
							chars += format.charAt(iFormat);
						}
					} else {
						switch (format.charAt(iFormat)) {
							case "d":case "m":case "y":case "@":
								chars += "0123456789";
								break;
							case "D":case "M":
								return null; // Accept anything
							case "'":
								if (lookAhead("'")) {
									chars += "'";
								} else {
									literal = true;
								}
								break;
							default:
								chars += format.charAt(iFormat);
						}
					}
				}
				return chars;
			},
	
			/* Get a setting value, defaulting if necessary. */
			_get: function _get(inst, name) {
				return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
			},
	
			/* Parse existing date and initialise date picker. */
			_setDateFromField: function _setDateFromField(inst, noDefault) {
				if (inst.input.val() === inst.lastVal) {
					return;
				}
	
				var dateFormat = this._get(inst, "dateFormat"),
				    dates = inst.lastVal = inst.input ? inst.input.val() : null,
				    defaultDate = this._getDefaultDate(inst),
				    date = defaultDate,
				    settings = this._getFormatConfig(inst);
	
				try {
					date = this.parseDate(dateFormat, dates, settings) || defaultDate;
				} catch (event) {
					dates = noDefault ? "" : dates;
				}
				inst.selectedDay = date.getDate();
				inst.drawMonth = inst.selectedMonth = date.getMonth();
				inst.drawYear = inst.selectedYear = date.getFullYear();
				inst.currentDay = dates ? date.getDate() : 0;
				inst.currentMonth = dates ? date.getMonth() : 0;
				inst.currentYear = dates ? date.getFullYear() : 0;
				this._adjustInstDate(inst);
			},
	
			/* Retrieve the default date shown on opening. */
			_getDefaultDate: function _getDefaultDate(inst) {
				return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
			},
	
			/* A date may be specified as an exact value or a relative one. */
			_determineDate: function _determineDate(inst, date, defaultDate) {
				var offsetNumeric = function offsetNumeric(offset) {
					var date = new Date();
					date.setDate(date.getDate() + offset);
					return date;
				},
				    offsetString = function offsetString(offset) {
					try {
						return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
					} catch (e) {
						// Ignore
					}
	
					var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(),
					    year = date.getFullYear(),
					    month = date.getMonth(),
					    day = date.getDate(),
					    pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					    matches = pattern.exec(offset);
	
					while (matches) {
						switch (matches[2] || "d") {
							case "d":case "D":
								day += parseInt(matches[1], 10);break;
							case "w":case "W":
								day += parseInt(matches[1], 10) * 7;break;
							case "m":case "M":
								month += parseInt(matches[1], 10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
							case "y":case "Y":
								year += parseInt(matches[1], 10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
						}
						matches = pattern.exec(offset);
					}
					return new Date(year, month, day);
				},
				    newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
	
				newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;
				if (newDate) {
					newDate.setHours(0);
					newDate.setMinutes(0);
					newDate.setSeconds(0);
					newDate.setMilliseconds(0);
				}
				return this._daylightSavingAdjust(newDate);
			},
	
			/* Handle switch to/from daylight saving.
	   * Hours may be non-zero on daylight saving cut-over:
	   * > 12 when midnight changeover, but then cannot generate
	   * midnight datetime, so jump to 1AM, otherwise reset.
	   * @param  date  (Date) the date to check
	   * @return  (Date) the corrected date
	   */
			_daylightSavingAdjust: function _daylightSavingAdjust(date) {
				if (!date) {
					return null;
				}
				date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
				return date;
			},
	
			/* Set the date(s) directly. */
			_setDate: function _setDate(inst, date, noChange) {
				var clear = !date,
				    origMonth = inst.selectedMonth,
				    origYear = inst.selectedYear,
				    newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
	
				inst.selectedDay = inst.currentDay = newDate.getDate();
				inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
				inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
				if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
					this._notifyChange(inst);
				}
				this._adjustInstDate(inst);
				if (inst.input) {
					inst.input.val(clear ? "" : this._formatDate(inst));
				}
			},
	
			/* Retrieve the date(s) directly. */
			_getDate: function _getDate(inst) {
				var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
				return startDate;
			},
	
			/* Attach the onxxx handlers.  These are declared statically so
	   * they work with static code transformers like Caja.
	   */
			_attachHandlers: function _attachHandlers(inst) {
				var stepMonths = this._get(inst, "stepMonths"),
				    id = "#" + inst.id.replace(/\\\\/g, "\\");
				inst.dpDiv.find("[data-handler]").map(function () {
					var handler = {
						prev: function prev() {
							$.datepicker._adjustDate(id, -stepMonths, "M");
						},
						next: function next() {
							$.datepicker._adjustDate(id, +stepMonths, "M");
						},
						hide: function hide() {
							$.datepicker._hideDatepicker();
						},
						today: function today() {
							$.datepicker._gotoToday(id);
						},
						selectDay: function selectDay() {
							$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
							return false;
						},
						selectMonth: function selectMonth() {
							$.datepicker._selectMonthYear(id, this, "M");
							return false;
						},
						selectYear: function selectYear() {
							$.datepicker._selectMonthYear(id, this, "Y");
							return false;
						}
					};
					$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
				});
			},
	
			/* Generate the HTML for the current state of the date picker. */
			_generateHTML: function _generateHTML(inst) {
				var maxDraw,
				    prevText,
				    prev,
				    nextText,
				    next,
				    currentText,
				    gotoDate,
				    controls,
				    buttonPanel,
				    firstDay,
				    showWeek,
				    dayNames,
				    dayNamesMin,
				    monthNames,
				    monthNamesShort,
				    beforeShowDay,
				    showOtherMonths,
				    selectOtherMonths,
				    defaultDate,
				    html,
				    dow,
				    row,
				    group,
				    col,
				    selectedDate,
				    cornerClass,
				    calender,
				    thead,
				    day,
				    daysInMonth,
				    leadDays,
				    curRows,
				    numRows,
				    printDate,
				    dRow,
				    tbody,
				    daySettings,
				    otherMonth,
				    unselectable,
				    tempDate = new Date(),
				    today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),
				    // clear time
				isRTL = this._get(inst, "isRTL"),
				    showButtonPanel = this._get(inst, "showButtonPanel"),
				    hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
				    navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
				    numMonths = this._getNumberOfMonths(inst),
				    showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
				    stepMonths = this._get(inst, "stepMonths"),
				    isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1,
				    currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)),
				    minDate = this._getMinMaxDate(inst, "min"),
				    maxDate = this._getMinMaxDate(inst, "max"),
				    drawMonth = inst.drawMonth - showCurrentAtPos,
				    drawYear = inst.drawYear;
	
				if (drawMonth < 0) {
					drawMonth += 12;
					drawYear--;
				}
				if (maxDate) {
					maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
					maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
					while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
						drawMonth--;
						if (drawMonth < 0) {
							drawMonth = 11;
							drawYear--;
						}
					}
				}
				inst.drawMonth = drawMonth;
				inst.drawYear = drawYear;
	
				prevText = this._get(inst, "prevText");
				prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
	
				prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
	
				nextText = this._get(inst, "nextText");
				nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
	
				next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
	
				currentText = this._get(inst, "currentText");
				gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
				currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
	
				controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
	
				buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
	
				firstDay = parseInt(this._get(inst, "firstDay"), 10);
				firstDay = isNaN(firstDay) ? 0 : firstDay;
	
				showWeek = this._get(inst, "showWeek");
				dayNames = this._get(inst, "dayNames");
				dayNamesMin = this._get(inst, "dayNamesMin");
				monthNames = this._get(inst, "monthNames");
				monthNamesShort = this._get(inst, "monthNamesShort");
				beforeShowDay = this._get(inst, "beforeShowDay");
				showOtherMonths = this._get(inst, "showOtherMonths");
				selectOtherMonths = this._get(inst, "selectOtherMonths");
				defaultDate = this._getDefaultDate(inst);
				html = "";
				dow;
				for (row = 0; row < numMonths[0]; row++) {
					group = "";
					this.maxRows = 4;
					for (col = 0; col < numMonths[1]; col++) {
						selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
						cornerClass = " ui-corner-all";
						calender = "";
						if (isMultiMonth) {
							calender += "<div class='ui-datepicker-group";
							if (numMonths[1] > 1) {
								switch (col) {
									case 0:
										calender += " ui-datepicker-group-first";
										cornerClass = " ui-corner-" + (isRTL ? "right" : "left");break;
									case numMonths[1] - 1:
										calender += " ui-datepicker-group-last";
										cornerClass = " ui-corner-" + (isRTL ? "left" : "right");break;
									default:
										calender += " ui-datepicker-group-middle";cornerClass = "";break;
								}
							}
							calender += "'>";
						}
						calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
						"</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
						thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";
						for (dow = 0; dow < 7; dow++) {
							// days of the week
							day = (dow + firstDay) % 7;
							thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
						}
						calender += thead + "</tr></thead><tbody>";
						daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
						if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
							inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
						}
						leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
						curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
						numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows; //If multiple months, use the higher number of rows (see #7043)
						this.maxRows = numRows;
						printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
						for (dRow = 0; dRow < numRows; dRow++) {
							// create date picker rows
							calender += "<tr>";
							tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";
							for (dow = 0; dow < 7; dow++) {
								// create date picker days
								daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [true, ""];
								otherMonth = printDate.getMonth() !== drawMonth;
								unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
								tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + ( // highlight weekends
								otherMonth ? " ui-datepicker-other-month" : "") + ( // highlight days from other months
								printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || // user pressed key
								defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ?
								// or defaultDate is current printedDate and defaultDate is selectedDate
								" " + this._dayOverClass : "") + ( // highlight selected day
								unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + ( // highlight unselectable days
								otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + ( // highlight custom dates
								printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + ( // highlight selected day
								printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ( // highlight today (if different)
								(!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + ( // cell title
								unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + ( // actions
								otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
								unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + ( // highlight selected day
								otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
								"' href='#'>" + printDate.getDate() + "</a>") + "</td>"; // display selectable date
								printDate.setDate(printDate.getDate() + 1);
								printDate = this._daylightSavingAdjust(printDate);
							}
							calender += tbody + "</tr>";
						}
						drawMonth++;
						if (drawMonth > 11) {
							drawMonth = 0;
							drawYear++;
						}
						calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
						group += calender;
					}
					html += group;
				}
				html += buttonPanel;
				inst._keyEvent = false;
				return html;
			},
	
			/* Generate the month and year header. */
			_generateMonthYearHeader: function _generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
	
				var inMinYear,
				    inMaxYear,
				    month,
				    years,
				    thisYear,
				    determineYear,
				    year,
				    endYear,
				    changeMonth = this._get(inst, "changeMonth"),
				    changeYear = this._get(inst, "changeYear"),
				    showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
				    html = "<div class='ui-datepicker-title'>",
				    monthHtml = "";
	
				// month selection
				if (secondary || !changeMonth) {
					monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
				} else {
					inMinYear = minDate && minDate.getFullYear() === drawYear;
					inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
					monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
					for (month = 0; month < 12; month++) {
						if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
							monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
						}
					}
					monthHtml += "</select>";
				}
	
				if (!showMonthAfterYear) {
					html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
				}
	
				// year selection
				if (!inst.yearshtml) {
					inst.yearshtml = "";
					if (secondary || !changeYear) {
						html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
					} else {
						// determine range of years to display
						years = this._get(inst, "yearRange").split(":");
						thisYear = new Date().getFullYear();
						determineYear = function determineYear(value) {
							var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
							return isNaN(year) ? thisYear : year;
						};
						year = determineYear(years[0]);
						endYear = Math.max(year, determineYear(years[1] || ""));
						year = minDate ? Math.max(year, minDate.getFullYear()) : year;
						endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
						inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
						for (; year <= endYear; year++) {
							inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
						}
						inst.yearshtml += "</select>";
	
						html += inst.yearshtml;
						inst.yearshtml = null;
					}
				}
	
				html += this._get(inst, "yearSuffix");
				if (showMonthAfterYear) {
					html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
				}
				html += "</div>"; // Close datepicker_header
				return html;
			},
	
			/* Adjust one of the date sub-fields. */
			_adjustInstDate: function _adjustInstDate(inst, offset, period) {
				var year = inst.drawYear + (period === "Y" ? offset : 0),
				    month = inst.drawMonth + (period === "M" ? offset : 0),
				    day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
				    date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
	
				inst.selectedDay = date.getDate();
				inst.drawMonth = inst.selectedMonth = date.getMonth();
				inst.drawYear = inst.selectedYear = date.getFullYear();
				if (period === "M" || period === "Y") {
					this._notifyChange(inst);
				}
			},
	
			/* Ensure a date is within any min/max bounds. */
			_restrictMinMax: function _restrictMinMax(inst, date) {
				var minDate = this._getMinMaxDate(inst, "min"),
				    maxDate = this._getMinMaxDate(inst, "max"),
				    newDate = minDate && date < minDate ? minDate : date;
				return maxDate && newDate > maxDate ? maxDate : newDate;
			},
	
			/* Notify change of month/year. */
			_notifyChange: function _notifyChange(inst) {
				var onChange = this._get(inst, "onChangeMonthYear");
				if (onChange) {
					onChange.apply(inst.input ? inst.input[0] : null, [inst.selectedYear, inst.selectedMonth + 1, inst]);
				}
			},
	
			/* Determine the number of months to show. */
			_getNumberOfMonths: function _getNumberOfMonths(inst) {
				var numMonths = this._get(inst, "numberOfMonths");
				return numMonths == null ? [1, 1] : typeof numMonths === "number" ? [1, numMonths] : numMonths;
			},
	
			/* Determine the current maximum date - ensure no time components are set. */
			_getMinMaxDate: function _getMinMaxDate(inst, minMax) {
				return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
			},
	
			/* Find the number of days in a given month. */
			_getDaysInMonth: function _getDaysInMonth(year, month) {
				return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
			},
	
			/* Find the day of the week of the first of a month. */
			_getFirstDayOfMonth: function _getFirstDayOfMonth(year, month) {
				return new Date(year, month, 1).getDay();
			},
	
			/* Determines if we should allow a "next/prev" month display change. */
			_canAdjustMonth: function _canAdjustMonth(inst, offset, curYear, curMonth) {
				var numMonths = this._getNumberOfMonths(inst),
				    date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
	
				if (offset < 0) {
					date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
				}
				return this._isInRange(inst, date);
			},
	
			/* Is the given date in the accepted range? */
			_isInRange: function _isInRange(inst, date) {
				var yearSplit,
				    currentYear,
				    minDate = this._getMinMaxDate(inst, "min"),
				    maxDate = this._getMinMaxDate(inst, "max"),
				    minYear = null,
				    maxYear = null,
				    years = this._get(inst, "yearRange");
				if (years) {
					yearSplit = years.split(":");
					currentYear = new Date().getFullYear();
					minYear = parseInt(yearSplit[0], 10);
					maxYear = parseInt(yearSplit[1], 10);
					if (yearSplit[0].match(/[+\-].*/)) {
						minYear += currentYear;
					}
					if (yearSplit[1].match(/[+\-].*/)) {
						maxYear += currentYear;
					}
				}
	
				return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
			},
	
			/* Provide the configuration settings for formatting/parsing. */
			_getFormatConfig: function _getFormatConfig(inst) {
				var shortYearCutoff = this._get(inst, "shortYearCutoff");
				shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
				return { shortYearCutoff: shortYearCutoff,
					dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
					monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames") };
			},
	
			/* Format the given date for display. */
			_formatDate: function _formatDate(inst, day, month, year) {
				if (!day) {
					inst.currentDay = inst.selectedDay;
					inst.currentMonth = inst.selectedMonth;
					inst.currentYear = inst.selectedYear;
				}
				var date = day ? (typeof day === "undefined" ? "undefined" : _typeof(day)) === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
				return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
			}
		});
	
		/*
	  * Bind hover events for datepicker elements.
	  * Done via delegate so the binding only occurs once in the lifetime of the parent div.
	  * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
	  */
		function datepicker_bindHover(dpDiv) {
			var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
			return dpDiv.delegate(selector, "mouseout", function () {
				$(this).removeClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).removeClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).removeClass("ui-datepicker-next-hover");
				}
			}).delegate(selector, "mouseover", datepicker_handleMouseover);
		}
	
		function datepicker_handleMouseover() {
			if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		}
	
		/* jQuery extend now ignores nulls! */
		function datepicker_extendRemove(target, props) {
			$.extend(target, props);
			for (var name in props) {
				if (props[name] == null) {
					target[name] = props[name];
				}
			}
			return target;
		}
	
		/* Invoke the datepicker functionality.
	    @param  options  string - a command, optionally followed by additional parameters or
	 					Object - settings for attaching new datepicker functionality
	    @return  jQuery object */
		$.fn.datepicker = function (options) {
	
			/* Verify an empty collection wasn't passed - Fixes #6976 */
			if (!this.length) {
				return this;
			}
	
			/* Initialise the date picker. */
			if (!$.datepicker.initialized) {
				$(document).mousedown($.datepicker._checkExternalClick);
				$.datepicker.initialized = true;
			}
	
			/* Append datepicker main container to body if not exist. */
			if ($("#" + $.datepicker._mainDivId).length === 0) {
				$("body").append($.datepicker.dpDiv);
			}
	
			var otherArgs = Array.prototype.slice.call(arguments, 1);
			if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
				return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
			}
			if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
				return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
			}
			return this.each(function () {
				typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
			});
		};
	
		$.datepicker = new Datepicker(); // singleton instance
		$.datepicker.initialized = false;
		$.datepicker.uuid = new Date().getTime();
		$.datepicker.version = "1.11.4";
	
		return $.datepicker;
	});

/***/ }),
/* 225 */
/*!************************************!*\
  !*** ./~/jquery-ui/ui/position.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/*!
	 * jQuery UI Position 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/position/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
		(function () {
	
			$.ui = $.ui || {};
	
			var cachedScrollbarWidth,
			    supportsOffsetFractions,
			    max = Math.max,
			    abs = Math.abs,
			    round = Math.round,
			    rhorizontal = /left|center|right/,
			    rvertical = /top|center|bottom/,
			    roffset = /[\+\-]\d+(\.[\d]+)?%?/,
			    rposition = /^\w+/,
			    rpercent = /%$/,
			    _position = $.fn.position;
	
			function getOffsets(offsets, width, height) {
				return [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)];
			}
	
			function parseCss(element, property) {
				return parseInt($.css(element, property), 10) || 0;
			}
	
			function getDimensions(elem) {
				var raw = elem[0];
				if (raw.nodeType === 9) {
					return {
						width: elem.width(),
						height: elem.height(),
						offset: { top: 0, left: 0 }
					};
				}
				if ($.isWindow(raw)) {
					return {
						width: elem.width(),
						height: elem.height(),
						offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
					};
				}
				if (raw.preventDefault) {
					return {
						width: 0,
						height: 0,
						offset: { top: raw.pageY, left: raw.pageX }
					};
				}
				return {
					width: elem.outerWidth(),
					height: elem.outerHeight(),
					offset: elem.offset()
				};
			}
	
			$.position = {
				scrollbarWidth: function scrollbarWidth() {
					if (cachedScrollbarWidth !== undefined) {
						return cachedScrollbarWidth;
					}
					var w1,
					    w2,
					    div = $("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
					    innerDiv = div.children()[0];
	
					$("body").append(div);
					w1 = innerDiv.offsetWidth;
					div.css("overflow", "scroll");
	
					w2 = innerDiv.offsetWidth;
	
					if (w1 === w2) {
						w2 = div[0].clientWidth;
					}
	
					div.remove();
	
					return cachedScrollbarWidth = w1 - w2;
				},
				getScrollInfo: function getScrollInfo(within) {
					var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"),
					    overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"),
					    hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth,
					    hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
					return {
						width: hasOverflowY ? $.position.scrollbarWidth() : 0,
						height: hasOverflowX ? $.position.scrollbarWidth() : 0
					};
				},
				getWithinInfo: function getWithinInfo(element) {
					var withinElement = $(element || window),
					    isWindow = $.isWindow(withinElement[0]),
					    isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
					return {
						element: withinElement,
						isWindow: isWindow,
						isDocument: isDocument,
						offset: withinElement.offset() || { left: 0, top: 0 },
						scrollLeft: withinElement.scrollLeft(),
						scrollTop: withinElement.scrollTop(),
	
						// support: jQuery 1.6.x
						// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
						width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
						height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
					};
				}
			};
	
			$.fn.position = function (options) {
				if (!options || !options.of) {
					return _position.apply(this, arguments);
				}
	
				// make a copy, we don't want to modify arguments
				options = $.extend({}, options);
	
				var atOffset,
				    targetWidth,
				    targetHeight,
				    targetOffset,
				    basePosition,
				    dimensions,
				    target = $(options.of),
				    within = $.position.getWithinInfo(options.within),
				    scrollInfo = $.position.getScrollInfo(within),
				    collision = (options.collision || "flip").split(" "),
				    offsets = {};
	
				dimensions = getDimensions(target);
				if (target[0].preventDefault) {
					// force left top to allow flipping
					options.at = "left top";
				}
				targetWidth = dimensions.width;
				targetHeight = dimensions.height;
				targetOffset = dimensions.offset;
				// clone to reuse original targetOffset later
				basePosition = $.extend({}, targetOffset);
	
				// force my and at to have valid horizontal and vertical positions
				// if a value is missing or invalid, it will be converted to center
				$.each(["my", "at"], function () {
					var pos = (options[this] || "").split(" "),
					    horizontalOffset,
					    verticalOffset;
	
					if (pos.length === 1) {
						pos = rhorizontal.test(pos[0]) ? pos.concat(["center"]) : rvertical.test(pos[0]) ? ["center"].concat(pos) : ["center", "center"];
					}
					pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
					pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
	
					// calculate offsets
					horizontalOffset = roffset.exec(pos[0]);
					verticalOffset = roffset.exec(pos[1]);
					offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0];
	
					// reduce to just the positions without the offsets
					options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];
				});
	
				// normalize collision option
				if (collision.length === 1) {
					collision[1] = collision[0];
				}
	
				if (options.at[0] === "right") {
					basePosition.left += targetWidth;
				} else if (options.at[0] === "center") {
					basePosition.left += targetWidth / 2;
				}
	
				if (options.at[1] === "bottom") {
					basePosition.top += targetHeight;
				} else if (options.at[1] === "center") {
					basePosition.top += targetHeight / 2;
				}
	
				atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
				basePosition.left += atOffset[0];
				basePosition.top += atOffset[1];
	
				return this.each(function () {
					var collisionPosition,
					    using,
					    elem = $(this),
					    elemWidth = elem.outerWidth(),
					    elemHeight = elem.outerHeight(),
					    marginLeft = parseCss(this, "marginLeft"),
					    marginTop = parseCss(this, "marginTop"),
					    collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
					    collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
					    position = $.extend({}, basePosition),
					    myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
	
					if (options.my[0] === "right") {
						position.left -= elemWidth;
					} else if (options.my[0] === "center") {
						position.left -= elemWidth / 2;
					}
	
					if (options.my[1] === "bottom") {
						position.top -= elemHeight;
					} else if (options.my[1] === "center") {
						position.top -= elemHeight / 2;
					}
	
					position.left += myOffset[0];
					position.top += myOffset[1];
	
					// if the browser doesn't support fractions, then round for consistent results
					if (!supportsOffsetFractions) {
						position.left = round(position.left);
						position.top = round(position.top);
					}
	
					collisionPosition = {
						marginLeft: marginLeft,
						marginTop: marginTop
					};
	
					$.each(["left", "top"], function (i, dir) {
						if ($.ui.position[collision[i]]) {
							$.ui.position[collision[i]][dir](position, {
								targetWidth: targetWidth,
								targetHeight: targetHeight,
								elemWidth: elemWidth,
								elemHeight: elemHeight,
								collisionPosition: collisionPosition,
								collisionWidth: collisionWidth,
								collisionHeight: collisionHeight,
								offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
								my: options.my,
								at: options.at,
								within: within,
								elem: elem
							});
						}
					});
	
					if (options.using) {
						// adds feedback as second argument to using callback, if present
						using = function using(props) {
							var left = targetOffset.left - position.left,
							    right = left + targetWidth - elemWidth,
							    top = targetOffset.top - position.top,
							    bottom = top + targetHeight - elemHeight,
							    feedback = {
								target: {
									element: target,
									left: targetOffset.left,
									top: targetOffset.top,
									width: targetWidth,
									height: targetHeight
								},
								element: {
									element: elem,
									left: position.left,
									top: position.top,
									width: elemWidth,
									height: elemHeight
								},
								horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
								vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
							};
							if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
								feedback.horizontal = "center";
							}
							if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
								feedback.vertical = "middle";
							}
							if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
								feedback.important = "horizontal";
							} else {
								feedback.important = "vertical";
							}
							options.using.call(this, props, feedback);
						};
					}
	
					elem.offset($.extend(position, { using: using }));
				});
			};
	
			$.ui.position = {
				fit: {
					left: function left(position, data) {
						var within = data.within,
						    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
						    outerWidth = within.width,
						    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
						    overLeft = withinOffset - collisionPosLeft,
						    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
						    newOverRight;
	
						// element is wider than within
						if (data.collisionWidth > outerWidth) {
							// element is initially over the left side of within
							if (overLeft > 0 && overRight <= 0) {
								newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
								position.left += overLeft - newOverRight;
								// element is initially over right side of within
							} else if (overRight > 0 && overLeft <= 0) {
								position.left = withinOffset;
								// element is initially over both left and right sides of within
							} else {
								if (overLeft > overRight) {
									position.left = withinOffset + outerWidth - data.collisionWidth;
								} else {
									position.left = withinOffset;
								}
							}
							// too far left -> align with left edge
						} else if (overLeft > 0) {
							position.left += overLeft;
							// too far right -> align with right edge
						} else if (overRight > 0) {
							position.left -= overRight;
							// adjust based on position and margin
						} else {
							position.left = max(position.left - collisionPosLeft, position.left);
						}
					},
					top: function top(position, data) {
						var within = data.within,
						    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
						    outerHeight = data.within.height,
						    collisionPosTop = position.top - data.collisionPosition.marginTop,
						    overTop = withinOffset - collisionPosTop,
						    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
						    newOverBottom;
	
						// element is taller than within
						if (data.collisionHeight > outerHeight) {
							// element is initially over the top of within
							if (overTop > 0 && overBottom <= 0) {
								newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
								position.top += overTop - newOverBottom;
								// element is initially over bottom of within
							} else if (overBottom > 0 && overTop <= 0) {
								position.top = withinOffset;
								// element is initially over both top and bottom of within
							} else {
								if (overTop > overBottom) {
									position.top = withinOffset + outerHeight - data.collisionHeight;
								} else {
									position.top = withinOffset;
								}
							}
							// too far up -> align with top
						} else if (overTop > 0) {
							position.top += overTop;
							// too far down -> align with bottom edge
						} else if (overBottom > 0) {
							position.top -= overBottom;
							// adjust based on position and margin
						} else {
							position.top = max(position.top - collisionPosTop, position.top);
						}
					}
				},
				flip: {
					left: function left(position, data) {
						var within = data.within,
						    withinOffset = within.offset.left + within.scrollLeft,
						    outerWidth = within.width,
						    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
						    collisionPosLeft = position.left - data.collisionPosition.marginLeft,
						    overLeft = collisionPosLeft - offsetLeft,
						    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
						    myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0,
						    atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0,
						    offset = -2 * data.offset[0],
						    newOverRight,
						    newOverLeft;
	
						if (overLeft < 0) {
							newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
							if (newOverRight < 0 || newOverRight < abs(overLeft)) {
								position.left += myOffset + atOffset + offset;
							}
						} else if (overRight > 0) {
							newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
							if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
								position.left += myOffset + atOffset + offset;
							}
						}
					},
					top: function top(position, data) {
						var within = data.within,
						    withinOffset = within.offset.top + within.scrollTop,
						    outerHeight = within.height,
						    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
						    collisionPosTop = position.top - data.collisionPosition.marginTop,
						    overTop = collisionPosTop - offsetTop,
						    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
						    top = data.my[1] === "top",
						    myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0,
						    atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0,
						    offset = -2 * data.offset[1],
						    newOverTop,
						    newOverBottom;
						if (overTop < 0) {
							newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
							if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
								position.top += myOffset + atOffset + offset;
							}
						} else if (overBottom > 0) {
							newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
							if (newOverTop > 0 || abs(newOverTop) < overBottom) {
								position.top += myOffset + atOffset + offset;
							}
						}
					}
				},
				flipfit: {
					left: function left() {
						$.ui.position.flip.left.apply(this, arguments);
						$.ui.position.fit.left.apply(this, arguments);
					},
					top: function top() {
						$.ui.position.flip.top.apply(this, arguments);
						$.ui.position.fit.top.apply(this, arguments);
					}
				}
			};
	
			// fraction support test
			(function () {
				var testElement,
				    testElementParent,
				    testElementStyle,
				    offsetLeft,
				    i,
				    body = document.getElementsByTagName("body")[0],
				    div = document.createElement("div");
	
				//Create a "fake body" for testing based on method used in jQuery.support
				testElement = document.createElement(body ? "div" : "body");
				testElementStyle = {
					visibility: "hidden",
					width: 0,
					height: 0,
					border: 0,
					margin: 0,
					background: "none"
				};
				if (body) {
					$.extend(testElementStyle, {
						position: "absolute",
						left: "-1000px",
						top: "-1000px"
					});
				}
				for (i in testElementStyle) {
					testElement.style[i] = testElementStyle[i];
				}
				testElement.appendChild(div);
				testElementParent = body || document.documentElement;
				testElementParent.insertBefore(testElement, testElementParent.firstChild);
	
				div.style.cssText = "position: absolute; left: 10.7432222px;";
	
				offsetLeft = $(div).offset().left;
				supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
	
				testElement.innerHTML = "";
				testElementParent.removeChild(testElement);
			})();
		})();
	
		return $.ui.position;
	});

/***/ }),
/* 226 */
/*!************************************!*\
  !*** ./~/jquery-ui/ui/sortable.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/*!
	 * jQuery UI Sortable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/sortable/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3), __webpack_require__(/*! ./core */ 19), __webpack_require__(/*! ./mouse */ 72), __webpack_require__(/*! ./widget */ 36)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
	
		return $.widget("ui.sortable", $.ui.mouse, {
			version: "1.11.4",
			widgetEventPrefix: "sort",
			ready: false,
			options: {
				appendTo: "parent",
				axis: false,
				connectWith: false,
				containment: false,
				cursor: "auto",
				cursorAt: false,
				dropOnEmpty: true,
				forcePlaceholderSize: false,
				forceHelperSize: false,
				grid: false,
				handle: false,
				helper: "original",
				items: "> *",
				opacity: false,
				placeholder: false,
				revert: false,
				scroll: true,
				scrollSensitivity: 20,
				scrollSpeed: 20,
				scope: "default",
				tolerance: "intersect",
				zIndex: 1000,
	
				// callbacks
				activate: null,
				beforeStop: null,
				change: null,
				deactivate: null,
				out: null,
				over: null,
				receive: null,
				remove: null,
				sort: null,
				start: null,
				stop: null,
				update: null
			},
	
			_isOverAxis: function _isOverAxis(x, reference, size) {
				return x >= reference && x < reference + size;
			},
	
			_isFloating: function _isFloating(item) {
				return (/left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"))
				);
			},
	
			_create: function _create() {
				this.containerCache = {};
				this.element.addClass("ui-sortable");
	
				//Get the items
				this.refresh();
	
				//Let's determine the parent's offset
				this.offset = this.element.offset();
	
				//Initialize mouse events for interaction
				this._mouseInit();
	
				this._setHandleClassName();
	
				//We're ready to go
				this.ready = true;
			},
	
			_setOption: function _setOption(key, value) {
				this._super(key, value);
	
				if (key === "handle") {
					this._setHandleClassName();
				}
			},
	
			_setHandleClassName: function _setHandleClassName() {
				this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle");
				$.each(this.items, function () {
					(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle");
				});
			},
	
			_destroy: function _destroy() {
				this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle");
				this._mouseDestroy();
	
				for (var i = this.items.length - 1; i >= 0; i--) {
					this.items[i].item.removeData(this.widgetName + "-item");
				}
	
				return this;
			},
	
			_mouseCapture: function _mouseCapture(event, overrideHandle) {
				var currentItem = null,
				    validHandle = false,
				    that = this;
	
				if (this.reverting) {
					return false;
				}
	
				if (this.options.disabled || this.options.type === "static") {
					return false;
				}
	
				//We have to refresh the items data once first
				this._refreshItems(event);
	
				//Find out if the clicked node (or one of its parents) is a actual item in this.items
				$(event.target).parents().each(function () {
					if ($.data(this, that.widgetName + "-item") === that) {
						currentItem = $(this);
						return false;
					}
				});
				if ($.data(event.target, that.widgetName + "-item") === that) {
					currentItem = $(event.target);
				}
	
				if (!currentItem) {
					return false;
				}
				if (this.options.handle && !overrideHandle) {
					$(this.options.handle, currentItem).find("*").addBack().each(function () {
						if (this === event.target) {
							validHandle = true;
						}
					});
					if (!validHandle) {
						return false;
					}
				}
	
				this.currentItem = currentItem;
				this._removeCurrentsFromItems();
				return true;
			},
	
			_mouseStart: function _mouseStart(event, overrideHandle, noActivation) {
	
				var i,
				    body,
				    o = this.options;
	
				this.currentContainer = this;
	
				//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
				this.refreshPositions();
	
				//Create and append the visible helper
				this.helper = this._createHelper(event);
	
				//Cache the helper size
				this._cacheHelperProportions();
	
				/*
	    * - Position generation -
	    * This block generates everything position related - it's the core of draggables.
	    */
	
				//Cache the margins of the original element
				this._cacheMargins();
	
				//Get the next scrolling parent
				this.scrollParent = this.helper.scrollParent();
	
				//The element's absolute position on the page minus margins
				this.offset = this.currentItem.offset();
				this.offset = {
					top: this.offset.top - this.margins.top,
					left: this.offset.left - this.margins.left
				};
	
				$.extend(this.offset, {
					click: { //Where the click happened, relative to the element
						left: event.pageX - this.offset.left,
						top: event.pageY - this.offset.top
					},
					parent: this._getParentOffset(),
					relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
				});
	
				// Only after we got the offset, we can change the helper's position to absolute
				// TODO: Still need to figure out a way to make relative sorting possible
				this.helper.css("position", "absolute");
				this.cssPosition = this.helper.css("position");
	
				//Generate the original position
				this.originalPosition = this._generatePosition(event);
				this.originalPageX = event.pageX;
				this.originalPageY = event.pageY;
	
				//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
				o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
	
				//Cache the former DOM position
				this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
	
				//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
				if (this.helper[0] !== this.currentItem[0]) {
					this.currentItem.hide();
				}
	
				//Create the placeholder
				this._createPlaceholder();
	
				//Set a containment if given in the options
				if (o.containment) {
					this._setContainment();
				}
	
				if (o.cursor && o.cursor !== "auto") {
					// cursor option
					body = this.document.find("body");
	
					// support: IE
					this.storedCursor = body.css("cursor");
					body.css("cursor", o.cursor);
	
					this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
				}
	
				if (o.opacity) {
					// opacity option
					if (this.helper.css("opacity")) {
						this._storedOpacity = this.helper.css("opacity");
					}
					this.helper.css("opacity", o.opacity);
				}
	
				if (o.zIndex) {
					// zIndex option
					if (this.helper.css("zIndex")) {
						this._storedZIndex = this.helper.css("zIndex");
					}
					this.helper.css("zIndex", o.zIndex);
				}
	
				//Prepare scrolling
				if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
					this.overflowOffset = this.scrollParent.offset();
				}
	
				//Call callbacks
				this._trigger("start", event, this._uiHash());
	
				//Recache the helper size
				if (!this._preserveHelperProportions) {
					this._cacheHelperProportions();
				}
	
				//Post "activate" events to possible containers
				if (!noActivation) {
					for (i = this.containers.length - 1; i >= 0; i--) {
						this.containers[i]._trigger("activate", event, this._uiHash(this));
					}
				}
	
				//Prepare possible droppables
				if ($.ui.ddmanager) {
					$.ui.ddmanager.current = this;
				}
	
				if ($.ui.ddmanager && !o.dropBehaviour) {
					$.ui.ddmanager.prepareOffsets(this, event);
				}
	
				this.dragging = true;
	
				this.helper.addClass("ui-sortable-helper");
				this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
				return true;
			},
	
			_mouseDrag: function _mouseDrag(event) {
				var i,
				    item,
				    itemElement,
				    intersection,
				    o = this.options,
				    scrolled = false;
	
				//Compute the helpers position
				this.position = this._generatePosition(event);
				this.positionAbs = this._convertPositionTo("absolute");
	
				if (!this.lastPositionAbs) {
					this.lastPositionAbs = this.positionAbs;
				}
	
				//Do scrolling
				if (this.options.scroll) {
					if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
	
						if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
							this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
						} else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
							this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
						}
	
						if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
							this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
						} else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
							this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
						}
					} else {
	
						if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
							scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
						} else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
							scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
						}
	
						if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
							scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
						} else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
							scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
						}
					}
	
					if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
						$.ui.ddmanager.prepareOffsets(this, event);
					}
				}
	
				//Regenerate the absolute position used for position checks
				this.positionAbs = this._convertPositionTo("absolute");
	
				//Set the helper position
				if (!this.options.axis || this.options.axis !== "y") {
					this.helper[0].style.left = this.position.left + "px";
				}
				if (!this.options.axis || this.options.axis !== "x") {
					this.helper[0].style.top = this.position.top + "px";
				}
	
				//Rearrange
				for (i = this.items.length - 1; i >= 0; i--) {
	
					//Cache variables and intersection, continue if no intersection
					item = this.items[i];
					itemElement = item.item[0];
					intersection = this._intersectsWithPointer(item);
					if (!intersection) {
						continue;
					}
	
					// Only put the placeholder inside the current Container, skip all
					// items from other containers. This works because when moving
					// an item from one container to another the
					// currentContainer is switched before the placeholder is moved.
					//
					// Without this, moving items in "sub-sortables" can cause
					// the placeholder to jitter between the outer and inner container.
					if (item.instance !== this.currentContainer) {
						continue;
					}
	
					// cannot intersect with itself
					// no useless actions that have been done before
					// no action if the item moved is the parent of the item checked
					if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
	
						this.direction = intersection === 1 ? "down" : "up";
	
						if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
							this._rearrange(event, item);
						} else {
							break;
						}
	
						this._trigger("change", event, this._uiHash());
						break;
					}
				}
	
				//Post events to containers
				this._contactContainers(event);
	
				//Interconnect with droppables
				if ($.ui.ddmanager) {
					$.ui.ddmanager.drag(this, event);
				}
	
				//Call callbacks
				this._trigger("sort", event, this._uiHash());
	
				this.lastPositionAbs = this.positionAbs;
				return false;
			},
	
			_mouseStop: function _mouseStop(event, noPropagation) {
	
				if (!event) {
					return;
				}
	
				//If we are using droppables, inform the manager about the drop
				if ($.ui.ddmanager && !this.options.dropBehaviour) {
					$.ui.ddmanager.drop(this, event);
				}
	
				if (this.options.revert) {
					var that = this,
					    cur = this.placeholder.offset(),
					    axis = this.options.axis,
					    animation = {};
	
					if (!axis || axis === "x") {
						animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
					}
					if (!axis || axis === "y") {
						animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
					}
					this.reverting = true;
					$(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
						that._clear(event);
					});
				} else {
					this._clear(event, noPropagation);
				}
	
				return false;
			},
	
			cancel: function cancel() {
	
				if (this.dragging) {
	
					this._mouseUp({ target: null });
	
					if (this.options.helper === "original") {
						this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
					} else {
						this.currentItem.show();
					}
	
					//Post deactivating events to containers
					for (var i = this.containers.length - 1; i >= 0; i--) {
						this.containers[i]._trigger("deactivate", null, this._uiHash(this));
						if (this.containers[i].containerCache.over) {
							this.containers[i]._trigger("out", null, this._uiHash(this));
							this.containers[i].containerCache.over = 0;
						}
					}
				}
	
				if (this.placeholder) {
					//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
					if (this.placeholder[0].parentNode) {
						this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
					}
					if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
						this.helper.remove();
					}
	
					$.extend(this, {
						helper: null,
						dragging: false,
						reverting: false,
						_noFinalSort: null
					});
	
					if (this.domPosition.prev) {
						$(this.domPosition.prev).after(this.currentItem);
					} else {
						$(this.domPosition.parent).prepend(this.currentItem);
					}
				}
	
				return this;
			},
	
			serialize: function serialize(o) {
	
				var items = this._getItemsAsjQuery(o && o.connected),
				    str = [];
				o = o || {};
	
				$(items).each(function () {
					var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
					if (res) {
						str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
					}
				});
	
				if (!str.length && o.key) {
					str.push(o.key + "=");
				}
	
				return str.join("&");
			},
	
			toArray: function toArray(o) {
	
				var items = this._getItemsAsjQuery(o && o.connected),
				    ret = [];
	
				o = o || {};
	
				items.each(function () {
					ret.push($(o.item || this).attr(o.attribute || "id") || "");
				});
				return ret;
			},
	
			/* Be careful with the following core functions */
			_intersectsWith: function _intersectsWith(item) {
	
				var x1 = this.positionAbs.left,
				    x2 = x1 + this.helperProportions.width,
				    y1 = this.positionAbs.top,
				    y2 = y1 + this.helperProportions.height,
				    l = item.left,
				    r = l + item.width,
				    t = item.top,
				    b = t + item.height,
				    dyClick = this.offset.click.top,
				    dxClick = this.offset.click.left,
				    isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b,
				    isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r,
				    isOverElement = isOverElementHeight && isOverElementWidth;
	
				if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
					return isOverElement;
				} else {
	
					return l < x1 + this.helperProportions.width / 2 && // Right Half
					x2 - this.helperProportions.width / 2 < r && // Left Half
					t < y1 + this.helperProportions.height / 2 && // Bottom Half
					y2 - this.helperProportions.height / 2 < b; // Top Half
				}
			},
	
			_intersectsWithPointer: function _intersectsWithPointer(item) {
	
				var isOverElementHeight = this.options.axis === "x" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
				    isOverElementWidth = this.options.axis === "y" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
				    isOverElement = isOverElementHeight && isOverElementWidth,
				    verticalDirection = this._getDragVerticalDirection(),
				    horizontalDirection = this._getDragHorizontalDirection();
	
				if (!isOverElement) {
					return false;
				}
	
				return this.floating ? horizontalDirection && horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
			},
	
			_intersectsWithSides: function _intersectsWithSides(item) {
	
				var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),
				    isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),
				    verticalDirection = this._getDragVerticalDirection(),
				    horizontalDirection = this._getDragHorizontalDirection();
	
				if (this.floating && horizontalDirection) {
					return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
				} else {
					return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
				}
			},
	
			_getDragVerticalDirection: function _getDragVerticalDirection() {
				var delta = this.positionAbs.top - this.lastPositionAbs.top;
				return delta !== 0 && (delta > 0 ? "down" : "up");
			},
	
			_getDragHorizontalDirection: function _getDragHorizontalDirection() {
				var delta = this.positionAbs.left - this.lastPositionAbs.left;
				return delta !== 0 && (delta > 0 ? "right" : "left");
			},
	
			refresh: function refresh(event) {
				this._refreshItems(event);
				this._setHandleClassName();
				this.refreshPositions();
				return this;
			},
	
			_connectWith: function _connectWith() {
				var options = this.options;
				return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
			},
	
			_getItemsAsjQuery: function _getItemsAsjQuery(connected) {
	
				var i,
				    j,
				    cur,
				    inst,
				    items = [],
				    queries = [],
				    connectWith = this._connectWith();
	
				if (connectWith && connected) {
					for (i = connectWith.length - 1; i >= 0; i--) {
						cur = $(connectWith[i], this.document[0]);
						for (j = cur.length - 1; j >= 0; j--) {
							inst = $.data(cur[j], this.widgetFullName);
							if (inst && inst !== this && !inst.options.disabled) {
								queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
							}
						}
					}
				}
	
				queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
	
				function addItems() {
					items.push(this);
				}
				for (i = queries.length - 1; i >= 0; i--) {
					queries[i][0].each(addItems);
				}
	
				return $(items);
			},
	
			_removeCurrentsFromItems: function _removeCurrentsFromItems() {
	
				var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
	
				this.items = $.grep(this.items, function (item) {
					for (var j = 0; j < list.length; j++) {
						if (list[j] === item.item[0]) {
							return false;
						}
					}
					return true;
				});
			},
	
			_refreshItems: function _refreshItems(event) {
	
				this.items = [];
				this.containers = [this];
	
				var i,
				    j,
				    cur,
				    inst,
				    targetData,
				    _queries,
				    item,
				    queriesLength,
				    items = this.items,
				    queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
				    connectWith = this._connectWith();
	
				if (connectWith && this.ready) {
					//Shouldn't be run the first time through due to massive slow-down
					for (i = connectWith.length - 1; i >= 0; i--) {
						cur = $(connectWith[i], this.document[0]);
						for (j = cur.length - 1; j >= 0; j--) {
							inst = $.data(cur[j], this.widgetFullName);
							if (inst && inst !== this && !inst.options.disabled) {
								queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
								this.containers.push(inst);
							}
						}
					}
				}
	
				for (i = queries.length - 1; i >= 0; i--) {
					targetData = queries[i][1];
					_queries = queries[i][0];
	
					for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
						item = $(_queries[j]);
	
						item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
	
						items.push({
							item: item,
							instance: targetData,
							width: 0, height: 0,
							left: 0, top: 0
						});
					}
				}
			},
	
			refreshPositions: function refreshPositions(fast) {
	
				// Determine whether items are being displayed horizontally
				this.floating = this.items.length ? this.options.axis === "x" || this._isFloating(this.items[0].item) : false;
	
				//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
				if (this.offsetParent && this.helper) {
					this.offset.parent = this._getParentOffset();
				}
	
				var i, item, t, p;
	
				for (i = this.items.length - 1; i >= 0; i--) {
					item = this.items[i];
	
					//We ignore calculating positions of all connected containers when we're not over them
					if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
						continue;
					}
	
					t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
	
					if (!fast) {
						item.width = t.outerWidth();
						item.height = t.outerHeight();
					}
	
					p = t.offset();
					item.left = p.left;
					item.top = p.top;
				}
	
				if (this.options.custom && this.options.custom.refreshContainers) {
					this.options.custom.refreshContainers.call(this);
				} else {
					for (i = this.containers.length - 1; i >= 0; i--) {
						p = this.containers[i].element.offset();
						this.containers[i].containerCache.left = p.left;
						this.containers[i].containerCache.top = p.top;
						this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
						this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
					}
				}
	
				return this;
			},
	
			_createPlaceholder: function _createPlaceholder(that) {
				that = that || this;
				var className,
				    o = that.options;
	
				if (!o.placeholder || o.placeholder.constructor === String) {
					className = o.placeholder;
					o.placeholder = {
						element: function element() {
	
							var nodeName = that.currentItem[0].nodeName.toLowerCase(),
							    element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
	
							if (nodeName === "tbody") {
								that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element));
							} else if (nodeName === "tr") {
								that._createTrPlaceholder(that.currentItem, element);
							} else if (nodeName === "img") {
								element.attr("src", that.currentItem.attr("src"));
							}
	
							if (!className) {
								element.css("visibility", "hidden");
							}
	
							return element;
						},
						update: function update(container, p) {
	
							// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
							// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
							if (className && !o.forcePlaceholderSize) {
								return;
							}
	
							//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
							if (!p.height()) {
								p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
							}
							if (!p.width()) {
								p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
							}
						}
					};
				}
	
				//Create the placeholder
				that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
	
				//Append it after the actual current item
				that.currentItem.after(that.placeholder);
	
				//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
				o.placeholder.update(that, that.placeholder);
			},
	
			_createTrPlaceholder: function _createTrPlaceholder(sourceTr, targetTr) {
				var that = this;
	
				sourceTr.children().each(function () {
					$("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr);
				});
			},
	
			_contactContainers: function _contactContainers(event) {
				var i,
				    j,
				    dist,
				    itemWithLeastDistance,
				    posProperty,
				    sizeProperty,
				    cur,
				    nearBottom,
				    floating,
				    axis,
				    innermostContainer = null,
				    innermostIndex = null;
	
				// get innermost container that intersects with item
				for (i = this.containers.length - 1; i >= 0; i--) {
	
					// never consider a container that's located within the item itself
					if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
						continue;
					}
	
					if (this._intersectsWith(this.containers[i].containerCache)) {
	
						// if we've already found a container and it's more "inner" than this, then continue
						if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
							continue;
						}
	
						innermostContainer = this.containers[i];
						innermostIndex = i;
					} else {
						// container doesn't intersect. trigger "out" event if necessary
						if (this.containers[i].containerCache.over) {
							this.containers[i]._trigger("out", event, this._uiHash(this));
							this.containers[i].containerCache.over = 0;
						}
					}
				}
	
				// if no intersecting containers found, return
				if (!innermostContainer) {
					return;
				}
	
				// move the item into the container if it's not there already
				if (this.containers.length === 1) {
					if (!this.containers[innermostIndex].containerCache.over) {
						this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
						this.containers[innermostIndex].containerCache.over = 1;
					}
				} else {
	
					//When entering a new container, we will find the item with the least distance and append our item near it
					dist = 10000;
					itemWithLeastDistance = null;
					floating = innermostContainer.floating || this._isFloating(this.currentItem);
					posProperty = floating ? "left" : "top";
					sizeProperty = floating ? "width" : "height";
					axis = floating ? "clientX" : "clientY";
	
					for (j = this.items.length - 1; j >= 0; j--) {
						if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
							continue;
						}
						if (this.items[j].item[0] === this.currentItem[0]) {
							continue;
						}
	
						cur = this.items[j].item.offset()[posProperty];
						nearBottom = false;
						if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
							nearBottom = true;
						}
	
						if (Math.abs(event[axis] - cur) < dist) {
							dist = Math.abs(event[axis] - cur);
							itemWithLeastDistance = this.items[j];
							this.direction = nearBottom ? "up" : "down";
						}
					}
	
					//Check if dropOnEmpty is enabled
					if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
						return;
					}
	
					if (this.currentContainer === this.containers[innermostIndex]) {
						if (!this.currentContainer.containerCache.over) {
							this.containers[innermostIndex]._trigger("over", event, this._uiHash());
							this.currentContainer.containerCache.over = 1;
						}
						return;
					}
	
					itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
					this._trigger("change", event, this._uiHash());
					this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
					this.currentContainer = this.containers[innermostIndex];
	
					//Update the placeholder
					this.options.placeholder.update(this.currentContainer, this.placeholder);
	
					this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
					this.containers[innermostIndex].containerCache.over = 1;
				}
			},
	
			_createHelper: function _createHelper(event) {
	
				var o = this.options,
				    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;
	
				//Add the helper to the DOM if that didn't happen already
				if (!helper.parents("body").length) {
					$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
				}
	
				if (helper[0] === this.currentItem[0]) {
					this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
				}
	
				if (!helper[0].style.width || o.forceHelperSize) {
					helper.width(this.currentItem.width());
				}
				if (!helper[0].style.height || o.forceHelperSize) {
					helper.height(this.currentItem.height());
				}
	
				return helper;
			},
	
			_adjustOffsetFromHelper: function _adjustOffsetFromHelper(obj) {
				if (typeof obj === "string") {
					obj = obj.split(" ");
				}
				if ($.isArray(obj)) {
					obj = { left: +obj[0], top: +obj[1] || 0 };
				}
				if ("left" in obj) {
					this.offset.click.left = obj.left + this.margins.left;
				}
				if ("right" in obj) {
					this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
				}
				if ("top" in obj) {
					this.offset.click.top = obj.top + this.margins.top;
				}
				if ("bottom" in obj) {
					this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
				}
			},
	
			_getParentOffset: function _getParentOffset() {
	
				//Get the offsetParent and cache its position
				this.offsetParent = this.helper.offsetParent();
				var po = this.offsetParent.offset();
	
				// This is a special case where we need to modify a offset calculated on start, since the following happened:
				// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
				// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
				//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
				if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
					po.left += this.scrollParent.scrollLeft();
					po.top += this.scrollParent.scrollTop();
				}
	
				// This needs to be actually done for all browsers, since pageX/pageY includes this information
				// with an ugly IE fix
				if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
					po = { top: 0, left: 0 };
				}
	
				return {
					top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
					left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
				};
			},
	
			_getRelativeOffset: function _getRelativeOffset() {
	
				if (this.cssPosition === "relative") {
					var p = this.currentItem.position();
					return {
						top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
						left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
					};
				} else {
					return { top: 0, left: 0 };
				}
			},
	
			_cacheMargins: function _cacheMargins() {
				this.margins = {
					left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
					top: parseInt(this.currentItem.css("marginTop"), 10) || 0
				};
			},
	
			_cacheHelperProportions: function _cacheHelperProportions() {
				this.helperProportions = {
					width: this.helper.outerWidth(),
					height: this.helper.outerHeight()
				};
			},
	
			_setContainment: function _setContainment() {
	
				var ce,
				    co,
				    over,
				    o = this.options;
				if (o.containment === "parent") {
					o.containment = this.helper[0].parentNode;
				}
				if (o.containment === "document" || o.containment === "window") {
					this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
				}
	
				if (!/^(document|window|parent)$/.test(o.containment)) {
					ce = $(o.containment)[0];
					co = $(o.containment).offset();
					over = $(ce).css("overflow") !== "hidden";
	
					this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top];
				}
			},
	
			_convertPositionTo: function _convertPositionTo(d, pos) {
	
				if (!pos) {
					pos = this.position;
				}
				var mod = d === "absolute" ? 1 : -1,
				    scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
				    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
	
				return {
					top: pos.top + // The absolute mouse position
					this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
					(this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
					left: pos.left + // The absolute mouse position
					this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
					(this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
				};
			},
	
			_generatePosition: function _generatePosition(event) {
	
				var top,
				    left,
				    o = this.options,
				    pageX = event.pageX,
				    pageY = event.pageY,
				    scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
				    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
	
				// This is another very weird special case that only happens for relative elements:
				// 1. If the css position is relative
				// 2. and the scroll parent is the document or similar to the offset parent
				// we have to refresh the relative offset during the scroll so there are no jumps
				if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
					this.offset.relative = this._getRelativeOffset();
				}
	
				/*
	    * - Position constraining -
	    * Constrain the position to a mix of grid, containment.
	    */
	
				if (this.originalPosition) {
					//If we are not dragging yet, we won't check for options
	
					if (this.containment) {
						if (event.pageX - this.offset.click.left < this.containment[0]) {
							pageX = this.containment[0] + this.offset.click.left;
						}
						if (event.pageY - this.offset.click.top < this.containment[1]) {
							pageY = this.containment[1] + this.offset.click.top;
						}
						if (event.pageX - this.offset.click.left > this.containment[2]) {
							pageX = this.containment[2] + this.offset.click.left;
						}
						if (event.pageY - this.offset.click.top > this.containment[3]) {
							pageY = this.containment[3] + this.offset.click.top;
						}
					}
	
					if (o.grid) {
						top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
						pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
	
						left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
						pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
					}
				}
	
				return {
					top: pageY - // The absolute mouse position
					this.offset.click.top - // Click offset (relative to the element)
					this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top + ( // The offsetParent's offset without borders (offset + border)
					this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
					left: pageX - // The absolute mouse position
					this.offset.click.left - // Click offset (relative to the element)
					this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left + ( // The offsetParent's offset without borders (offset + border)
					this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
				};
			},
	
			_rearrange: function _rearrange(event, i, a, hardRefresh) {
	
				a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);
	
				//Various things done here to improve the performance:
				// 1. we create a setTimeout, that calls refreshPositions
				// 2. on the instance, we have a counter variable, that get's higher after every append
				// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
				// 4. this lets only the last addition to the timeout stack through
				this.counter = this.counter ? ++this.counter : 1;
				var counter = this.counter;
	
				this._delay(function () {
					if (counter === this.counter) {
						this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
					}
				});
			},
	
			_clear: function _clear(event, noPropagation) {
	
				this.reverting = false;
				// We delay all events that have to be triggered to after the point where the placeholder has been removed and
				// everything else normalized again
				var i,
				    delayedTriggers = [];
	
				// We first have to update the dom position of the actual currentItem
				// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
				if (!this._noFinalSort && this.currentItem.parent().length) {
					this.placeholder.before(this.currentItem);
				}
				this._noFinalSort = null;
	
				if (this.helper[0] === this.currentItem[0]) {
					for (i in this._storedCSS) {
						if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
							this._storedCSS[i] = "";
						}
					}
					this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
				} else {
					this.currentItem.show();
				}
	
				if (this.fromOutside && !noPropagation) {
					delayedTriggers.push(function (event) {
						this._trigger("receive", event, this._uiHash(this.fromOutside));
					});
				}
				if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
					delayedTriggers.push(function (event) {
						this._trigger("update", event, this._uiHash());
					}); //Trigger update callback if the DOM position has changed
				}
	
				// Check if the items Container has Changed and trigger appropriate
				// events.
				if (this !== this.currentContainer) {
					if (!noPropagation) {
						delayedTriggers.push(function (event) {
							this._trigger("remove", event, this._uiHash());
						});
						delayedTriggers.push(function (c) {
							return function (event) {
								c._trigger("receive", event, this._uiHash(this));
							};
						}.call(this, this.currentContainer));
						delayedTriggers.push(function (c) {
							return function (event) {
								c._trigger("update", event, this._uiHash(this));
							};
						}.call(this, this.currentContainer));
					}
				}
	
				//Post events to containers
				function delayEvent(type, instance, container) {
					return function (event) {
						container._trigger(type, event, instance._uiHash(instance));
					};
				}
				for (i = this.containers.length - 1; i >= 0; i--) {
					if (!noPropagation) {
						delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
					}
					if (this.containers[i].containerCache.over) {
						delayedTriggers.push(delayEvent("out", this, this.containers[i]));
						this.containers[i].containerCache.over = 0;
					}
				}
	
				//Do what was originally in plugins
				if (this.storedCursor) {
					this.document.find("body").css("cursor", this.storedCursor);
					this.storedStylesheet.remove();
				}
				if (this._storedOpacity) {
					this.helper.css("opacity", this._storedOpacity);
				}
				if (this._storedZIndex) {
					this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
				}
	
				this.dragging = false;
	
				if (!noPropagation) {
					this._trigger("beforeStop", event, this._uiHash());
				}
	
				//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
	
				if (!this.cancelHelperRemoval) {
					if (this.helper[0] !== this.currentItem[0]) {
						this.helper.remove();
					}
					this.helper = null;
				}
	
				if (!noPropagation) {
					for (i = 0; i < delayedTriggers.length; i++) {
						delayedTriggers[i].call(this, event);
					} //Trigger all delayed events
					this._trigger("stop", event, this._uiHash());
				}
	
				this.fromOutside = false;
				return !this.cancelHelperRemoval;
			},
	
			_trigger: function _trigger() {
				if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
					this.cancel();
				}
			},
	
			_uiHash: function _uiHash(_inst) {
				var inst = _inst || this;
				return {
					helper: inst.helper,
					placeholder: inst.placeholder || $([]),
					position: inst.position,
					originalPosition: inst.originalPosition,
					offset: inst.positionAbs,
					item: inst.currentItem,
					sender: _inst ? _inst.element : null
				};
			}
	
		});
	});

/***/ }),
/* 227 */
/*!***********************************!*\
  !*** ./~/jquery-ui/ui/tooltip.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	/*!
	 * jQuery UI Tooltip 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/tooltip/
	 */
	(function (factory) {
		if (true) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 3), __webpack_require__(/*! ./core */ 19), __webpack_require__(/*! ./widget */ 36), __webpack_require__(/*! ./position */ 225)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory(jQuery);
		}
	})(function ($) {
	
		return $.widget("ui.tooltip", {
			version: "1.11.4",
			options: {
				content: function content() {
					// support: IE<9, Opera in jQuery <1.7
					// .text() can't accept undefined, so coerce to a string
					var title = $(this).attr("title") || "";
					// Escape title, since we're going from an attribute to raw HTML
					return $("<a>").text(title).html();
				},
				hide: true,
				// Disabled elements have inconsistent behavior across browsers (#8661)
				items: "[title]:not([disabled])",
				position: {
					my: "left top+15",
					at: "left bottom",
					collision: "flipfit flip"
				},
				show: true,
				tooltipClass: null,
				track: false,
	
				// callbacks
				close: null,
				open: null
			},
	
			_addDescribedBy: function _addDescribedBy(elem, id) {
				var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
				describedby.push(id);
				elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
			},
	
			_removeDescribedBy: function _removeDescribedBy(elem) {
				var id = elem.data("ui-tooltip-id"),
				    describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
				    index = $.inArray(id, describedby);
	
				if (index !== -1) {
					describedby.splice(index, 1);
				}
	
				elem.removeData("ui-tooltip-id");
				describedby = $.trim(describedby.join(" "));
				if (describedby) {
					elem.attr("aria-describedby", describedby);
				} else {
					elem.removeAttr("aria-describedby");
				}
			},
	
			_create: function _create() {
				this._on({
					mouseover: "open",
					focusin: "open"
				});
	
				// IDs of generated tooltips, needed for destroy
				this.tooltips = {};
	
				// IDs of parent tooltips where we removed the title attribute
				this.parents = {};
	
				if (this.options.disabled) {
					this._disable();
				}
	
				// Append the aria-live region so tooltips announce correctly
				this.liveRegion = $("<div>").attr({
					role: "log",
					"aria-live": "assertive",
					"aria-relevant": "additions"
				}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
			},
	
			_setOption: function _setOption(key, value) {
				var that = this;
	
				if (key === "disabled") {
					this[value ? "_disable" : "_enable"]();
					this.options[key] = value;
					// disable element style changes
					return;
				}
	
				this._super(key, value);
	
				if (key === "content") {
					$.each(this.tooltips, function (id, tooltipData) {
						that._updateContent(tooltipData.element);
					});
				}
			},
	
			_disable: function _disable() {
				var that = this;
	
				// close open tooltips
				$.each(this.tooltips, function (id, tooltipData) {
					var event = $.Event("blur");
					event.target = event.currentTarget = tooltipData.element[0];
					that.close(event, true);
				});
	
				// remove title attributes to prevent native tooltips
				this.element.find(this.options.items).addBack().each(function () {
					var element = $(this);
					if (element.is("[title]")) {
						element.data("ui-tooltip-title", element.attr("title")).removeAttr("title");
					}
				});
			},
	
			_enable: function _enable() {
				// restore title attributes
				this.element.find(this.options.items).addBack().each(function () {
					var element = $(this);
					if (element.data("ui-tooltip-title")) {
						element.attr("title", element.data("ui-tooltip-title"));
					}
				});
			},
	
			open: function open(event) {
				var that = this,
				    target = $(event ? event.target : this.element)
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest(this.options.items);
	
				// No element to show a tooltip for or the tooltip is already open
				if (!target.length || target.data("ui-tooltip-id")) {
					return;
				}
	
				if (target.attr("title")) {
					target.data("ui-tooltip-title", target.attr("title"));
				}
	
				target.data("ui-tooltip-open", true);
	
				// kill parent tooltips, custom or native, for hover
				if (event && event.type === "mouseover") {
					target.parents().each(function () {
						var parent = $(this),
						    blurEvent;
						if (parent.data("ui-tooltip-open")) {
							blurEvent = $.Event("blur");
							blurEvent.target = blurEvent.currentTarget = this;
							that.close(blurEvent, true);
						}
						if (parent.attr("title")) {
							parent.uniqueId();
							that.parents[this.id] = {
								element: this,
								title: parent.attr("title")
							};
							parent.attr("title", "");
						}
					});
				}
	
				this._registerCloseHandlers(event, target);
				this._updateContent(target, event);
			},
	
			_updateContent: function _updateContent(target, event) {
				var content,
				    contentOption = this.options.content,
				    that = this,
				    eventType = event ? event.type : null;
	
				if (typeof contentOption === "string") {
					return this._open(event, target, contentOption);
				}
	
				content = contentOption.call(target[0], function (response) {
	
					// IE may instantly serve a cached response for ajax requests
					// delay this call to _open so the other call to _open runs first
					that._delay(function () {
	
						// Ignore async response if tooltip was closed already
						if (!target.data("ui-tooltip-open")) {
							return;
						}
	
						// jQuery creates a special event for focusin when it doesn't
						// exist natively. To improve performance, the native event
						// object is reused and the type is changed. Therefore, we can't
						// rely on the type being correct after the event finished
						// bubbling, so we set it back to the previous value. (#8740)
						if (event) {
							event.type = eventType;
						}
						this._open(event, target, response);
					});
				});
				if (content) {
					this._open(event, target, content);
				}
			},
	
			_open: function _open(event, target, content) {
				var tooltipData,
				    tooltip,
				    delayedShow,
				    a11yContent,
				    positionOption = $.extend({}, this.options.position);
	
				if (!content) {
					return;
				}
	
				// Content can be updated multiple times. If the tooltip already
				// exists, then just update the content and bail.
				tooltipData = this._find(target);
				if (tooltipData) {
					tooltipData.tooltip.find(".ui-tooltip-content").html(content);
					return;
				}
	
				// if we have a title, clear it to prevent the native tooltip
				// we have to check first to avoid defining a title if none exists
				// (we don't want to cause an element to start matching [title])
				//
				// We use removeAttr only for key events, to allow IE to export the correct
				// accessible attributes. For mouse events, set to empty string to avoid
				// native tooltip showing up (happens only when removing inside mouseover).
				if (target.is("[title]")) {
					if (event && event.type === "mouseover") {
						target.attr("title", "");
					} else {
						target.removeAttr("title");
					}
				}
	
				tooltipData = this._tooltip(target);
				tooltip = tooltipData.tooltip;
				this._addDescribedBy(target, tooltip.attr("id"));
				tooltip.find(".ui-tooltip-content").html(content);
	
				// Support: Voiceover on OS X, JAWS on IE <= 9
				// JAWS announces deletions even when aria-relevant="additions"
				// Voiceover will sometimes re-read the entire log region's contents from the beginning
				this.liveRegion.children().hide();
				if (content.clone) {
					a11yContent = content.clone();
					a11yContent.removeAttr("id").find("[id]").removeAttr("id");
				} else {
					a11yContent = content;
				}
				$("<div>").html(a11yContent).appendTo(this.liveRegion);
	
				function position(event) {
					positionOption.of = event;
					if (tooltip.is(":hidden")) {
						return;
					}
					tooltip.position(positionOption);
				}
				if (this.options.track && event && /^mouse/.test(event.type)) {
					this._on(this.document, {
						mousemove: position
					});
					// trigger once to override element-relative positioning
					position(event);
				} else {
					tooltip.position($.extend({
						of: target
					}, this.options.position));
				}
	
				tooltip.hide();
	
				this._show(tooltip, this.options.show);
				// Handle tracking tooltips that are shown with a delay (#8644). As soon
				// as the tooltip is visible, position the tooltip using the most recent
				// event.
				if (this.options.show && this.options.show.delay) {
					delayedShow = this.delayedShow = setInterval(function () {
						if (tooltip.is(":visible")) {
							position(positionOption.of);
							clearInterval(delayedShow);
						}
					}, $.fx.interval);
				}
	
				this._trigger("open", event, { tooltip: tooltip });
			},
	
			_registerCloseHandlers: function _registerCloseHandlers(event, target) {
				var events = {
					keyup: function keyup(event) {
						if (event.keyCode === $.ui.keyCode.ESCAPE) {
							var fakeEvent = $.Event(event);
							fakeEvent.currentTarget = target[0];
							this.close(fakeEvent, true);
						}
					}
				};
	
				// Only bind remove handler for delegated targets. Non-delegated
				// tooltips will handle this in destroy.
				if (target[0] !== this.element[0]) {
					events.remove = function () {
						this._removeTooltip(this._find(target).tooltip);
					};
				}
	
				if (!event || event.type === "mouseover") {
					events.mouseleave = "close";
				}
				if (!event || event.type === "focusin") {
					events.focusout = "close";
				}
				this._on(true, target, events);
			},
	
			close: function close(event) {
				var tooltip,
				    that = this,
				    target = $(event ? event.currentTarget : this.element),
				    tooltipData = this._find(target);
	
				// The tooltip may already be closed
				if (!tooltipData) {
	
					// We set ui-tooltip-open immediately upon open (in open()), but only set the
					// additional data once there's actually content to show (in _open()). So even if the
					// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
					// the period between open() and _open().
					target.removeData("ui-tooltip-open");
					return;
				}
	
				tooltip = tooltipData.tooltip;
	
				// disabling closes the tooltip, so we need to track when we're closing
				// to avoid an infinite loop in case the tooltip becomes disabled on close
				if (tooltipData.closing) {
					return;
				}
	
				// Clear the interval for delayed tracking tooltips
				clearInterval(this.delayedShow);
	
				// only set title if we had one before (see comment in _open())
				// If the title attribute has changed since open(), don't restore
				if (target.data("ui-tooltip-title") && !target.attr("title")) {
					target.attr("title", target.data("ui-tooltip-title"));
				}
	
				this._removeDescribedBy(target);
	
				tooltipData.hiding = true;
				tooltip.stop(true);
				this._hide(tooltip, this.options.hide, function () {
					that._removeTooltip($(this));
				});
	
				target.removeData("ui-tooltip-open");
				this._off(target, "mouseleave focusout keyup");
	
				// Remove 'remove' binding only on delegated targets
				if (target[0] !== this.element[0]) {
					this._off(target, "remove");
				}
				this._off(this.document, "mousemove");
	
				if (event && event.type === "mouseleave") {
					$.each(this.parents, function (id, parent) {
						$(parent.element).attr("title", parent.title);
						delete that.parents[id];
					});
				}
	
				tooltipData.closing = true;
				this._trigger("close", event, { tooltip: tooltip });
				if (!tooltipData.hiding) {
					tooltipData.closing = false;
				}
			},
	
			_tooltip: function _tooltip(element) {
				var tooltip = $("<div>").attr("role", "tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || "")),
				    id = tooltip.uniqueId().attr("id");
	
				$("<div>").addClass("ui-tooltip-content").appendTo(tooltip);
	
				tooltip.appendTo(this.document[0].body);
	
				return this.tooltips[id] = {
					element: element,
					tooltip: tooltip
				};
			},
	
			_find: function _find(target) {
				var id = target.data("ui-tooltip-id");
				return id ? this.tooltips[id] : null;
			},
	
			_removeTooltip: function _removeTooltip(tooltip) {
				tooltip.remove();
				delete this.tooltips[tooltip.attr("id")];
			},
	
			_destroy: function _destroy() {
				var that = this;
	
				// close open tooltips
				$.each(this.tooltips, function (id, tooltipData) {
					// Delegate to close method to handle common cleanup
					var event = $.Event("blur"),
					    element = tooltipData.element;
					event.target = event.currentTarget = element[0];
					that.close(event, true);
	
					// Remove immediately; destroying an open tooltip doesn't use the
					// hide animation
					$("#" + id).remove();
	
					// Restore the title
					if (element.data("ui-tooltip-title")) {
						// If the title attribute has changed since open(), don't restore
						if (!element.attr("title")) {
							element.attr("title", element.data("ui-tooltip-title"));
						}
						element.removeData("ui-tooltip-title");
					}
				});
				this.liveRegion.remove();
			}
		});
	});

/***/ }),
/* 228 */
/*!***********************************!*\
  !*** ./~/lodash.isequal/index.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Detect free variable `exports`. */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = function () {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}();
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];
	
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}
	
	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;
	
	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}
	
	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function (value) {
	    return func(value);
	  };
	}
	
	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}
	
	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	
	  map.forEach(function (value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}
	
	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function (value) {
	    result[++index] = value;
	  });
	  return result;
	}
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = function () {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? 'Symbol(src)_1.' + uid : '';
	}();
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    _Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}
	
	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
	  return this;
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash(),
	    'map': new (Map || ListCache)(),
	    'string': new Hash()
	  };
	}
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;
	
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;
	
	  this.__data__ = new MapCache();
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}
	
	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}
	
	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}
	
	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache();
	  this.size = 0;
	}
	
	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);
	
	  this.size = data.size;
	  return result;
	}
	
	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
	    // Safari 9 has enumerable `arguments.length` in strict mode.
	    key == 'length' ||
	    // Node.js 0.10 has enumerable non-index properties on buffers.
	    isBuff && (key == 'offset' || key == 'parent') ||
	    // PhantomJS 2 has enumerable non-index properties on typed arrays.
	    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
	    // Skip index properties.
	    isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);
	
	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;
	
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack());
	    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;
	
	      stack || (stack = new Stack());
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack());
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
	
	  stack.set(array, other);
	  stack.set(other, array);
	
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];
	
	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function (othValue, othIndex) {
	        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	          return seen.push(othIndex);
	        }
	      })) {
	        result = false;
	        break;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	
	    case arrayBufferTag:
	      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;
	
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == other + '';
	
	    case mapTag:
	      var convert = mapToArray;
	
	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);
	
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;
	
	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;
	
	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];
	
	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function (symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;
	
	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
	  getTag = function getTag(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString:
	          return dataViewTag;
	        case mapCtorString:
	          return mapTag;
	        case promiseCtorString:
	          return promiseTag;
	        case setCtorString:
	          return setTag;
	        case weakMapCtorString:
	          return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	
	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
	}
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && maskSrcKey in func;
	}
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
	
	  return value === proto;
	}
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return func + '';
	    } catch (e) {}
	  }
	  return '';
	}
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || value !== value && other !== other;
	}
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function () {
	  return arguments;
	}()) ? baseIsArguments : function (value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	};
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	  return value != null && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}
	
	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	module.exports = isEqual;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./../webpack/buildin/module.js */ 38)(module)))

/***/ }),
/* 229 */,
/* 230 */
/*!********************************************!*\
  !*** ./~/material-design-lite/material.js ***!
  \********************************************/
/***/ (function(module, exports) {

	;(function() {
	"use strict";
	
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * A component handler interface using the revealing module design pattern.
	 * More details on this design pattern here:
	 * https://github.com/jasonmayes/mdl-component-design-pattern
	 *
	 * @author Jason Mayes.
	 */
	/* exported componentHandler */
	
	// Pre-defining the componentHandler interface, for closure documentation and
	// static verification.
	var componentHandler = {
	  /**
	   * Searches existing DOM for elements of our component type and upgrades them
	   * if they have not already been upgraded.
	   *
	   * @param {string=} optJsClass the programatic name of the element class we
	   * need to create a new instance of.
	   * @param {string=} optCssClass the name of the CSS class elements of this
	   * type will have.
	   */
	  upgradeDom: function(optJsClass, optCssClass) {},
	  /**
	   * Upgrades a specific element rather than all in the DOM.
	   *
	   * @param {!Element} element The element we wish to upgrade.
	   * @param {string=} optJsClass Optional name of the class we want to upgrade
	   * the element to.
	   */
	  upgradeElement: function(element, optJsClass) {},
	  /**
	   * Upgrades a specific list of elements rather than all in the DOM.
	   *
	   * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements
	   * The elements we wish to upgrade.
	   */
	  upgradeElements: function(elements) {},
	  /**
	   * Upgrades all registered components found in the current DOM. This is
	   * automatically called on window load.
	   */
	  upgradeAllRegistered: function() {},
	  /**
	   * Allows user to be alerted to any upgrades that are performed for a given
	   * component type
	   *
	   * @param {string} jsClass The class name of the MDL component we wish
	   * to hook into for any upgrades performed.
	   * @param {function(!HTMLElement)} callback The function to call upon an
	   * upgrade. This function should expect 1 parameter - the HTMLElement which
	   * got upgraded.
	   */
	  registerUpgradedCallback: function(jsClass, callback) {},
	  /**
	   * Registers a class for future use and attempts to upgrade existing DOM.
	   *
	   * @param {componentHandler.ComponentConfigPublic} config the registration configuration
	   */
	  register: function(config) {},
	  /**
	   * Downgrade either a given node, an array of nodes, or a NodeList.
	   *
	   * @param {!Node|!Array<!Node>|!NodeList} nodes
	   */
	  downgradeElements: function(nodes) {}
	};
	
	componentHandler = (function() {
	  'use strict';
	
	  /** @type {!Array<componentHandler.ComponentConfig>} */
	  var registeredComponents_ = [];
	
	  /** @type {!Array<componentHandler.Component>} */
	  var createdComponents_ = [];
	
	  var componentConfigProperty_ = 'mdlComponentConfigInternal_';
	
	  /**
	   * Searches registered components for a class we are interested in using.
	   * Optionally replaces a match with passed object if specified.
	   *
	   * @param {string} name The name of a class we want to use.
	   * @param {componentHandler.ComponentConfig=} optReplace Optional object to replace match with.
	   * @return {!Object|boolean}
	   * @private
	   */
	  function findRegisteredClass_(name, optReplace) {
	    for (var i = 0; i < registeredComponents_.length; i++) {
	      if (registeredComponents_[i].className === name) {
	        if (typeof optReplace !== 'undefined') {
	          registeredComponents_[i] = optReplace;
	        }
	        return registeredComponents_[i];
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Returns an array of the classNames of the upgraded classes on the element.
	   *
	   * @param {!Element} element The element to fetch data from.
	   * @return {!Array<string>}
	   * @private
	   */
	  function getUpgradedListOfElement_(element) {
	    var dataUpgraded = element.getAttribute('data-upgraded');
	    // Use `['']` as default value to conform the `,name,name...` style.
	    return dataUpgraded === null ? [''] : dataUpgraded.split(',');
	  }
	
	  /**
	   * Returns true if the given element has already been upgraded for the given
	   * class.
	   *
	   * @param {!Element} element The element we want to check.
	   * @param {string} jsClass The class to check for.
	   * @returns {boolean}
	   * @private
	   */
	  function isElementUpgraded_(element, jsClass) {
	    var upgradedList = getUpgradedListOfElement_(element);
	    return upgradedList.indexOf(jsClass) !== -1;
	  }
	
	  /**
	   * Create an event object.
	   *
	   * @param {string} eventType The type name of the event.
	   * @param {boolean} bubbles Whether the event should bubble up the DOM.
	   * @param {boolean} cancelable Whether the event can be canceled.
	   * @returns {!Event}
	   */
	  function createEvent_(eventType, bubbles, cancelable) {
	    if ('CustomEvent' in window && typeof window.CustomEvent === 'function') {
	      return new CustomEvent(eventType, {
	        bubbles: bubbles,
	        cancelable: cancelable
	      });
	    } else {
	      var ev = document.createEvent('Events');
	      ev.initEvent(eventType, bubbles, cancelable);
	      return ev;
	    }
	  }
	
	  /**
	   * Searches existing DOM for elements of our component type and upgrades them
	   * if they have not already been upgraded.
	   *
	   * @param {string=} optJsClass the programatic name of the element class we
	   * need to create a new instance of.
	   * @param {string=} optCssClass the name of the CSS class elements of this
	   * type will have.
	   */
	  function upgradeDomInternal(optJsClass, optCssClass) {
	    if (typeof optJsClass === 'undefined' &&
	        typeof optCssClass === 'undefined') {
	      for (var i = 0; i < registeredComponents_.length; i++) {
	        upgradeDomInternal(registeredComponents_[i].className,
	            registeredComponents_[i].cssClass);
	      }
	    } else {
	      var jsClass = /** @type {string} */ (optJsClass);
	      if (typeof optCssClass === 'undefined') {
	        var registeredClass = findRegisteredClass_(jsClass);
	        if (registeredClass) {
	          optCssClass = registeredClass.cssClass;
	        }
	      }
	
	      var elements = document.querySelectorAll('.' + optCssClass);
	      for (var n = 0; n < elements.length; n++) {
	        upgradeElementInternal(elements[n], jsClass);
	      }
	    }
	  }
	
	  /**
	   * Upgrades a specific element rather than all in the DOM.
	   *
	   * @param {!Element} element The element we wish to upgrade.
	   * @param {string=} optJsClass Optional name of the class we want to upgrade
	   * the element to.
	   */
	  function upgradeElementInternal(element, optJsClass) {
	    // Verify argument type.
	    if (!(typeof element === 'object' && element instanceof Element)) {
	      throw new Error('Invalid argument provided to upgrade MDL element.');
	    }
	    // Allow upgrade to be canceled by canceling emitted event.
	    var upgradingEv = createEvent_('mdl-componentupgrading', true, true);
	    element.dispatchEvent(upgradingEv);
	    if (upgradingEv.defaultPrevented) {
	      return;
	    }
	
	    var upgradedList = getUpgradedListOfElement_(element);
	    var classesToUpgrade = [];
	    // If jsClass is not provided scan the registered components to find the
	    // ones matching the element's CSS classList.
	    if (!optJsClass) {
	      var classList = element.classList;
	      registeredComponents_.forEach(function(component) {
	        // Match CSS & Not to be upgraded & Not upgraded.
	        if (classList.contains(component.cssClass) &&
	            classesToUpgrade.indexOf(component) === -1 &&
	            !isElementUpgraded_(element, component.className)) {
	          classesToUpgrade.push(component);
	        }
	      });
	    } else if (!isElementUpgraded_(element, optJsClass)) {
	      classesToUpgrade.push(findRegisteredClass_(optJsClass));
	    }
	
	    // Upgrade the element for each classes.
	    for (var i = 0, n = classesToUpgrade.length, registeredClass; i < n; i++) {
	      registeredClass = classesToUpgrade[i];
	      if (registeredClass) {
	        // Mark element as upgraded.
	        upgradedList.push(registeredClass.className);
	        element.setAttribute('data-upgraded', upgradedList.join(','));
	        var instance = new registeredClass.classConstructor(element);
	        instance[componentConfigProperty_] = registeredClass;
	        createdComponents_.push(instance);
	        // Call any callbacks the user has registered with this component type.
	        for (var j = 0, m = registeredClass.callbacks.length; j < m; j++) {
	          registeredClass.callbacks[j](element);
	        }
	
	        if (registeredClass.widget) {
	          // Assign per element instance for control over API
	          element[registeredClass.className] = instance;
	        }
	      } else {
	        throw new Error(
	          'Unable to find a registered component for the given class.');
	      }
	
	      var upgradedEv = createEvent_('mdl-componentupgraded', true, false);
	      element.dispatchEvent(upgradedEv);
	    }
	  }
	
	  /**
	   * Upgrades a specific list of elements rather than all in the DOM.
	   *
	   * @param {!Element|!Array<!Element>|!NodeList|!HTMLCollection} elements
	   * The elements we wish to upgrade.
	   */
	  function upgradeElementsInternal(elements) {
	    if (!Array.isArray(elements)) {
	      if (elements instanceof Element) {
	        elements = [elements];
	      } else {
	        elements = Array.prototype.slice.call(elements);
	      }
	    }
	    for (var i = 0, n = elements.length, element; i < n; i++) {
	      element = elements[i];
	      if (element instanceof HTMLElement) {
	        upgradeElementInternal(element);
	        if (element.children.length > 0) {
	          upgradeElementsInternal(element.children);
	        }
	      }
	    }
	  }
	
	  /**
	   * Registers a class for future use and attempts to upgrade existing DOM.
	   *
	   * @param {componentHandler.ComponentConfigPublic} config
	   */
	  function registerInternal(config) {
	    // In order to support both Closure-compiled and uncompiled code accessing
	    // this method, we need to allow for both the dot and array syntax for
	    // property access. You'll therefore see the `foo.bar || foo['bar']`
	    // pattern repeated across this method.
	    var widgetMissing = (typeof config.widget === 'undefined' &&
	        typeof config['widget'] === 'undefined');
	    var widget = true;
	
	    if (!widgetMissing) {
	      widget = config.widget || config['widget'];
	    }
	
	    var newConfig = /** @type {componentHandler.ComponentConfig} */ ({
	      classConstructor: config.constructor || config['constructor'],
	      className: config.classAsString || config['classAsString'],
	      cssClass: config.cssClass || config['cssClass'],
	      widget: widget,
	      callbacks: []
	    });
	
	    registeredComponents_.forEach(function(item) {
	      if (item.cssClass === newConfig.cssClass) {
	        throw new Error('The provided cssClass has already been registered: ' + item.cssClass);
	      }
	      if (item.className === newConfig.className) {
	        throw new Error('The provided className has already been registered');
	      }
	    });
	
	    if (config.constructor.prototype
	        .hasOwnProperty(componentConfigProperty_)) {
	      throw new Error(
	          'MDL component classes must not have ' + componentConfigProperty_ +
	          ' defined as a property.');
	    }
	
	    var found = findRegisteredClass_(config.classAsString, newConfig);
	
	    if (!found) {
	      registeredComponents_.push(newConfig);
	    }
	  }
	
	  /**
	   * Allows user to be alerted to any upgrades that are performed for a given
	   * component type
	   *
	   * @param {string} jsClass The class name of the MDL component we wish
	   * to hook into for any upgrades performed.
	   * @param {function(!HTMLElement)} callback The function to call upon an
	   * upgrade. This function should expect 1 parameter - the HTMLElement which
	   * got upgraded.
	   */
	  function registerUpgradedCallbackInternal(jsClass, callback) {
	    var regClass = findRegisteredClass_(jsClass);
	    if (regClass) {
	      regClass.callbacks.push(callback);
	    }
	  }
	
	  /**
	   * Upgrades all registered components found in the current DOM. This is
	   * automatically called on window load.
	   */
	  function upgradeAllRegisteredInternal() {
	    for (var n = 0; n < registeredComponents_.length; n++) {
	      upgradeDomInternal(registeredComponents_[n].className);
	    }
	  }
	
	  /**
	   * Check the component for the downgrade method.
	   * Execute if found.
	   * Remove component from createdComponents list.
	   *
	   * @param {?componentHandler.Component} component
	   */
	  function deconstructComponentInternal(component) {
	    if (component) {
	      var componentIndex = createdComponents_.indexOf(component);
	      createdComponents_.splice(componentIndex, 1);
	
	      var upgrades = component.element_.getAttribute('data-upgraded').split(',');
	      var componentPlace = upgrades.indexOf(component[componentConfigProperty_].classAsString);
	      upgrades.splice(componentPlace, 1);
	      component.element_.setAttribute('data-upgraded', upgrades.join(','));
	
	      var ev = createEvent_('mdl-componentdowngraded', true, false);
	      component.element_.dispatchEvent(ev);
	    }
	  }
	
	  /**
	   * Downgrade either a given node, an array of nodes, or a NodeList.
	   *
	   * @param {!Node|!Array<!Node>|!NodeList} nodes
	   */
	  function downgradeNodesInternal(nodes) {
	    /**
	     * Auxiliary function to downgrade a single node.
	     * @param  {!Node} node the node to be downgraded
	     */
	    var downgradeNode = function(node) {
	      createdComponents_.filter(function(item) {
	        return item.element_ === node;
	      }).forEach(deconstructComponentInternal);
	    };
	    if (nodes instanceof Array || nodes instanceof NodeList) {
	      for (var n = 0; n < nodes.length; n++) {
	        downgradeNode(nodes[n]);
	      }
	    } else if (nodes instanceof Node) {
	      downgradeNode(nodes);
	    } else {
	      throw new Error('Invalid argument provided to downgrade MDL nodes.');
	    }
	  }
	
	  // Now return the functions that should be made public with their publicly
	  // facing names...
	  return {
	    upgradeDom: upgradeDomInternal,
	    upgradeElement: upgradeElementInternal,
	    upgradeElements: upgradeElementsInternal,
	    upgradeAllRegistered: upgradeAllRegisteredInternal,
	    registerUpgradedCallback: registerUpgradedCallbackInternal,
	    register: registerInternal,
	    downgradeElements: downgradeNodesInternal
	  };
	})();
	
	/**
	 * Describes the type of a registered component type managed by
	 * componentHandler. Provided for benefit of the Closure compiler.
	 *
	 * @typedef {{
	 *   constructor: Function,
	 *   classAsString: string,
	 *   cssClass: string,
	 *   widget: (string|boolean|undefined)
	 * }}
	 */
	componentHandler.ComponentConfigPublic;  // jshint ignore:line
	
	/**
	 * Describes the type of a registered component type managed by
	 * componentHandler. Provided for benefit of the Closure compiler.
	 *
	 * @typedef {{
	 *   constructor: !Function,
	 *   className: string,
	 *   cssClass: string,
	 *   widget: (string|boolean),
	 *   callbacks: !Array<function(!HTMLElement)>
	 * }}
	 */
	componentHandler.ComponentConfig;  // jshint ignore:line
	
	/**
	 * Created component (i.e., upgraded element) type as managed by
	 * componentHandler. Provided for benefit of the Closure compiler.
	 *
	 * @typedef {{
	 *   element_: !HTMLElement,
	 *   className: string,
	 *   classAsString: string,
	 *   cssClass: string,
	 *   widget: string
	 * }}
	 */
	componentHandler.Component;  // jshint ignore:line
	
	// Export all symbols, for the benefit of Closure compiler.
	// No effect on uncompiled code.
	componentHandler['upgradeDom'] = componentHandler.upgradeDom;
	componentHandler['upgradeElement'] = componentHandler.upgradeElement;
	componentHandler['upgradeElements'] = componentHandler.upgradeElements;
	componentHandler['upgradeAllRegistered'] =
	    componentHandler.upgradeAllRegistered;
	componentHandler['registerUpgradedCallback'] =
	    componentHandler.registerUpgradedCallback;
	componentHandler['register'] = componentHandler.register;
	componentHandler['downgradeElements'] = componentHandler.downgradeElements;
	window.componentHandler = componentHandler;
	window['componentHandler'] = componentHandler;
	
	window.addEventListener('load', function() {
	  'use strict';
	
	  /**
	   * Performs a "Cutting the mustard" test. If the browser supports the features
	   * tested, adds a mdl-js class to the <html> element. It then upgrades all MDL
	   * components requiring JavaScript.
	   */
	  if ('classList' in document.createElement('div') &&
	      'querySelector' in document &&
	      'addEventListener' in window && Array.prototype.forEach) {
	    document.documentElement.classList.add('mdl-js');
	    componentHandler.upgradeAllRegistered();
	  } else {
	    /**
	     * Dummy function to avoid JS errors.
	     */
	    componentHandler.upgradeElement = function() {};
	    /**
	     * Dummy function to avoid JS errors.
	     */
	    componentHandler.register = function() {};
	  }
	});
	
	// Source: https://github.com/darius/requestAnimationFrame/blob/master/requestAnimationFrame.js
	// Adapted from https://gist.github.com/paulirish/1579671 which derived from
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
	// requestAnimationFrame polyfill by Erik Mller.
	// Fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavi, Darius Bacon
	// MIT license
	if (!Date.now) {
	    /**
	     * Date.now polyfill.
	     * @return {number} the current Date
	     */
	    Date.now = function () {
	        return new Date().getTime();
	    };
	    Date['now'] = Date.now;
	}
	var vendors = [
	    'webkit',
	    'moz'
	];
	for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
	    var vp = vendors[i];
	    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
	    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
	    window['requestAnimationFrame'] = window.requestAnimationFrame;
	    window['cancelAnimationFrame'] = window.cancelAnimationFrame;
	}
	if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
	    var lastTime = 0;
	    /**
	     * requestAnimationFrame polyfill.
	     * @param  {!Function} callback the callback function.
	     */
	    window.requestAnimationFrame = function (callback) {
	        var now = Date.now();
	        var nextTime = Math.max(lastTime + 16, now);
	        return setTimeout(function () {
	            callback(lastTime = nextTime);
	        }, nextTime - now);
	    };
	    window.cancelAnimationFrame = clearTimeout;
	    window['requestAnimationFrame'] = window.requestAnimationFrame;
	    window['cancelAnimationFrame'] = window.cancelAnimationFrame;
	}
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Button MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialButton = function MaterialButton(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialButton'] = MaterialButton;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialButton.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialButton.prototype.CssClasses_ = {
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_CONTAINER: 'mdl-button__ripple-container',
	    RIPPLE: 'mdl-ripple'
	};
	/**
	   * Handle blur of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialButton.prototype.blurHandler_ = function (event) {
	    if (event) {
	        this.element_.blur();
	    }
	};
	// Public methods.
	/**
	   * Disable button.
	   *
	   * @public
	   */
	MaterialButton.prototype.disable = function () {
	    this.element_.disabled = true;
	};
	MaterialButton.prototype['disable'] = MaterialButton.prototype.disable;
	/**
	   * Enable button.
	   *
	   * @public
	   */
	MaterialButton.prototype.enable = function () {
	    this.element_.disabled = false;
	};
	MaterialButton.prototype['enable'] = MaterialButton.prototype.enable;
	/**
	   * Initialize element.
	   */
	MaterialButton.prototype.init = function () {
	    if (this.element_) {
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            var rippleContainer = document.createElement('span');
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleElement_ = document.createElement('span');
	            this.rippleElement_.classList.add(this.CssClasses_.RIPPLE);
	            rippleContainer.appendChild(this.rippleElement_);
	            this.boundRippleBlurHandler = this.blurHandler_.bind(this);
	            this.rippleElement_.addEventListener('mouseup', this.boundRippleBlurHandler);
	            this.element_.appendChild(rippleContainer);
	        }
	        this.boundButtonBlurHandler = this.blurHandler_.bind(this);
	        this.element_.addEventListener('mouseup', this.boundButtonBlurHandler);
	        this.element_.addEventListener('mouseleave', this.boundButtonBlurHandler);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialButton,
	    classAsString: 'MaterialButton',
	    cssClass: 'mdl-js-button',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Checkbox MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialCheckbox = function MaterialCheckbox(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialCheckbox'] = MaterialCheckbox;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialCheckbox.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialCheckbox.prototype.CssClasses_ = {
	    INPUT: 'mdl-checkbox__input',
	    BOX_OUTLINE: 'mdl-checkbox__box-outline',
	    FOCUS_HELPER: 'mdl-checkbox__focus-helper',
	    TICK_OUTLINE: 'mdl-checkbox__tick-outline',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-checkbox__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked',
	    IS_UPGRADED: 'is-upgraded'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onChange_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialCheckbox.prototype.onMouseUp_ = function (event) {
	    this.blur_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialCheckbox.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialCheckbox.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.inputElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the inputs toggle state and update display.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.checkToggleState = function () {
	    if (this.inputElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialCheckbox.prototype['checkToggleState'] = MaterialCheckbox.prototype.checkToggleState;
	/**
	   * Check the inputs disabled state and update display.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.checkDisabled = function () {
	    if (this.inputElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialCheckbox.prototype['checkDisabled'] = MaterialCheckbox.prototype.checkDisabled;
	/**
	   * Disable checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.disable = function () {
	    this.inputElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['disable'] = MaterialCheckbox.prototype.disable;
	/**
	   * Enable checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.enable = function () {
	    this.inputElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['enable'] = MaterialCheckbox.prototype.enable;
	/**
	   * Check checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.check = function () {
	    this.inputElement_.checked = true;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['check'] = MaterialCheckbox.prototype.check;
	/**
	   * Uncheck checkbox.
	   *
	   * @public
	   */
	MaterialCheckbox.prototype.uncheck = function () {
	    this.inputElement_.checked = false;
	    this.updateClasses_();
	};
	MaterialCheckbox.prototype['uncheck'] = MaterialCheckbox.prototype.uncheck;
	/**
	   * Initialize element.
	   */
	MaterialCheckbox.prototype.init = function () {
	    if (this.element_) {
	        this.inputElement_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        var boxOutline = document.createElement('span');
	        boxOutline.classList.add(this.CssClasses_.BOX_OUTLINE);
	        var tickContainer = document.createElement('span');
	        tickContainer.classList.add(this.CssClasses_.FOCUS_HELPER);
	        var tickOutline = document.createElement('span');
	        tickOutline.classList.add(this.CssClasses_.TICK_OUTLINE);
	        boxOutline.appendChild(tickOutline);
	        this.element_.appendChild(tickContainer);
	        this.element_.appendChild(boxOutline);
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            this.rippleContainerElement_ = document.createElement('span');
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            this.boundRippleMouseUp = this.onMouseUp_.bind(this);
	            this.rippleContainerElement_.addEventListener('mouseup', this.boundRippleMouseUp);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            this.rippleContainerElement_.appendChild(ripple);
	            this.element_.appendChild(this.rippleContainerElement_);
	        }
	        this.boundInputOnChange = this.onChange_.bind(this);
	        this.boundInputOnFocus = this.onFocus_.bind(this);
	        this.boundInputOnBlur = this.onBlur_.bind(this);
	        this.boundElementMouseUp = this.onMouseUp_.bind(this);
	        this.inputElement_.addEventListener('change', this.boundInputOnChange);
	        this.inputElement_.addEventListener('focus', this.boundInputOnFocus);
	        this.inputElement_.addEventListener('blur', this.boundInputOnBlur);
	        this.element_.addEventListener('mouseup', this.boundElementMouseUp);
	        this.updateClasses_();
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialCheckbox,
	    classAsString: 'MaterialCheckbox',
	    cssClass: 'mdl-js-checkbox',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for icon toggle MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialIconToggle = function MaterialIconToggle(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialIconToggle'] = MaterialIconToggle;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialIconToggle.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialIconToggle.prototype.CssClasses_ = {
	    INPUT: 'mdl-icon-toggle__input',
	    JS_RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-icon-toggle__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onChange_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialIconToggle.prototype.onMouseUp_ = function (event) {
	    this.blur_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialIconToggle.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialIconToggle.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.inputElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the inputs toggle state and update display.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.checkToggleState = function () {
	    if (this.inputElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialIconToggle.prototype['checkToggleState'] = MaterialIconToggle.prototype.checkToggleState;
	/**
	   * Check the inputs disabled state and update display.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.checkDisabled = function () {
	    if (this.inputElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialIconToggle.prototype['checkDisabled'] = MaterialIconToggle.prototype.checkDisabled;
	/**
	   * Disable icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.disable = function () {
	    this.inputElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['disable'] = MaterialIconToggle.prototype.disable;
	/**
	   * Enable icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.enable = function () {
	    this.inputElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['enable'] = MaterialIconToggle.prototype.enable;
	/**
	   * Check icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.check = function () {
	    this.inputElement_.checked = true;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['check'] = MaterialIconToggle.prototype.check;
	/**
	   * Uncheck icon toggle.
	   *
	   * @public
	   */
	MaterialIconToggle.prototype.uncheck = function () {
	    this.inputElement_.checked = false;
	    this.updateClasses_();
	};
	MaterialIconToggle.prototype['uncheck'] = MaterialIconToggle.prototype.uncheck;
	/**
	   * Initialize element.
	   */
	MaterialIconToggle.prototype.init = function () {
	    if (this.element_) {
	        this.inputElement_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        if (this.element_.classList.contains(this.CssClasses_.JS_RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            this.rippleContainerElement_ = document.createElement('span');
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.JS_RIPPLE_EFFECT);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            this.boundRippleMouseUp = this.onMouseUp_.bind(this);
	            this.rippleContainerElement_.addEventListener('mouseup', this.boundRippleMouseUp);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            this.rippleContainerElement_.appendChild(ripple);
	            this.element_.appendChild(this.rippleContainerElement_);
	        }
	        this.boundInputOnChange = this.onChange_.bind(this);
	        this.boundInputOnFocus = this.onFocus_.bind(this);
	        this.boundInputOnBlur = this.onBlur_.bind(this);
	        this.boundElementOnMouseUp = this.onMouseUp_.bind(this);
	        this.inputElement_.addEventListener('change', this.boundInputOnChange);
	        this.inputElement_.addEventListener('focus', this.boundInputOnFocus);
	        this.inputElement_.addEventListener('blur', this.boundInputOnBlur);
	        this.element_.addEventListener('mouseup', this.boundElementOnMouseUp);
	        this.updateClasses_();
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialIconToggle,
	    classAsString: 'MaterialIconToggle',
	    cssClass: 'mdl-js-icon-toggle',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for dropdown MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialMenu = function MaterialMenu(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialMenu'] = MaterialMenu;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialMenu.prototype.Constant_ = {
	    // Total duration of the menu animation.
	    TRANSITION_DURATION_SECONDS: 0.3,
	    // The fraction of the total duration we want to use for menu item animations.
	    TRANSITION_DURATION_FRACTION: 0.8,
	    // How long the menu stays open after choosing an option (so the user can see
	    // the ripple).
	    CLOSE_TIMEOUT: 150
	};
	/**
	   * Keycodes, for code readability.
	   *
	   * @enum {number}
	   * @private
	   */
	MaterialMenu.prototype.Keycodes_ = {
	    ENTER: 13,
	    ESCAPE: 27,
	    SPACE: 32,
	    UP_ARROW: 38,
	    DOWN_ARROW: 40
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialMenu.prototype.CssClasses_ = {
	    CONTAINER: 'mdl-menu__container',
	    OUTLINE: 'mdl-menu__outline',
	    ITEM: 'mdl-menu__item',
	    ITEM_RIPPLE_CONTAINER: 'mdl-menu__item-ripple-container',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE: 'mdl-ripple',
	    // Statuses
	    IS_UPGRADED: 'is-upgraded',
	    IS_VISIBLE: 'is-visible',
	    IS_ANIMATING: 'is-animating',
	    // Alignment options
	    BOTTOM_LEFT: 'mdl-menu--bottom-left',
	    // This is the default.
	    BOTTOM_RIGHT: 'mdl-menu--bottom-right',
	    TOP_LEFT: 'mdl-menu--top-left',
	    TOP_RIGHT: 'mdl-menu--top-right',
	    UNALIGNED: 'mdl-menu--unaligned'
	};
	/**
	   * Initialize element.
	   */
	MaterialMenu.prototype.init = function () {
	    if (this.element_) {
	        // Create container for the menu.
	        var container = document.createElement('div');
	        container.classList.add(this.CssClasses_.CONTAINER);
	        this.element_.parentElement.insertBefore(container, this.element_);
	        this.element_.parentElement.removeChild(this.element_);
	        container.appendChild(this.element_);
	        this.container_ = container;
	        // Create outline for the menu (shadow and background).
	        var outline = document.createElement('div');
	        outline.classList.add(this.CssClasses_.OUTLINE);
	        this.outline_ = outline;
	        container.insertBefore(outline, this.element_);
	        // Find the "for" element and bind events to it.
	        var forElId = this.element_.getAttribute('for') || this.element_.getAttribute('data-mdl-for');
	        var forEl = null;
	        if (forElId) {
	            forEl = document.getElementById(forElId);
	            if (forEl) {
	                this.forElement_ = forEl;
	                forEl.addEventListener('click', this.handleForClick_.bind(this));
	                forEl.addEventListener('keydown', this.handleForKeyboardEvent_.bind(this));
	            }
	        }
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM);
	        this.boundItemKeydown_ = this.handleItemKeyboardEvent_.bind(this);
	        this.boundItemClick_ = this.handleItemClick_.bind(this);
	        for (var i = 0; i < items.length; i++) {
	            // Add a listener to each menu item.
	            items[i].addEventListener('click', this.boundItemClick_);
	            // Add a tab index to each menu item.
	            items[i].tabIndex = '-1';
	            // Add a keyboard listener to each menu item.
	            items[i].addEventListener('keydown', this.boundItemKeydown_);
	        }
	        // Add ripple classes to each item, if the user has enabled ripples.
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            for (i = 0; i < items.length; i++) {
	                var item = items[i];
	                var rippleContainer = document.createElement('span');
	                rippleContainer.classList.add(this.CssClasses_.ITEM_RIPPLE_CONTAINER);
	                var ripple = document.createElement('span');
	                ripple.classList.add(this.CssClasses_.RIPPLE);
	                rippleContainer.appendChild(ripple);
	                item.appendChild(rippleContainer);
	                item.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            }
	        }
	        // Copy alignment classes to the container, so the outline can use them.
	        if (this.element_.classList.contains(this.CssClasses_.BOTTOM_LEFT)) {
	            this.outline_.classList.add(this.CssClasses_.BOTTOM_LEFT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
	            this.outline_.classList.add(this.CssClasses_.BOTTOM_RIGHT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT)) {
	            this.outline_.classList.add(this.CssClasses_.TOP_LEFT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	            this.outline_.classList.add(this.CssClasses_.TOP_RIGHT);
	        }
	        if (this.element_.classList.contains(this.CssClasses_.UNALIGNED)) {
	            this.outline_.classList.add(this.CssClasses_.UNALIGNED);
	        }
	        container.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	/**
	   * Handles a click on the "for" element, by positioning the menu and then
	   * toggling it.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleForClick_ = function (evt) {
	    if (this.element_ && this.forElement_) {
	        var rect = this.forElement_.getBoundingClientRect();
	        var forRect = this.forElement_.parentElement.getBoundingClientRect();
	        if (this.element_.classList.contains(this.CssClasses_.UNALIGNED)) {
	        } else if (this.element_.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
	            // Position below the "for" element, aligned to its right.
	            this.container_.style.right = forRect.right - rect.right + 'px';
	            this.container_.style.top = this.forElement_.offsetTop + this.forElement_.offsetHeight + 'px';
	        } else if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT)) {
	            // Position above the "for" element, aligned to its left.
	            this.container_.style.left = this.forElement_.offsetLeft + 'px';
	            this.container_.style.bottom = forRect.bottom - rect.top + 'px';
	        } else if (this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	            // Position above the "for" element, aligned to its right.
	            this.container_.style.right = forRect.right - rect.right + 'px';
	            this.container_.style.bottom = forRect.bottom - rect.top + 'px';
	        } else {
	            // Default: position below the "for" element, aligned to its left.
	            this.container_.style.left = this.forElement_.offsetLeft + 'px';
	            this.container_.style.top = this.forElement_.offsetTop + this.forElement_.offsetHeight + 'px';
	        }
	    }
	    this.toggle(evt);
	};
	/**
	   * Handles a keyboard event on the "for" element.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleForKeyboardEvent_ = function (evt) {
	    if (this.element_ && this.container_ && this.forElement_) {
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM + ':not([disabled])');
	        if (items && items.length > 0 && this.container_.classList.contains(this.CssClasses_.IS_VISIBLE)) {
	            if (evt.keyCode === this.Keycodes_.UP_ARROW) {
	                evt.preventDefault();
	                items[items.length - 1].focus();
	            } else if (evt.keyCode === this.Keycodes_.DOWN_ARROW) {
	                evt.preventDefault();
	                items[0].focus();
	            }
	        }
	    }
	};
	/**
	   * Handles a keyboard event on an item.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleItemKeyboardEvent_ = function (evt) {
	    if (this.element_ && this.container_) {
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM + ':not([disabled])');
	        if (items && items.length > 0 && this.container_.classList.contains(this.CssClasses_.IS_VISIBLE)) {
	            var currentIndex = Array.prototype.slice.call(items).indexOf(evt.target);
	            if (evt.keyCode === this.Keycodes_.UP_ARROW) {
	                evt.preventDefault();
	                if (currentIndex > 0) {
	                    items[currentIndex - 1].focus();
	                } else {
	                    items[items.length - 1].focus();
	                }
	            } else if (evt.keyCode === this.Keycodes_.DOWN_ARROW) {
	                evt.preventDefault();
	                if (items.length > currentIndex + 1) {
	                    items[currentIndex + 1].focus();
	                } else {
	                    items[0].focus();
	                }
	            } else if (evt.keyCode === this.Keycodes_.SPACE || evt.keyCode === this.Keycodes_.ENTER) {
	                evt.preventDefault();
	                // Send mousedown and mouseup to trigger ripple.
	                var e = new MouseEvent('mousedown');
	                evt.target.dispatchEvent(e);
	                e = new MouseEvent('mouseup');
	                evt.target.dispatchEvent(e);
	                // Send click.
	                evt.target.click();
	            } else if (evt.keyCode === this.Keycodes_.ESCAPE) {
	                evt.preventDefault();
	                this.hide();
	            }
	        }
	    }
	};
	/**
	   * Handles a click event on an item.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialMenu.prototype.handleItemClick_ = function (evt) {
	    if (evt.target.hasAttribute('disabled')) {
	        evt.stopPropagation();
	    } else {
	        // Wait some time before closing menu, so the user can see the ripple.
	        this.closing_ = true;
	        window.setTimeout(function (evt) {
	            this.hide();
	            this.closing_ = false;
	        }.bind(this), this.Constant_.CLOSE_TIMEOUT);
	    }
	};
	/**
	   * Calculates the initial clip (for opening the menu) or final clip (for closing
	   * it), and applies it. This allows us to animate from or to the correct point,
	   * that is, the point it's aligned to in the "for" element.
	   *
	   * @param {number} height Height of the clip rectangle
	   * @param {number} width Width of the clip rectangle
	   * @private
	   */
	MaterialMenu.prototype.applyClip_ = function (height, width) {
	    if (this.element_.classList.contains(this.CssClasses_.UNALIGNED)) {
	        // Do not clip.
	        this.element_.style.clip = '';
	    } else if (this.element_.classList.contains(this.CssClasses_.BOTTOM_RIGHT)) {
	        // Clip to the top right corner of the menu.
	        this.element_.style.clip = 'rect(0 ' + width + 'px ' + '0 ' + width + 'px)';
	    } else if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT)) {
	        // Clip to the bottom left corner of the menu.
	        this.element_.style.clip = 'rect(' + height + 'px 0 ' + height + 'px 0)';
	    } else if (this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	        // Clip to the bottom right corner of the menu.
	        this.element_.style.clip = 'rect(' + height + 'px ' + width + 'px ' + height + 'px ' + width + 'px)';
	    } else {
	        // Default: do not clip (same as clipping to the top left corner).
	        this.element_.style.clip = '';
	    }
	};
	/**
	   * Cleanup function to remove animation listeners.
	   *
	   * @param {Event} evt
	   * @private
	   */
	MaterialMenu.prototype.removeAnimationEndListener_ = function (evt) {
	    evt.target.classList.remove(MaterialMenu.prototype.CssClasses_.IS_ANIMATING);
	};
	/**
	   * Adds an event listener to clean up after the animation ends.
	   *
	   * @private
	   */
	MaterialMenu.prototype.addAnimationEndListener_ = function () {
	    this.element_.addEventListener('transitionend', this.removeAnimationEndListener_);
	    this.element_.addEventListener('webkitTransitionEnd', this.removeAnimationEndListener_);
	};
	/**
	   * Displays the menu.
	   *
	   * @public
	   */
	MaterialMenu.prototype.show = function (evt) {
	    if (this.element_ && this.container_ && this.outline_) {
	        // Measure the inner element.
	        var height = this.element_.getBoundingClientRect().height;
	        var width = this.element_.getBoundingClientRect().width;
	        // Apply the inner element's size to the container and outline.
	        this.container_.style.width = width + 'px';
	        this.container_.style.height = height + 'px';
	        this.outline_.style.width = width + 'px';
	        this.outline_.style.height = height + 'px';
	        var transitionDuration = this.Constant_.TRANSITION_DURATION_SECONDS * this.Constant_.TRANSITION_DURATION_FRACTION;
	        // Calculate transition delays for individual menu items, so that they fade
	        // in one at a time.
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM);
	        for (var i = 0; i < items.length; i++) {
	            var itemDelay = null;
	            if (this.element_.classList.contains(this.CssClasses_.TOP_LEFT) || this.element_.classList.contains(this.CssClasses_.TOP_RIGHT)) {
	                itemDelay = (height - items[i].offsetTop - items[i].offsetHeight) / height * transitionDuration + 's';
	            } else {
	                itemDelay = items[i].offsetTop / height * transitionDuration + 's';
	            }
	            items[i].style.transitionDelay = itemDelay;
	        }
	        // Apply the initial clip to the text before we start animating.
	        this.applyClip_(height, width);
	        // Wait for the next frame, turn on animation, and apply the final clip.
	        // Also make it visible. This triggers the transitions.
	        window.requestAnimationFrame(function () {
	            this.element_.classList.add(this.CssClasses_.IS_ANIMATING);
	            this.element_.style.clip = 'rect(0 ' + width + 'px ' + height + 'px 0)';
	            this.container_.classList.add(this.CssClasses_.IS_VISIBLE);
	        }.bind(this));
	        // Clean up after the animation is complete.
	        this.addAnimationEndListener_();
	        // Add a click listener to the document, to close the menu.
	        var callback = function (e) {
	            // Check to see if the document is processing the same event that
	            // displayed the menu in the first place. If so, do nothing.
	            // Also check to see if the menu is in the process of closing itself, and
	            // do nothing in that case.
	            // Also check if the clicked element is a menu item
	            // if so, do nothing.
	            if (e !== evt && !this.closing_ && e.target.parentNode !== this.element_) {
	                document.removeEventListener('click', callback);
	                this.hide();
	            }
	        }.bind(this);
	        document.addEventListener('click', callback);
	    }
	};
	MaterialMenu.prototype['show'] = MaterialMenu.prototype.show;
	/**
	   * Hides the menu.
	   *
	   * @public
	   */
	MaterialMenu.prototype.hide = function () {
	    if (this.element_ && this.container_ && this.outline_) {
	        var items = this.element_.querySelectorAll('.' + this.CssClasses_.ITEM);
	        // Remove all transition delays; menu items fade out concurrently.
	        for (var i = 0; i < items.length; i++) {
	            items[i].style.removeProperty('transition-delay');
	        }
	        // Measure the inner element.
	        var rect = this.element_.getBoundingClientRect();
	        var height = rect.height;
	        var width = rect.width;
	        // Turn on animation, and apply the final clip. Also make invisible.
	        // This triggers the transitions.
	        this.element_.classList.add(this.CssClasses_.IS_ANIMATING);
	        this.applyClip_(height, width);
	        this.container_.classList.remove(this.CssClasses_.IS_VISIBLE);
	        // Clean up after the animation is complete.
	        this.addAnimationEndListener_();
	    }
	};
	MaterialMenu.prototype['hide'] = MaterialMenu.prototype.hide;
	/**
	   * Displays or hides the menu, depending on current state.
	   *
	   * @public
	   */
	MaterialMenu.prototype.toggle = function (evt) {
	    if (this.container_.classList.contains(this.CssClasses_.IS_VISIBLE)) {
	        this.hide();
	    } else {
	        this.show(evt);
	    }
	};
	MaterialMenu.prototype['toggle'] = MaterialMenu.prototype.toggle;
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialMenu,
	    classAsString: 'MaterialMenu',
	    cssClass: 'mdl-js-menu',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Progress MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialProgress = function MaterialProgress(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialProgress'] = MaterialProgress;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialProgress.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialProgress.prototype.CssClasses_ = { INDETERMINATE_CLASS: 'mdl-progress__indeterminate' };
	/**
	   * Set the current progress of the progressbar.
	   *
	   * @param {number} p Percentage of the progress (0-100)
	   * @public
	   */
	MaterialProgress.prototype.setProgress = function (p) {
	    if (this.element_.classList.contains(this.CssClasses_.INDETERMINATE_CLASS)) {
	        return;
	    }
	    this.progressbar_.style.width = p + '%';
	};
	MaterialProgress.prototype['setProgress'] = MaterialProgress.prototype.setProgress;
	/**
	   * Set the current progress of the buffer.
	   *
	   * @param {number} p Percentage of the buffer (0-100)
	   * @public
	   */
	MaterialProgress.prototype.setBuffer = function (p) {
	    this.bufferbar_.style.width = p + '%';
	    this.auxbar_.style.width = 100 - p + '%';
	};
	MaterialProgress.prototype['setBuffer'] = MaterialProgress.prototype.setBuffer;
	/**
	   * Initialize element.
	   */
	MaterialProgress.prototype.init = function () {
	    if (this.element_) {
	        var el = document.createElement('div');
	        el.className = 'progressbar bar bar1';
	        this.element_.appendChild(el);
	        this.progressbar_ = el;
	        el = document.createElement('div');
	        el.className = 'bufferbar bar bar2';
	        this.element_.appendChild(el);
	        this.bufferbar_ = el;
	        el = document.createElement('div');
	        el.className = 'auxbar bar bar3';
	        this.element_.appendChild(el);
	        this.auxbar_ = el;
	        this.progressbar_.style.width = '0%';
	        this.bufferbar_.style.width = '100%';
	        this.auxbar_.style.width = '0%';
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialProgress,
	    classAsString: 'MaterialProgress',
	    cssClass: 'mdl-js-progress',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Radio MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialRadio = function MaterialRadio(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialRadio'] = MaterialRadio;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialRadio.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialRadio.prototype.CssClasses_ = {
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked',
	    IS_UPGRADED: 'is-upgraded',
	    JS_RADIO: 'mdl-js-radio',
	    RADIO_BTN: 'mdl-radio__button',
	    RADIO_OUTER_CIRCLE: 'mdl-radio__outer-circle',
	    RADIO_INNER_CIRCLE: 'mdl-radio__inner-circle',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-radio__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onChange_ = function (event) {
	    // Since other radio buttons don't get change events, we need to look for
	    // them to update their classes.
	    var radios = document.getElementsByClassName(this.CssClasses_.JS_RADIO);
	    for (var i = 0; i < radios.length; i++) {
	        var button = radios[i].querySelector('.' + this.CssClasses_.RADIO_BTN);
	        // Different name == different group, so no point updating those.
	        if (button.getAttribute('name') === this.btnElement_.getAttribute('name')) {
	            if (typeof radios[i]['MaterialRadio'] !== 'undefined') {
	                radios[i]['MaterialRadio'].updateClasses_();
	            }
	        }
	    }
	};
	/**
	   * Handle focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRadio.prototype.onMouseup_ = function (event) {
	    this.blur_();
	};
	/**
	   * Update classes.
	   *
	   * @private
	   */
	MaterialRadio.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialRadio.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.btnElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the components disabled state.
	   *
	   * @public
	   */
	MaterialRadio.prototype.checkDisabled = function () {
	    if (this.btnElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialRadio.prototype['checkDisabled'] = MaterialRadio.prototype.checkDisabled;
	/**
	   * Check the components toggled state.
	   *
	   * @public
	   */
	MaterialRadio.prototype.checkToggleState = function () {
	    if (this.btnElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialRadio.prototype['checkToggleState'] = MaterialRadio.prototype.checkToggleState;
	/**
	   * Disable radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.disable = function () {
	    this.btnElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialRadio.prototype['disable'] = MaterialRadio.prototype.disable;
	/**
	   * Enable radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.enable = function () {
	    this.btnElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialRadio.prototype['enable'] = MaterialRadio.prototype.enable;
	/**
	   * Check radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.check = function () {
	    this.btnElement_.checked = true;
	    this.onChange_(null);
	};
	MaterialRadio.prototype['check'] = MaterialRadio.prototype.check;
	/**
	   * Uncheck radio.
	   *
	   * @public
	   */
	MaterialRadio.prototype.uncheck = function () {
	    this.btnElement_.checked = false;
	    this.onChange_(null);
	};
	MaterialRadio.prototype['uncheck'] = MaterialRadio.prototype.uncheck;
	/**
	   * Initialize element.
	   */
	MaterialRadio.prototype.init = function () {
	    if (this.element_) {
	        this.btnElement_ = this.element_.querySelector('.' + this.CssClasses_.RADIO_BTN);
	        this.boundChangeHandler_ = this.onChange_.bind(this);
	        this.boundFocusHandler_ = this.onChange_.bind(this);
	        this.boundBlurHandler_ = this.onBlur_.bind(this);
	        this.boundMouseUpHandler_ = this.onMouseup_.bind(this);
	        var outerCircle = document.createElement('span');
	        outerCircle.classList.add(this.CssClasses_.RADIO_OUTER_CIRCLE);
	        var innerCircle = document.createElement('span');
	        innerCircle.classList.add(this.CssClasses_.RADIO_INNER_CIRCLE);
	        this.element_.appendChild(outerCircle);
	        this.element_.appendChild(innerCircle);
	        var rippleContainer;
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            rippleContainer = document.createElement('span');
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            rippleContainer.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            rippleContainer.addEventListener('mouseup', this.boundMouseUpHandler_);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            rippleContainer.appendChild(ripple);
	            this.element_.appendChild(rippleContainer);
	        }
	        this.btnElement_.addEventListener('change', this.boundChangeHandler_);
	        this.btnElement_.addEventListener('focus', this.boundFocusHandler_);
	        this.btnElement_.addEventListener('blur', this.boundBlurHandler_);
	        this.element_.addEventListener('mouseup', this.boundMouseUpHandler_);
	        this.updateClasses_();
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialRadio,
	    classAsString: 'MaterialRadio',
	    cssClass: 'mdl-js-radio',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Slider MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialSlider = function MaterialSlider(element) {
	    this.element_ = element;
	    // Browser feature detection.
	    this.isIE_ = window.navigator.msPointerEnabled;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialSlider'] = MaterialSlider;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSlider.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSlider.prototype.CssClasses_ = {
	    IE_CONTAINER: 'mdl-slider__ie-container',
	    SLIDER_CONTAINER: 'mdl-slider__container',
	    BACKGROUND_FLEX: 'mdl-slider__background-flex',
	    BACKGROUND_LOWER: 'mdl-slider__background-lower',
	    BACKGROUND_UPPER: 'mdl-slider__background-upper',
	    IS_LOWEST_VALUE: 'is-lowest-value',
	    IS_UPGRADED: 'is-upgraded'
	};
	/**
	   * Handle input on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSlider.prototype.onInput_ = function (event) {
	    this.updateValueStyles_();
	};
	/**
	   * Handle change on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSlider.prototype.onChange_ = function (event) {
	    this.updateValueStyles_();
	};
	/**
	   * Handle mouseup on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSlider.prototype.onMouseUp_ = function (event) {
	    event.target.blur();
	};
	/**
	   * Handle mousedown on container element.
	   * This handler is purpose is to not require the use to click
	   * exactly on the 2px slider element, as FireFox seems to be very
	   * strict about this.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   * @suppress {missingProperties}
	   */
	MaterialSlider.prototype.onContainerMouseDown_ = function (event) {
	    // If this click is not on the parent element (but rather some child)
	    // ignore. It may still bubble up.
	    if (event.target !== this.element_.parentElement) {
	        return;
	    }
	    // Discard the original event and create a new event that
	    // is on the slider element.
	    event.preventDefault();
	    var newEvent = new MouseEvent('mousedown', {
	        target: event.target,
	        buttons: event.buttons,
	        clientX: event.clientX,
	        clientY: this.element_.getBoundingClientRect().y
	    });
	    this.element_.dispatchEvent(newEvent);
	};
	/**
	   * Handle updating of values.
	   *
	   * @private
	   */
	MaterialSlider.prototype.updateValueStyles_ = function () {
	    // Calculate and apply percentages to div structure behind slider.
	    var fraction = (this.element_.value - this.element_.min) / (this.element_.max - this.element_.min);
	    if (fraction === 0) {
	        this.element_.classList.add(this.CssClasses_.IS_LOWEST_VALUE);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_LOWEST_VALUE);
	    }
	    if (!this.isIE_) {
	        this.backgroundLower_.style.flex = fraction;
	        this.backgroundLower_.style.webkitFlex = fraction;
	        this.backgroundUpper_.style.flex = 1 - fraction;
	        this.backgroundUpper_.style.webkitFlex = 1 - fraction;
	    }
	};
	// Public methods.
	/**
	   * Disable slider.
	   *
	   * @public
	   */
	MaterialSlider.prototype.disable = function () {
	    this.element_.disabled = true;
	};
	MaterialSlider.prototype['disable'] = MaterialSlider.prototype.disable;
	/**
	   * Enable slider.
	   *
	   * @public
	   */
	MaterialSlider.prototype.enable = function () {
	    this.element_.disabled = false;
	};
	MaterialSlider.prototype['enable'] = MaterialSlider.prototype.enable;
	/**
	   * Update slider value.
	   *
	   * @param {number} value The value to which to set the control (optional).
	   * @public
	   */
	MaterialSlider.prototype.change = function (value) {
	    if (typeof value !== 'undefined') {
	        this.element_.value = value;
	    }
	    this.updateValueStyles_();
	};
	MaterialSlider.prototype['change'] = MaterialSlider.prototype.change;
	/**
	   * Initialize element.
	   */
	MaterialSlider.prototype.init = function () {
	    if (this.element_) {
	        if (this.isIE_) {
	            // Since we need to specify a very large height in IE due to
	            // implementation limitations, we add a parent here that trims it down to
	            // a reasonable size.
	            var containerIE = document.createElement('div');
	            containerIE.classList.add(this.CssClasses_.IE_CONTAINER);
	            this.element_.parentElement.insertBefore(containerIE, this.element_);
	            this.element_.parentElement.removeChild(this.element_);
	            containerIE.appendChild(this.element_);
	        } else {
	            // For non-IE browsers, we need a div structure that sits behind the
	            // slider and allows us to style the left and right sides of it with
	            // different colors.
	            var container = document.createElement('div');
	            container.classList.add(this.CssClasses_.SLIDER_CONTAINER);
	            this.element_.parentElement.insertBefore(container, this.element_);
	            this.element_.parentElement.removeChild(this.element_);
	            container.appendChild(this.element_);
	            var backgroundFlex = document.createElement('div');
	            backgroundFlex.classList.add(this.CssClasses_.BACKGROUND_FLEX);
	            container.appendChild(backgroundFlex);
	            this.backgroundLower_ = document.createElement('div');
	            this.backgroundLower_.classList.add(this.CssClasses_.BACKGROUND_LOWER);
	            backgroundFlex.appendChild(this.backgroundLower_);
	            this.backgroundUpper_ = document.createElement('div');
	            this.backgroundUpper_.classList.add(this.CssClasses_.BACKGROUND_UPPER);
	            backgroundFlex.appendChild(this.backgroundUpper_);
	        }
	        this.boundInputHandler = this.onInput_.bind(this);
	        this.boundChangeHandler = this.onChange_.bind(this);
	        this.boundMouseUpHandler = this.onMouseUp_.bind(this);
	        this.boundContainerMouseDownHandler = this.onContainerMouseDown_.bind(this);
	        this.element_.addEventListener('input', this.boundInputHandler);
	        this.element_.addEventListener('change', this.boundChangeHandler);
	        this.element_.addEventListener('mouseup', this.boundMouseUpHandler);
	        this.element_.parentElement.addEventListener('mousedown', this.boundContainerMouseDownHandler);
	        this.updateValueStyles_();
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSlider,
	    classAsString: 'MaterialSlider',
	    cssClass: 'mdl-js-slider',
	    widget: true
	});
	/**
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Snackbar MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialSnackbar = function MaterialSnackbar(element) {
	    this.element_ = element;
	    this.textElement_ = this.element_.querySelector('.' + this.cssClasses_.MESSAGE);
	    this.actionElement_ = this.element_.querySelector('.' + this.cssClasses_.ACTION);
	    if (!this.textElement_) {
	        throw new Error('There must be a message element for a snackbar.');
	    }
	    if (!this.actionElement_) {
	        throw new Error('There must be an action element for a snackbar.');
	    }
	    this.active = false;
	    this.actionHandler_ = undefined;
	    this.message_ = undefined;
	    this.actionText_ = undefined;
	    this.queuedNotifications_ = [];
	    this.setActionHidden_(true);
	};
	window['MaterialSnackbar'] = MaterialSnackbar;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSnackbar.prototype.Constant_ = {
	    // The duration of the snackbar show/hide animation, in ms.
	    ANIMATION_LENGTH: 250
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSnackbar.prototype.cssClasses_ = {
	    SNACKBAR: 'mdl-snackbar',
	    MESSAGE: 'mdl-snackbar__text',
	    ACTION: 'mdl-snackbar__action',
	    ACTIVE: 'mdl-snackbar--active'
	};
	/**
	   * Display the snackbar.
	   *
	   * @private
	   */
	MaterialSnackbar.prototype.displaySnackbar_ = function () {
	    this.element_.setAttribute('aria-hidden', 'true');
	    if (this.actionHandler_) {
	        this.actionElement_.textContent = this.actionText_;
	        this.actionElement_.addEventListener('click', this.actionHandler_);
	        this.setActionHidden_(false);
	    }
	    this.textElement_.textContent = this.message_;
	    this.element_.classList.add(this.cssClasses_.ACTIVE);
	    this.element_.setAttribute('aria-hidden', 'false');
	    setTimeout(this.cleanup_.bind(this), this.timeout_);
	};
	/**
	   * Show the snackbar.
	   *
	   * @param {Object} data The data for the notification.
	   * @public
	   */
	MaterialSnackbar.prototype.showSnackbar = function (data) {
	    if (data === undefined) {
	        throw new Error('Please provide a data object with at least a message to display.');
	    }
	    if (data['message'] === undefined) {
	        throw new Error('Please provide a message to be displayed.');
	    }
	    if (data['actionHandler'] && !data['actionText']) {
	        throw new Error('Please provide action text with the handler.');
	    }
	    if (this.active) {
	        this.queuedNotifications_.push(data);
	    } else {
	        this.active = true;
	        this.message_ = data['message'];
	        if (data['timeout']) {
	            this.timeout_ = data['timeout'];
	        } else {
	            this.timeout_ = 2750;
	        }
	        if (data['actionHandler']) {
	            this.actionHandler_ = data['actionHandler'];
	        }
	        if (data['actionText']) {
	            this.actionText_ = data['actionText'];
	        }
	        this.displaySnackbar_();
	    }
	};
	MaterialSnackbar.prototype['showSnackbar'] = MaterialSnackbar.prototype.showSnackbar;
	/**
	   * Check if the queue has items within it.
	   * If it does, display the next entry.
	   *
	   * @private
	   */
	MaterialSnackbar.prototype.checkQueue_ = function () {
	    if (this.queuedNotifications_.length > 0) {
	        this.showSnackbar(this.queuedNotifications_.shift());
	    }
	};
	/**
	   * Cleanup the snackbar event listeners and accessiblity attributes.
	   *
	   * @private
	   */
	MaterialSnackbar.prototype.cleanup_ = function () {
	    this.element_.classList.remove(this.cssClasses_.ACTIVE);
	    setTimeout(function () {
	        this.element_.setAttribute('aria-hidden', 'true');
	        this.textElement_.textContent = '';
	        if (!Boolean(this.actionElement_.getAttribute('aria-hidden'))) {
	            this.setActionHidden_(true);
	            this.actionElement_.textContent = '';
	            this.actionElement_.removeEventListener('click', this.actionHandler_);
	        }
	        this.actionHandler_ = undefined;
	        this.message_ = undefined;
	        this.actionText_ = undefined;
	        this.active = false;
	        this.checkQueue_();
	    }.bind(this), this.Constant_.ANIMATION_LENGTH);
	};
	/**
	   * Set the action handler hidden state.
	   *
	   * @param {boolean} value
	   * @private
	   */
	MaterialSnackbar.prototype.setActionHidden_ = function (value) {
	    if (value) {
	        this.actionElement_.setAttribute('aria-hidden', 'true');
	    } else {
	        this.actionElement_.removeAttribute('aria-hidden');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSnackbar,
	    classAsString: 'MaterialSnackbar',
	    cssClass: 'mdl-js-snackbar',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Spinner MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @param {HTMLElement} element The element that will be upgraded.
	   * @constructor
	   */
	var MaterialSpinner = function MaterialSpinner(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialSpinner'] = MaterialSpinner;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSpinner.prototype.Constant_ = { MDL_SPINNER_LAYER_COUNT: 4 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSpinner.prototype.CssClasses_ = {
	    MDL_SPINNER_LAYER: 'mdl-spinner__layer',
	    MDL_SPINNER_CIRCLE_CLIPPER: 'mdl-spinner__circle-clipper',
	    MDL_SPINNER_CIRCLE: 'mdl-spinner__circle',
	    MDL_SPINNER_GAP_PATCH: 'mdl-spinner__gap-patch',
	    MDL_SPINNER_LEFT: 'mdl-spinner__left',
	    MDL_SPINNER_RIGHT: 'mdl-spinner__right'
	};
	/**
	   * Auxiliary method to create a spinner layer.
	   *
	   * @param {number} index Index of the layer to be created.
	   * @public
	   */
	MaterialSpinner.prototype.createLayer = function (index) {
	    var layer = document.createElement('div');
	    layer.classList.add(this.CssClasses_.MDL_SPINNER_LAYER);
	    layer.classList.add(this.CssClasses_.MDL_SPINNER_LAYER + '-' + index);
	    var leftClipper = document.createElement('div');
	    leftClipper.classList.add(this.CssClasses_.MDL_SPINNER_CIRCLE_CLIPPER);
	    leftClipper.classList.add(this.CssClasses_.MDL_SPINNER_LEFT);
	    var gapPatch = document.createElement('div');
	    gapPatch.classList.add(this.CssClasses_.MDL_SPINNER_GAP_PATCH);
	    var rightClipper = document.createElement('div');
	    rightClipper.classList.add(this.CssClasses_.MDL_SPINNER_CIRCLE_CLIPPER);
	    rightClipper.classList.add(this.CssClasses_.MDL_SPINNER_RIGHT);
	    var circleOwners = [
	        leftClipper,
	        gapPatch,
	        rightClipper
	    ];
	    for (var i = 0; i < circleOwners.length; i++) {
	        var circle = document.createElement('div');
	        circle.classList.add(this.CssClasses_.MDL_SPINNER_CIRCLE);
	        circleOwners[i].appendChild(circle);
	    }
	    layer.appendChild(leftClipper);
	    layer.appendChild(gapPatch);
	    layer.appendChild(rightClipper);
	    this.element_.appendChild(layer);
	};
	MaterialSpinner.prototype['createLayer'] = MaterialSpinner.prototype.createLayer;
	/**
	   * Stops the spinner animation.
	   * Public method for users who need to stop the spinner for any reason.
	   *
	   * @public
	   */
	MaterialSpinner.prototype.stop = function () {
	    this.element_.classList.remove('is-active');
	};
	MaterialSpinner.prototype['stop'] = MaterialSpinner.prototype.stop;
	/**
	   * Starts the spinner animation.
	   * Public method for users who need to manually start the spinner for any reason
	   * (instead of just adding the 'is-active' class to their markup).
	   *
	   * @public
	   */
	MaterialSpinner.prototype.start = function () {
	    this.element_.classList.add('is-active');
	};
	MaterialSpinner.prototype['start'] = MaterialSpinner.prototype.start;
	/**
	   * Initialize element.
	   */
	MaterialSpinner.prototype.init = function () {
	    if (this.element_) {
	        for (var i = 1; i <= this.Constant_.MDL_SPINNER_LAYER_COUNT; i++) {
	            this.createLayer(i);
	        }
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSpinner,
	    classAsString: 'MaterialSpinner',
	    cssClass: 'mdl-js-spinner',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Checkbox MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialSwitch = function MaterialSwitch(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialSwitch'] = MaterialSwitch;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialSwitch.prototype.Constant_ = { TINY_TIMEOUT: 0.001 };
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialSwitch.prototype.CssClasses_ = {
	    INPUT: 'mdl-switch__input',
	    TRACK: 'mdl-switch__track',
	    THUMB: 'mdl-switch__thumb',
	    FOCUS_HELPER: 'mdl-switch__focus-helper',
	    RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE_CONTAINER: 'mdl-switch__ripple-container',
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE: 'mdl-ripple',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_CHECKED: 'is-checked'
	};
	/**
	   * Handle change of state.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onChange_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus of element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle mouseup.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialSwitch.prototype.onMouseUp_ = function (event) {
	    this.blur_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialSwitch.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkToggleState();
	};
	/**
	   * Add blur.
	   *
	   * @private
	   */
	MaterialSwitch.prototype.blur_ = function () {
	    // TODO: figure out why there's a focus event being fired after our blur,
	    // so that we can avoid this hack.
	    window.setTimeout(function () {
	        this.inputElement_.blur();
	    }.bind(this), this.Constant_.TINY_TIMEOUT);
	};
	// Public methods.
	/**
	   * Check the components disabled state.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.checkDisabled = function () {
	    if (this.inputElement_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialSwitch.prototype['checkDisabled'] = MaterialSwitch.prototype.checkDisabled;
	/**
	   * Check the components toggled state.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.checkToggleState = function () {
	    if (this.inputElement_.checked) {
	        this.element_.classList.add(this.CssClasses_.IS_CHECKED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_CHECKED);
	    }
	};
	MaterialSwitch.prototype['checkToggleState'] = MaterialSwitch.prototype.checkToggleState;
	/**
	   * Disable switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.disable = function () {
	    this.inputElement_.disabled = true;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['disable'] = MaterialSwitch.prototype.disable;
	/**
	   * Enable switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.enable = function () {
	    this.inputElement_.disabled = false;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['enable'] = MaterialSwitch.prototype.enable;
	/**
	   * Activate switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.on = function () {
	    this.inputElement_.checked = true;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['on'] = MaterialSwitch.prototype.on;
	/**
	   * Deactivate switch.
	   *
	   * @public
	   */
	MaterialSwitch.prototype.off = function () {
	    this.inputElement_.checked = false;
	    this.updateClasses_();
	};
	MaterialSwitch.prototype['off'] = MaterialSwitch.prototype.off;
	/**
	   * Initialize element.
	   */
	MaterialSwitch.prototype.init = function () {
	    if (this.element_) {
	        this.inputElement_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        var track = document.createElement('div');
	        track.classList.add(this.CssClasses_.TRACK);
	        var thumb = document.createElement('div');
	        thumb.classList.add(this.CssClasses_.THUMB);
	        var focusHelper = document.createElement('span');
	        focusHelper.classList.add(this.CssClasses_.FOCUS_HELPER);
	        thumb.appendChild(focusHelper);
	        this.element_.appendChild(track);
	        this.element_.appendChild(thumb);
	        this.boundMouseUpHandler = this.onMouseUp_.bind(this);
	        if (this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT)) {
	            this.element_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            this.rippleContainerElement_ = document.createElement('span');
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CONTAINER);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_EFFECT);
	            this.rippleContainerElement_.classList.add(this.CssClasses_.RIPPLE_CENTER);
	            this.rippleContainerElement_.addEventListener('mouseup', this.boundMouseUpHandler);
	            var ripple = document.createElement('span');
	            ripple.classList.add(this.CssClasses_.RIPPLE);
	            this.rippleContainerElement_.appendChild(ripple);
	            this.element_.appendChild(this.rippleContainerElement_);
	        }
	        this.boundChangeHandler = this.onChange_.bind(this);
	        this.boundFocusHandler = this.onFocus_.bind(this);
	        this.boundBlurHandler = this.onBlur_.bind(this);
	        this.inputElement_.addEventListener('change', this.boundChangeHandler);
	        this.inputElement_.addEventListener('focus', this.boundFocusHandler);
	        this.inputElement_.addEventListener('blur', this.boundBlurHandler);
	        this.element_.addEventListener('mouseup', this.boundMouseUpHandler);
	        this.updateClasses_();
	        this.element_.classList.add('is-upgraded');
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialSwitch,
	    classAsString: 'MaterialSwitch',
	    cssClass: 'mdl-js-switch',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Tabs MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {Element} element The element that will be upgraded.
	   */
	var MaterialTabs = function MaterialTabs(element) {
	    // Stores the HTML element.
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialTabs'] = MaterialTabs;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTabs.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTabs.prototype.CssClasses_ = {
	    TAB_CLASS: 'mdl-tabs__tab',
	    PANEL_CLASS: 'mdl-tabs__panel',
	    ACTIVE_CLASS: 'is-active',
	    UPGRADED_CLASS: 'is-upgraded',
	    MDL_JS_RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    MDL_RIPPLE_CONTAINER: 'mdl-tabs__ripple-container',
	    MDL_RIPPLE: 'mdl-ripple',
	    MDL_JS_RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events'
	};
	/**
	   * Handle clicks to a tabs component
	   *
	   * @private
	   */
	MaterialTabs.prototype.initTabs_ = function () {
	    if (this.element_.classList.contains(this.CssClasses_.MDL_JS_RIPPLE_EFFECT)) {
	        this.element_.classList.add(this.CssClasses_.MDL_JS_RIPPLE_EFFECT_IGNORE_EVENTS);
	    }
	    // Select element tabs, document panels
	    this.tabs_ = this.element_.querySelectorAll('.' + this.CssClasses_.TAB_CLASS);
	    this.panels_ = this.element_.querySelectorAll('.' + this.CssClasses_.PANEL_CLASS);
	    // Create new tabs for each tab element
	    for (var i = 0; i < this.tabs_.length; i++) {
	        new MaterialTab(this.tabs_[i], this);
	    }
	    this.element_.classList.add(this.CssClasses_.UPGRADED_CLASS);
	};
	/**
	   * Reset tab state, dropping active classes
	   *
	   * @private
	   */
	MaterialTabs.prototype.resetTabState_ = function () {
	    for (var k = 0; k < this.tabs_.length; k++) {
	        this.tabs_[k].classList.remove(this.CssClasses_.ACTIVE_CLASS);
	    }
	};
	/**
	   * Reset panel state, droping active classes
	   *
	   * @private
	   */
	MaterialTabs.prototype.resetPanelState_ = function () {
	    for (var j = 0; j < this.panels_.length; j++) {
	        this.panels_[j].classList.remove(this.CssClasses_.ACTIVE_CLASS);
	    }
	};
	/**
	   * Initialize element.
	   */
	MaterialTabs.prototype.init = function () {
	    if (this.element_) {
	        this.initTabs_();
	    }
	};
	/**
	   * Constructor for an individual tab.
	   *
	   * @constructor
	   * @param {Element} tab The HTML element for the tab.
	   * @param {MaterialTabs} ctx The MaterialTabs object that owns the tab.
	   */
	function MaterialTab(tab, ctx) {
	    if (tab) {
	        if (ctx.element_.classList.contains(ctx.CssClasses_.MDL_JS_RIPPLE_EFFECT)) {
	            var rippleContainer = document.createElement('span');
	            rippleContainer.classList.add(ctx.CssClasses_.MDL_RIPPLE_CONTAINER);
	            rippleContainer.classList.add(ctx.CssClasses_.MDL_JS_RIPPLE_EFFECT);
	            var ripple = document.createElement('span');
	            ripple.classList.add(ctx.CssClasses_.MDL_RIPPLE);
	            rippleContainer.appendChild(ripple);
	            tab.appendChild(rippleContainer);
	        }
	        tab.addEventListener('click', function (e) {
	            if (tab.getAttribute('href').charAt(0) === '#') {
	                e.preventDefault();
	                var href = tab.href.split('#')[1];
	                var panel = ctx.element_.querySelector('#' + href);
	                ctx.resetTabState_();
	                ctx.resetPanelState_();
	                tab.classList.add(ctx.CssClasses_.ACTIVE_CLASS);
	                panel.classList.add(ctx.CssClasses_.ACTIVE_CLASS);
	            }
	        });
	    }
	}
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialTabs,
	    classAsString: 'MaterialTabs',
	    cssClass: 'mdl-js-tabs'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Textfield MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialTextfield = function MaterialTextfield(element) {
	    this.element_ = element;
	    this.maxRows = this.Constant_.NO_MAX_ROWS;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialTextfield'] = MaterialTextfield;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialTextfield.prototype.Constant_ = {
	    NO_MAX_ROWS: -1,
	    MAX_ROWS_ATTRIBUTE: 'maxrows'
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTextfield.prototype.CssClasses_ = {
	    LABEL: 'mdl-textfield__label',
	    INPUT: 'mdl-textfield__input',
	    IS_DIRTY: 'is-dirty',
	    IS_FOCUSED: 'is-focused',
	    IS_DISABLED: 'is-disabled',
	    IS_INVALID: 'is-invalid',
	    IS_UPGRADED: 'is-upgraded',
	    HAS_PLACEHOLDER: 'has-placeholder'
	};
	/**
	   * Handle input being entered.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onKeyDown_ = function (event) {
	    var currentRowCount = event.target.value.split('\n').length;
	    if (event.keyCode === 13) {
	        if (currentRowCount >= this.maxRows) {
	            event.preventDefault();
	        }
	    }
	};
	/**
	   * Handle focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onFocus_ = function (event) {
	    this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle lost focus.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onBlur_ = function (event) {
	    this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	};
	/**
	   * Handle reset event from out side.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTextfield.prototype.onReset_ = function (event) {
	    this.updateClasses_();
	};
	/**
	   * Handle class updates.
	   *
	   * @private
	   */
	MaterialTextfield.prototype.updateClasses_ = function () {
	    this.checkDisabled();
	    this.checkValidity();
	    this.checkDirty();
	    this.checkFocus();
	};
	// Public methods.
	/**
	   * Check the disabled state and update field accordingly.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.checkDisabled = function () {
	    if (this.input_.disabled) {
	        this.element_.classList.add(this.CssClasses_.IS_DISABLED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DISABLED);
	    }
	};
	MaterialTextfield.prototype['checkDisabled'] = MaterialTextfield.prototype.checkDisabled;
	/**
	  * Check the focus state and update field accordingly.
	  *
	  * @public
	  */
	MaterialTextfield.prototype.checkFocus = function () {
	    if (Boolean(this.element_.querySelector(':focus'))) {
	        this.element_.classList.add(this.CssClasses_.IS_FOCUSED);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_FOCUSED);
	    }
	};
	MaterialTextfield.prototype['checkFocus'] = MaterialTextfield.prototype.checkFocus;
	/**
	   * Check the validity state and update field accordingly.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.checkValidity = function () {
	    if (this.input_.validity) {
	        if (this.input_.validity.valid) {
	            this.element_.classList.remove(this.CssClasses_.IS_INVALID);
	        } else {
	            this.element_.classList.add(this.CssClasses_.IS_INVALID);
	        }
	    }
	};
	MaterialTextfield.prototype['checkValidity'] = MaterialTextfield.prototype.checkValidity;
	/**
	   * Check the dirty state and update field accordingly.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.checkDirty = function () {
	    if (this.input_.value && this.input_.value.length > 0) {
	        this.element_.classList.add(this.CssClasses_.IS_DIRTY);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_DIRTY);
	    }
	};
	MaterialTextfield.prototype['checkDirty'] = MaterialTextfield.prototype.checkDirty;
	/**
	   * Disable text field.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.disable = function () {
	    this.input_.disabled = true;
	    this.updateClasses_();
	};
	MaterialTextfield.prototype['disable'] = MaterialTextfield.prototype.disable;
	/**
	   * Enable text field.
	   *
	   * @public
	   */
	MaterialTextfield.prototype.enable = function () {
	    this.input_.disabled = false;
	    this.updateClasses_();
	};
	MaterialTextfield.prototype['enable'] = MaterialTextfield.prototype.enable;
	/**
	   * Update text field value.
	   *
	   * @param {string} value The value to which to set the control (optional).
	   * @public
	   */
	MaterialTextfield.prototype.change = function (value) {
	    this.input_.value = value || '';
	    this.updateClasses_();
	};
	MaterialTextfield.prototype['change'] = MaterialTextfield.prototype.change;
	/**
	   * Initialize element.
	   */
	MaterialTextfield.prototype.init = function () {
	    if (this.element_) {
	        this.label_ = this.element_.querySelector('.' + this.CssClasses_.LABEL);
	        this.input_ = this.element_.querySelector('.' + this.CssClasses_.INPUT);
	        if (this.input_) {
	            if (this.input_.hasAttribute(this.Constant_.MAX_ROWS_ATTRIBUTE)) {
	                this.maxRows = parseInt(this.input_.getAttribute(this.Constant_.MAX_ROWS_ATTRIBUTE), 10);
	                if (isNaN(this.maxRows)) {
	                    this.maxRows = this.Constant_.NO_MAX_ROWS;
	                }
	            }
	            if (this.input_.hasAttribute('placeholder')) {
	                this.element_.classList.add(this.CssClasses_.HAS_PLACEHOLDER);
	            }
	            this.boundUpdateClassesHandler = this.updateClasses_.bind(this);
	            this.boundFocusHandler = this.onFocus_.bind(this);
	            this.boundBlurHandler = this.onBlur_.bind(this);
	            this.boundResetHandler = this.onReset_.bind(this);
	            this.input_.addEventListener('input', this.boundUpdateClassesHandler);
	            this.input_.addEventListener('focus', this.boundFocusHandler);
	            this.input_.addEventListener('blur', this.boundBlurHandler);
	            this.input_.addEventListener('reset', this.boundResetHandler);
	            if (this.maxRows !== this.Constant_.NO_MAX_ROWS) {
	                // TODO: This should handle pasting multi line text.
	                // Currently doesn't.
	                this.boundKeyDownHandler = this.onKeyDown_.bind(this);
	                this.input_.addEventListener('keydown', this.boundKeyDownHandler);
	            }
	            var invalid = this.element_.classList.contains(this.CssClasses_.IS_INVALID);
	            this.updateClasses_();
	            this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	            if (invalid) {
	                this.element_.classList.add(this.CssClasses_.IS_INVALID);
	            }
	            if (this.input_.hasAttribute('autofocus')) {
	                this.element_.focus();
	                this.checkFocus();
	            }
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialTextfield,
	    classAsString: 'MaterialTextfield',
	    cssClass: 'mdl-js-textfield',
	    widget: true
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Tooltip MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialTooltip = function MaterialTooltip(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialTooltip'] = MaterialTooltip;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialTooltip.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialTooltip.prototype.CssClasses_ = {
	    IS_ACTIVE: 'is-active',
	    BOTTOM: 'mdl-tooltip--bottom',
	    LEFT: 'mdl-tooltip--left',
	    RIGHT: 'mdl-tooltip--right',
	    TOP: 'mdl-tooltip--top'
	};
	/**
	   * Handle mouseenter for tooltip.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialTooltip.prototype.handleMouseEnter_ = function (event) {
	    var props = event.target.getBoundingClientRect();
	    var left = props.left + props.width / 2;
	    var top = props.top + props.height / 2;
	    var marginLeft = -1 * (this.element_.offsetWidth / 2);
	    var marginTop = -1 * (this.element_.offsetHeight / 2);
	    if (this.element_.classList.contains(this.CssClasses_.LEFT) || this.element_.classList.contains(this.CssClasses_.RIGHT)) {
	        left = props.width / 2;
	        if (top + marginTop < 0) {
	            this.element_.style.top = '0';
	            this.element_.style.marginTop = '0';
	        } else {
	            this.element_.style.top = top + 'px';
	            this.element_.style.marginTop = marginTop + 'px';
	        }
	    } else {
	        if (left + marginLeft < 0) {
	            this.element_.style.left = '0';
	            this.element_.style.marginLeft = '0';
	        } else {
	            this.element_.style.left = left + 'px';
	            this.element_.style.marginLeft = marginLeft + 'px';
	        }
	    }
	    if (this.element_.classList.contains(this.CssClasses_.TOP)) {
	        this.element_.style.top = props.top - this.element_.offsetHeight - 10 + 'px';
	    } else if (this.element_.classList.contains(this.CssClasses_.RIGHT)) {
	        this.element_.style.left = props.left + props.width + 10 + 'px';
	    } else if (this.element_.classList.contains(this.CssClasses_.LEFT)) {
	        this.element_.style.left = props.left - this.element_.offsetWidth - 10 + 'px';
	    } else {
	        this.element_.style.top = props.top + props.height + 10 + 'px';
	    }
	    this.element_.classList.add(this.CssClasses_.IS_ACTIVE);
	};
	/**
	   * Hide tooltip on mouseleave or scroll
	   *
	   * @private
	   */
	MaterialTooltip.prototype.hideTooltip_ = function () {
	    this.element_.classList.remove(this.CssClasses_.IS_ACTIVE);
	};
	/**
	   * Initialize element.
	   */
	MaterialTooltip.prototype.init = function () {
	    if (this.element_) {
	        var forElId = this.element_.getAttribute('for') || this.element_.getAttribute('data-mdl-for');
	        if (forElId) {
	            this.forElement_ = document.getElementById(forElId);
	        }
	        if (this.forElement_) {
	            // It's left here because it prevents accidental text selection on Android
	            if (!this.forElement_.hasAttribute('tabindex')) {
	                this.forElement_.setAttribute('tabindex', '0');
	            }
	            this.boundMouseEnterHandler = this.handleMouseEnter_.bind(this);
	            this.boundMouseLeaveAndScrollHandler = this.hideTooltip_.bind(this);
	            this.forElement_.addEventListener('mouseenter', this.boundMouseEnterHandler, false);
	            this.forElement_.addEventListener('touchend', this.boundMouseEnterHandler, false);
	            this.forElement_.addEventListener('mouseleave', this.boundMouseLeaveAndScrollHandler, false);
	            window.addEventListener('scroll', this.boundMouseLeaveAndScrollHandler, true);
	            window.addEventListener('touchstart', this.boundMouseLeaveAndScrollHandler);
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialTooltip,
	    classAsString: 'MaterialTooltip',
	    cssClass: 'mdl-tooltip'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Layout MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialLayout = function MaterialLayout(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialLayout'] = MaterialLayout;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialLayout.prototype.Constant_ = {
	    MAX_WIDTH: '(max-width: 1024px)',
	    TAB_SCROLL_PIXELS: 100,
	    RESIZE_TIMEOUT: 100,
	    MENU_ICON: '&#xE5D2;',
	    CHEVRON_LEFT: 'chevron_left',
	    CHEVRON_RIGHT: 'chevron_right'
	};
	/**
	   * Keycodes, for code readability.
	   *
	   * @enum {number}
	   * @private
	   */
	MaterialLayout.prototype.Keycodes_ = {
	    ENTER: 13,
	    ESCAPE: 27,
	    SPACE: 32
	};
	/**
	   * Modes.
	   *
	   * @enum {number}
	   * @private
	   */
	MaterialLayout.prototype.Mode_ = {
	    STANDARD: 0,
	    SEAMED: 1,
	    WATERFALL: 2,
	    SCROLL: 3
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialLayout.prototype.CssClasses_ = {
	    CONTAINER: 'mdl-layout__container',
	    HEADER: 'mdl-layout__header',
	    DRAWER: 'mdl-layout__drawer',
	    CONTENT: 'mdl-layout__content',
	    DRAWER_BTN: 'mdl-layout__drawer-button',
	    ICON: 'material-icons',
	    JS_RIPPLE_EFFECT: 'mdl-js-ripple-effect',
	    RIPPLE_CONTAINER: 'mdl-layout__tab-ripple-container',
	    RIPPLE: 'mdl-ripple',
	    RIPPLE_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    HEADER_SEAMED: 'mdl-layout__header--seamed',
	    HEADER_WATERFALL: 'mdl-layout__header--waterfall',
	    HEADER_SCROLL: 'mdl-layout__header--scroll',
	    FIXED_HEADER: 'mdl-layout--fixed-header',
	    OBFUSCATOR: 'mdl-layout__obfuscator',
	    TAB_BAR: 'mdl-layout__tab-bar',
	    TAB_CONTAINER: 'mdl-layout__tab-bar-container',
	    TAB: 'mdl-layout__tab',
	    TAB_BAR_BUTTON: 'mdl-layout__tab-bar-button',
	    TAB_BAR_LEFT_BUTTON: 'mdl-layout__tab-bar-left-button',
	    TAB_BAR_RIGHT_BUTTON: 'mdl-layout__tab-bar-right-button',
	    TAB_MANUAL_SWITCH: 'mdl-layout__tab-manual-switch',
	    PANEL: 'mdl-layout__tab-panel',
	    HAS_DRAWER: 'has-drawer',
	    HAS_TABS: 'has-tabs',
	    HAS_SCROLLING_HEADER: 'has-scrolling-header',
	    CASTING_SHADOW: 'is-casting-shadow',
	    IS_COMPACT: 'is-compact',
	    IS_SMALL_SCREEN: 'is-small-screen',
	    IS_DRAWER_OPEN: 'is-visible',
	    IS_ACTIVE: 'is-active',
	    IS_UPGRADED: 'is-upgraded',
	    IS_ANIMATING: 'is-animating',
	    ON_LARGE_SCREEN: 'mdl-layout--large-screen-only',
	    ON_SMALL_SCREEN: 'mdl-layout--small-screen-only'
	};
	/**
	   * Handles scrolling on the content.
	   *
	   * @private
	   */
	MaterialLayout.prototype.contentScrollHandler_ = function () {
	    if (this.header_.classList.contains(this.CssClasses_.IS_ANIMATING)) {
	        return;
	    }
	    var headerVisible = !this.element_.classList.contains(this.CssClasses_.IS_SMALL_SCREEN) || this.element_.classList.contains(this.CssClasses_.FIXED_HEADER);
	    if (this.content_.scrollTop > 0 && !this.header_.classList.contains(this.CssClasses_.IS_COMPACT)) {
	        this.header_.classList.add(this.CssClasses_.CASTING_SHADOW);
	        this.header_.classList.add(this.CssClasses_.IS_COMPACT);
	        if (headerVisible) {
	            this.header_.classList.add(this.CssClasses_.IS_ANIMATING);
	        }
	    } else if (this.content_.scrollTop <= 0 && this.header_.classList.contains(this.CssClasses_.IS_COMPACT)) {
	        this.header_.classList.remove(this.CssClasses_.CASTING_SHADOW);
	        this.header_.classList.remove(this.CssClasses_.IS_COMPACT);
	        if (headerVisible) {
	            this.header_.classList.add(this.CssClasses_.IS_ANIMATING);
	        }
	    }
	};
	/**
	   * Handles a keyboard event on the drawer.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialLayout.prototype.keyboardEventHandler_ = function (evt) {
	    // Only react when the drawer is open.
	    if (evt.keyCode === this.Keycodes_.ESCAPE && this.drawer_.classList.contains(this.CssClasses_.IS_DRAWER_OPEN)) {
	        this.toggleDrawer();
	    }
	};
	/**
	   * Handles changes in screen size.
	   *
	   * @private
	   */
	MaterialLayout.prototype.screenSizeHandler_ = function () {
	    if (this.screenSizeMediaQuery_.matches) {
	        this.element_.classList.add(this.CssClasses_.IS_SMALL_SCREEN);
	    } else {
	        this.element_.classList.remove(this.CssClasses_.IS_SMALL_SCREEN);
	        // Collapse drawer (if any) when moving to a large screen size.
	        if (this.drawer_) {
	            this.drawer_.classList.remove(this.CssClasses_.IS_DRAWER_OPEN);
	            this.obfuscator_.classList.remove(this.CssClasses_.IS_DRAWER_OPEN);
	        }
	    }
	};
	/**
	   * Handles events of drawer button.
	   *
	   * @param {Event} evt The event that fired.
	   * @private
	   */
	MaterialLayout.prototype.drawerToggleHandler_ = function (evt) {
	    if (evt && evt.type === 'keydown') {
	        if (evt.keyCode === this.Keycodes_.SPACE || evt.keyCode === this.Keycodes_.ENTER) {
	            // prevent scrolling in drawer nav
	            evt.preventDefault();
	        } else {
	            // prevent other keys
	            return;
	        }
	    }
	    this.toggleDrawer();
	};
	/**
	   * Handles (un)setting the `is-animating` class
	   *
	   * @private
	   */
	MaterialLayout.prototype.headerTransitionEndHandler_ = function () {
	    this.header_.classList.remove(this.CssClasses_.IS_ANIMATING);
	};
	/**
	   * Handles expanding the header on click
	   *
	   * @private
	   */
	MaterialLayout.prototype.headerClickHandler_ = function () {
	    if (this.header_.classList.contains(this.CssClasses_.IS_COMPACT)) {
	        this.header_.classList.remove(this.CssClasses_.IS_COMPACT);
	        this.header_.classList.add(this.CssClasses_.IS_ANIMATING);
	    }
	};
	/**
	   * Reset tab state, dropping active classes
	   *
	   * @private
	   */
	MaterialLayout.prototype.resetTabState_ = function (tabBar) {
	    for (var k = 0; k < tabBar.length; k++) {
	        tabBar[k].classList.remove(this.CssClasses_.IS_ACTIVE);
	    }
	};
	/**
	   * Reset panel state, droping active classes
	   *
	   * @private
	   */
	MaterialLayout.prototype.resetPanelState_ = function (panels) {
	    for (var j = 0; j < panels.length; j++) {
	        panels[j].classList.remove(this.CssClasses_.IS_ACTIVE);
	    }
	};
	/**
	  * Toggle drawer state
	  *
	  * @public
	  */
	MaterialLayout.prototype.toggleDrawer = function () {
	    var drawerButton = this.element_.querySelector('.' + this.CssClasses_.DRAWER_BTN);
	    this.drawer_.classList.toggle(this.CssClasses_.IS_DRAWER_OPEN);
	    this.obfuscator_.classList.toggle(this.CssClasses_.IS_DRAWER_OPEN);
	    // Set accessibility properties.
	    if (this.drawer_.classList.contains(this.CssClasses_.IS_DRAWER_OPEN)) {
	        this.drawer_.setAttribute('aria-hidden', 'false');
	        drawerButton.setAttribute('aria-expanded', 'true');
	    } else {
	        this.drawer_.setAttribute('aria-hidden', 'true');
	        drawerButton.setAttribute('aria-expanded', 'false');
	    }
	};
	MaterialLayout.prototype['toggleDrawer'] = MaterialLayout.prototype.toggleDrawer;
	/**
	   * Initialize element.
	   */
	MaterialLayout.prototype.init = function () {
	    if (this.element_) {
	        var container = document.createElement('div');
	        container.classList.add(this.CssClasses_.CONTAINER);
	        var focusedElement = this.element_.querySelector(':focus');
	        this.element_.parentElement.insertBefore(container, this.element_);
	        this.element_.parentElement.removeChild(this.element_);
	        container.appendChild(this.element_);
	        if (focusedElement) {
	            focusedElement.focus();
	        }
	        var directChildren = this.element_.childNodes;
	        var numChildren = directChildren.length;
	        for (var c = 0; c < numChildren; c++) {
	            var child = directChildren[c];
	            if (child.classList && child.classList.contains(this.CssClasses_.HEADER)) {
	                this.header_ = child;
	            }
	            if (child.classList && child.classList.contains(this.CssClasses_.DRAWER)) {
	                this.drawer_ = child;
	            }
	            if (child.classList && child.classList.contains(this.CssClasses_.CONTENT)) {
	                this.content_ = child;
	            }
	        }
	        window.addEventListener('pageshow', function (e) {
	            if (e.persisted) {
	                // when page is loaded from back/forward cache
	                // trigger repaint to let layout scroll in safari
	                this.element_.style.overflowY = 'hidden';
	                requestAnimationFrame(function () {
	                    this.element_.style.overflowY = '';
	                }.bind(this));
	            }
	        }.bind(this), false);
	        if (this.header_) {
	            this.tabBar_ = this.header_.querySelector('.' + this.CssClasses_.TAB_BAR);
	        }
	        var mode = this.Mode_.STANDARD;
	        if (this.header_) {
	            if (this.header_.classList.contains(this.CssClasses_.HEADER_SEAMED)) {
	                mode = this.Mode_.SEAMED;
	            } else if (this.header_.classList.contains(this.CssClasses_.HEADER_WATERFALL)) {
	                mode = this.Mode_.WATERFALL;
	                this.header_.addEventListener('transitionend', this.headerTransitionEndHandler_.bind(this));
	                this.header_.addEventListener('click', this.headerClickHandler_.bind(this));
	            } else if (this.header_.classList.contains(this.CssClasses_.HEADER_SCROLL)) {
	                mode = this.Mode_.SCROLL;
	                container.classList.add(this.CssClasses_.HAS_SCROLLING_HEADER);
	            }
	            if (mode === this.Mode_.STANDARD) {
	                this.header_.classList.add(this.CssClasses_.CASTING_SHADOW);
	                if (this.tabBar_) {
	                    this.tabBar_.classList.add(this.CssClasses_.CASTING_SHADOW);
	                }
	            } else if (mode === this.Mode_.SEAMED || mode === this.Mode_.SCROLL) {
	                this.header_.classList.remove(this.CssClasses_.CASTING_SHADOW);
	                if (this.tabBar_) {
	                    this.tabBar_.classList.remove(this.CssClasses_.CASTING_SHADOW);
	                }
	            } else if (mode === this.Mode_.WATERFALL) {
	                // Add and remove shadows depending on scroll position.
	                // Also add/remove auxiliary class for styling of the compact version of
	                // the header.
	                this.content_.addEventListener('scroll', this.contentScrollHandler_.bind(this));
	                this.contentScrollHandler_();
	            }
	        }
	        // Add drawer toggling button to our layout, if we have an openable drawer.
	        if (this.drawer_) {
	            var drawerButton = this.element_.querySelector('.' + this.CssClasses_.DRAWER_BTN);
	            if (!drawerButton) {
	                drawerButton = document.createElement('div');
	                drawerButton.setAttribute('aria-expanded', 'false');
	                drawerButton.setAttribute('role', 'button');
	                drawerButton.setAttribute('tabindex', '0');
	                drawerButton.classList.add(this.CssClasses_.DRAWER_BTN);
	                var drawerButtonIcon = document.createElement('i');
	                drawerButtonIcon.classList.add(this.CssClasses_.ICON);
	                drawerButtonIcon.innerHTML = this.Constant_.MENU_ICON;
	                drawerButton.appendChild(drawerButtonIcon);
	            }
	            if (this.drawer_.classList.contains(this.CssClasses_.ON_LARGE_SCREEN)) {
	                //If drawer has ON_LARGE_SCREEN class then add it to the drawer toggle button as well.
	                drawerButton.classList.add(this.CssClasses_.ON_LARGE_SCREEN);
	            } else if (this.drawer_.classList.contains(this.CssClasses_.ON_SMALL_SCREEN)) {
	                //If drawer has ON_SMALL_SCREEN class then add it to the drawer toggle button as well.
	                drawerButton.classList.add(this.CssClasses_.ON_SMALL_SCREEN);
	            }
	            drawerButton.addEventListener('click', this.drawerToggleHandler_.bind(this));
	            drawerButton.addEventListener('keydown', this.drawerToggleHandler_.bind(this));
	            // Add a class if the layout has a drawer, for altering the left padding.
	            // Adds the HAS_DRAWER to the elements since this.header_ may or may
	            // not be present.
	            this.element_.classList.add(this.CssClasses_.HAS_DRAWER);
	            // If we have a fixed header, add the button to the header rather than
	            // the layout.
	            if (this.element_.classList.contains(this.CssClasses_.FIXED_HEADER)) {
	                this.header_.insertBefore(drawerButton, this.header_.firstChild);
	            } else {
	                this.element_.insertBefore(drawerButton, this.content_);
	            }
	            var obfuscator = document.createElement('div');
	            obfuscator.classList.add(this.CssClasses_.OBFUSCATOR);
	            this.element_.appendChild(obfuscator);
	            obfuscator.addEventListener('click', this.drawerToggleHandler_.bind(this));
	            this.obfuscator_ = obfuscator;
	            this.drawer_.addEventListener('keydown', this.keyboardEventHandler_.bind(this));
	            this.drawer_.setAttribute('aria-hidden', 'true');
	        }
	        // Keep an eye on screen size, and add/remove auxiliary class for styling
	        // of small screens.
	        this.screenSizeMediaQuery_ = window.matchMedia(this.Constant_.MAX_WIDTH);
	        this.screenSizeMediaQuery_.addListener(this.screenSizeHandler_.bind(this));
	        this.screenSizeHandler_();
	        // Initialize tabs, if any.
	        if (this.header_ && this.tabBar_) {
	            this.element_.classList.add(this.CssClasses_.HAS_TABS);
	            var tabContainer = document.createElement('div');
	            tabContainer.classList.add(this.CssClasses_.TAB_CONTAINER);
	            this.header_.insertBefore(tabContainer, this.tabBar_);
	            this.header_.removeChild(this.tabBar_);
	            var leftButton = document.createElement('div');
	            leftButton.classList.add(this.CssClasses_.TAB_BAR_BUTTON);
	            leftButton.classList.add(this.CssClasses_.TAB_BAR_LEFT_BUTTON);
	            var leftButtonIcon = document.createElement('i');
	            leftButtonIcon.classList.add(this.CssClasses_.ICON);
	            leftButtonIcon.textContent = this.Constant_.CHEVRON_LEFT;
	            leftButton.appendChild(leftButtonIcon);
	            leftButton.addEventListener('click', function () {
	                this.tabBar_.scrollLeft -= this.Constant_.TAB_SCROLL_PIXELS;
	            }.bind(this));
	            var rightButton = document.createElement('div');
	            rightButton.classList.add(this.CssClasses_.TAB_BAR_BUTTON);
	            rightButton.classList.add(this.CssClasses_.TAB_BAR_RIGHT_BUTTON);
	            var rightButtonIcon = document.createElement('i');
	            rightButtonIcon.classList.add(this.CssClasses_.ICON);
	            rightButtonIcon.textContent = this.Constant_.CHEVRON_RIGHT;
	            rightButton.appendChild(rightButtonIcon);
	            rightButton.addEventListener('click', function () {
	                this.tabBar_.scrollLeft += this.Constant_.TAB_SCROLL_PIXELS;
	            }.bind(this));
	            tabContainer.appendChild(leftButton);
	            tabContainer.appendChild(this.tabBar_);
	            tabContainer.appendChild(rightButton);
	            // Add and remove tab buttons depending on scroll position and total
	            // window size.
	            var tabUpdateHandler = function () {
	                if (this.tabBar_.scrollLeft > 0) {
	                    leftButton.classList.add(this.CssClasses_.IS_ACTIVE);
	                } else {
	                    leftButton.classList.remove(this.CssClasses_.IS_ACTIVE);
	                }
	                if (this.tabBar_.scrollLeft < this.tabBar_.scrollWidth - this.tabBar_.offsetWidth) {
	                    rightButton.classList.add(this.CssClasses_.IS_ACTIVE);
	                } else {
	                    rightButton.classList.remove(this.CssClasses_.IS_ACTIVE);
	                }
	            }.bind(this);
	            this.tabBar_.addEventListener('scroll', tabUpdateHandler);
	            tabUpdateHandler();
	            // Update tabs when the window resizes.
	            var windowResizeHandler = function () {
	                // Use timeouts to make sure it doesn't happen too often.
	                if (this.resizeTimeoutId_) {
	                    clearTimeout(this.resizeTimeoutId_);
	                }
	                this.resizeTimeoutId_ = setTimeout(function () {
	                    tabUpdateHandler();
	                    this.resizeTimeoutId_ = null;
	                }.bind(this), this.Constant_.RESIZE_TIMEOUT);
	            }.bind(this);
	            window.addEventListener('resize', windowResizeHandler);
	            if (this.tabBar_.classList.contains(this.CssClasses_.JS_RIPPLE_EFFECT)) {
	                this.tabBar_.classList.add(this.CssClasses_.RIPPLE_IGNORE_EVENTS);
	            }
	            // Select element tabs, document panels
	            var tabs = this.tabBar_.querySelectorAll('.' + this.CssClasses_.TAB);
	            var panels = this.content_.querySelectorAll('.' + this.CssClasses_.PANEL);
	            // Create new tabs for each tab element
	            for (var i = 0; i < tabs.length; i++) {
	                new MaterialLayoutTab(tabs[i], tabs, panels, this);
	            }
	        }
	        this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	    }
	};
	/**
	   * Constructor for an individual tab.
	   *
	   * @constructor
	   * @param {HTMLElement} tab The HTML element for the tab.
	   * @param {!Array<HTMLElement>} tabs Array with HTML elements for all tabs.
	   * @param {!Array<HTMLElement>} panels Array with HTML elements for all panels.
	   * @param {MaterialLayout} layout The MaterialLayout object that owns the tab.
	   */
	function MaterialLayoutTab(tab, tabs, panels, layout) {
	    /**
	     * Auxiliary method to programmatically select a tab in the UI.
	     */
	    function selectTab() {
	        var href = tab.href.split('#')[1];
	        var panel = layout.content_.querySelector('#' + href);
	        layout.resetTabState_(tabs);
	        layout.resetPanelState_(panels);
	        tab.classList.add(layout.CssClasses_.IS_ACTIVE);
	        panel.classList.add(layout.CssClasses_.IS_ACTIVE);
	    }
	    if (layout.tabBar_.classList.contains(layout.CssClasses_.JS_RIPPLE_EFFECT)) {
	        var rippleContainer = document.createElement('span');
	        rippleContainer.classList.add(layout.CssClasses_.RIPPLE_CONTAINER);
	        rippleContainer.classList.add(layout.CssClasses_.JS_RIPPLE_EFFECT);
	        var ripple = document.createElement('span');
	        ripple.classList.add(layout.CssClasses_.RIPPLE);
	        rippleContainer.appendChild(ripple);
	        tab.appendChild(rippleContainer);
	    }
	    if (!layout.tabBar_.classList.contains(layout.CssClasses_.TAB_MANUAL_SWITCH)) {
	        tab.addEventListener('click', function (e) {
	            if (tab.getAttribute('href').charAt(0) === '#') {
	                e.preventDefault();
	                selectTab();
	            }
	        });
	    }
	    tab.show = selectTab;
	}
	window['MaterialLayoutTab'] = MaterialLayoutTab;
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialLayout,
	    classAsString: 'MaterialLayout',
	    cssClass: 'mdl-js-layout'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Data Table Card MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {Element} element The element that will be upgraded.
	   */
	var MaterialDataTable = function MaterialDataTable(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialDataTable'] = MaterialDataTable;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialDataTable.prototype.Constant_ = {};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialDataTable.prototype.CssClasses_ = {
	    DATA_TABLE: 'mdl-data-table',
	    SELECTABLE: 'mdl-data-table--selectable',
	    SELECT_ELEMENT: 'mdl-data-table__select',
	    IS_SELECTED: 'is-selected',
	    IS_UPGRADED: 'is-upgraded'
	};
	/**
	   * Generates and returns a function that toggles the selection state of a
	   * single row (or multiple rows).
	   *
	   * @param {Element} checkbox Checkbox that toggles the selection state.
	   * @param {Element} row Row to toggle when checkbox changes.
	   * @param {(Array<Object>|NodeList)=} opt_rows Rows to toggle when checkbox changes.
	   * @private
	   */
	MaterialDataTable.prototype.selectRow_ = function (checkbox, row, opt_rows) {
	    if (row) {
	        return function () {
	            if (checkbox.checked) {
	                row.classList.add(this.CssClasses_.IS_SELECTED);
	            } else {
	                row.classList.remove(this.CssClasses_.IS_SELECTED);
	            }
	        }.bind(this);
	    }
	    if (opt_rows) {
	        return function () {
	            var i;
	            var el;
	            if (checkbox.checked) {
	                for (i = 0; i < opt_rows.length; i++) {
	                    el = opt_rows[i].querySelector('td').querySelector('.mdl-checkbox');
	                    el['MaterialCheckbox'].check();
	                    opt_rows[i].classList.add(this.CssClasses_.IS_SELECTED);
	                }
	            } else {
	                for (i = 0; i < opt_rows.length; i++) {
	                    el = opt_rows[i].querySelector('td').querySelector('.mdl-checkbox');
	                    el['MaterialCheckbox'].uncheck();
	                    opt_rows[i].classList.remove(this.CssClasses_.IS_SELECTED);
	                }
	            }
	        }.bind(this);
	    }
	};
	/**
	   * Creates a checkbox for a single or or multiple rows and hooks up the
	   * event handling.
	   *
	   * @param {Element} row Row to toggle when checkbox changes.
	   * @param {(Array<Object>|NodeList)=} opt_rows Rows to toggle when checkbox changes.
	   * @private
	   */
	MaterialDataTable.prototype.createCheckbox_ = function (row, opt_rows) {
	    var label = document.createElement('label');
	    var labelClasses = [
	        'mdl-checkbox',
	        'mdl-js-checkbox',
	        'mdl-js-ripple-effect',
	        this.CssClasses_.SELECT_ELEMENT
	    ];
	    label.className = labelClasses.join(' ');
	    var checkbox = document.createElement('input');
	    checkbox.type = 'checkbox';
	    checkbox.classList.add('mdl-checkbox__input');
	    if (row) {
	        checkbox.checked = row.classList.contains(this.CssClasses_.IS_SELECTED);
	        checkbox.addEventListener('change', this.selectRow_(checkbox, row));
	    } else if (opt_rows) {
	        checkbox.addEventListener('change', this.selectRow_(checkbox, null, opt_rows));
	    }
	    label.appendChild(checkbox);
	    componentHandler.upgradeElement(label, 'MaterialCheckbox');
	    return label;
	};
	/**
	   * Initialize element.
	   */
	MaterialDataTable.prototype.init = function () {
	    if (this.element_) {
	        var firstHeader = this.element_.querySelector('th');
	        var bodyRows = Array.prototype.slice.call(this.element_.querySelectorAll('tbody tr'));
	        var footRows = Array.prototype.slice.call(this.element_.querySelectorAll('tfoot tr'));
	        var rows = bodyRows.concat(footRows);
	        if (this.element_.classList.contains(this.CssClasses_.SELECTABLE)) {
	            var th = document.createElement('th');
	            var headerCheckbox = this.createCheckbox_(null, rows);
	            th.appendChild(headerCheckbox);
	            firstHeader.parentElement.insertBefore(th, firstHeader);
	            for (var i = 0; i < rows.length; i++) {
	                var firstCell = rows[i].querySelector('td');
	                if (firstCell) {
	                    var td = document.createElement('td');
	                    if (rows[i].parentNode.nodeName.toUpperCase() === 'TBODY') {
	                        var rowCheckbox = this.createCheckbox_(rows[i]);
	                        td.appendChild(rowCheckbox);
	                    }
	                    rows[i].insertBefore(td, firstCell);
	                }
	            }
	            this.element_.classList.add(this.CssClasses_.IS_UPGRADED);
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialDataTable,
	    classAsString: 'MaterialDataTable',
	    cssClass: 'mdl-js-data-table'
	});
	/**
	 * @license
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	   * Class constructor for Ripple MDL component.
	   * Implements MDL component design pattern defined at:
	   * https://github.com/jasonmayes/mdl-component-design-pattern
	   *
	   * @constructor
	   * @param {HTMLElement} element The element that will be upgraded.
	   */
	var MaterialRipple = function MaterialRipple(element) {
	    this.element_ = element;
	    // Initialize instance.
	    this.init();
	};
	window['MaterialRipple'] = MaterialRipple;
	/**
	   * Store constants in one place so they can be updated easily.
	   *
	   * @enum {string | number}
	   * @private
	   */
	MaterialRipple.prototype.Constant_ = {
	    INITIAL_SCALE: 'scale(0.0001, 0.0001)',
	    INITIAL_SIZE: '1px',
	    INITIAL_OPACITY: '0.4',
	    FINAL_OPACITY: '0',
	    FINAL_SCALE: ''
	};
	/**
	   * Store strings for class names defined by this component that are used in
	   * JavaScript. This allows us to simply change it in one place should we
	   * decide to modify at a later date.
	   *
	   * @enum {string}
	   * @private
	   */
	MaterialRipple.prototype.CssClasses_ = {
	    RIPPLE_CENTER: 'mdl-ripple--center',
	    RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
	    RIPPLE: 'mdl-ripple',
	    IS_ANIMATING: 'is-animating',
	    IS_VISIBLE: 'is-visible'
	};
	/**
	   * Handle mouse / finger down on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRipple.prototype.downHandler_ = function (event) {
	    if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
	        var rect = this.element_.getBoundingClientRect();
	        this.boundHeight = rect.height;
	        this.boundWidth = rect.width;
	        this.rippleSize_ = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
	        this.rippleElement_.style.width = this.rippleSize_ + 'px';
	        this.rippleElement_.style.height = this.rippleSize_ + 'px';
	    }
	    this.rippleElement_.classList.add(this.CssClasses_.IS_VISIBLE);
	    if (event.type === 'mousedown' && this.ignoringMouseDown_) {
	        this.ignoringMouseDown_ = false;
	    } else {
	        if (event.type === 'touchstart') {
	            this.ignoringMouseDown_ = true;
	        }
	        var frameCount = this.getFrameCount();
	        if (frameCount > 0) {
	            return;
	        }
	        this.setFrameCount(1);
	        var bound = event.currentTarget.getBoundingClientRect();
	        var x;
	        var y;
	        // Check if we are handling a keyboard click.
	        if (event.clientX === 0 && event.clientY === 0) {
	            x = Math.round(bound.width / 2);
	            y = Math.round(bound.height / 2);
	        } else {
	            var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
	            var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
	            x = Math.round(clientX - bound.left);
	            y = Math.round(clientY - bound.top);
	        }
	        this.setRippleXY(x, y);
	        this.setRippleStyles(true);
	        window.requestAnimationFrame(this.animFrameHandler.bind(this));
	    }
	};
	/**
	   * Handle mouse / finger up on element.
	   *
	   * @param {Event} event The event that fired.
	   * @private
	   */
	MaterialRipple.prototype.upHandler_ = function (event) {
	    // Don't fire for the artificial "mouseup" generated by a double-click.
	    if (event && event.detail !== 2) {
	        // Allow a repaint to occur before removing this class, so the animation
	        // shows for tap events, which seem to trigger a mouseup too soon after
	        // mousedown.
	        window.setTimeout(function () {
	            this.rippleElement_.classList.remove(this.CssClasses_.IS_VISIBLE);
	        }.bind(this), 0);
	    }
	};
	/**
	   * Initialize element.
	   */
	MaterialRipple.prototype.init = function () {
	    if (this.element_) {
	        var recentering = this.element_.classList.contains(this.CssClasses_.RIPPLE_CENTER);
	        if (!this.element_.classList.contains(this.CssClasses_.RIPPLE_EFFECT_IGNORE_EVENTS)) {
	            this.rippleElement_ = this.element_.querySelector('.' + this.CssClasses_.RIPPLE);
	            this.frameCount_ = 0;
	            this.rippleSize_ = 0;
	            this.x_ = 0;
	            this.y_ = 0;
	            // Touch start produces a compat mouse down event, which would cause a
	            // second ripples. To avoid that, we use this property to ignore the first
	            // mouse down after a touch start.
	            this.ignoringMouseDown_ = false;
	            this.boundDownHandler = this.downHandler_.bind(this);
	            this.element_.addEventListener('mousedown', this.boundDownHandler);
	            this.element_.addEventListener('touchstart', this.boundDownHandler);
	            this.boundUpHandler = this.upHandler_.bind(this);
	            this.element_.addEventListener('mouseup', this.boundUpHandler);
	            this.element_.addEventListener('mouseleave', this.boundUpHandler);
	            this.element_.addEventListener('touchend', this.boundUpHandler);
	            this.element_.addEventListener('blur', this.boundUpHandler);
	            /**
	         * Getter for frameCount_.
	         * @return {number} the frame count.
	         */
	            this.getFrameCount = function () {
	                return this.frameCount_;
	            };
	            /**
	         * Setter for frameCount_.
	         * @param {number} fC the frame count.
	         */
	            this.setFrameCount = function (fC) {
	                this.frameCount_ = fC;
	            };
	            /**
	         * Getter for rippleElement_.
	         * @return {Element} the ripple element.
	         */
	            this.getRippleElement = function () {
	                return this.rippleElement_;
	            };
	            /**
	         * Sets the ripple X and Y coordinates.
	         * @param  {number} newX the new X coordinate
	         * @param  {number} newY the new Y coordinate
	         */
	            this.setRippleXY = function (newX, newY) {
	                this.x_ = newX;
	                this.y_ = newY;
	            };
	            /**
	         * Sets the ripple styles.
	         * @param  {boolean} start whether or not this is the start frame.
	         */
	            this.setRippleStyles = function (start) {
	                if (this.rippleElement_ !== null) {
	                    var transformString;
	                    var scale;
	                    var size;
	                    var offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';
	                    if (start) {
	                        scale = this.Constant_.INITIAL_SCALE;
	                        size = this.Constant_.INITIAL_SIZE;
	                    } else {
	                        scale = this.Constant_.FINAL_SCALE;
	                        size = this.rippleSize_ + 'px';
	                        if (recentering) {
	                            offset = 'translate(' + this.boundWidth / 2 + 'px, ' + this.boundHeight / 2 + 'px)';
	                        }
	                    }
	                    transformString = 'translate(-50%, -50%) ' + offset + scale;
	                    this.rippleElement_.style.webkitTransform = transformString;
	                    this.rippleElement_.style.msTransform = transformString;
	                    this.rippleElement_.style.transform = transformString;
	                    if (start) {
	                        this.rippleElement_.classList.remove(this.CssClasses_.IS_ANIMATING);
	                    } else {
	                        this.rippleElement_.classList.add(this.CssClasses_.IS_ANIMATING);
	                    }
	                }
	            };
	            /**
	         * Handles an animation frame.
	         */
	            this.animFrameHandler = function () {
	                if (this.frameCount_-- > 0) {
	                    window.requestAnimationFrame(this.animFrameHandler.bind(this));
	                } else {
	                    this.setRippleStyles(false);
	                }
	            };
	        }
	    }
	};
	// The component registers itself. It can assume componentHandler is available
	// in the global scope.
	componentHandler.register({
	    constructor: MaterialRipple,
	    classAsString: 'MaterialRipple',
	    cssClass: 'mdl-js-ripple-effect',
	    widget: false
	});
	}());


/***/ }),
/* 231 */
/*!*********************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/lib/event-manager.js ***!
  \*********************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	var EventElement = function EventElement(element) {
	  this.element = element;
	  this.events = {};
	};
	
	EventElement.prototype.bind = function (eventName, handler) {
	  if (typeof this.events[eventName] === 'undefined') {
	    this.events[eventName] = [];
	  }
	  this.events[eventName].push(handler);
	  this.element.addEventListener(eventName, handler, false);
	};
	
	EventElement.prototype.unbind = function (eventName, handler) {
	  var isHandlerProvided = typeof handler !== 'undefined';
	  this.events[eventName] = this.events[eventName].filter(function (hdlr) {
	    if (isHandlerProvided && hdlr !== handler) {
	      return true;
	    }
	    this.element.removeEventListener(eventName, hdlr, false);
	    return false;
	  }, this);
	};
	
	EventElement.prototype.unbindAll = function () {
	  for (var name in this.events) {
	    this.unbind(name);
	  }
	};
	
	var EventManager = function EventManager() {
	  this.eventElements = [];
	};
	
	EventManager.prototype.eventElement = function (element) {
	  var ee = this.eventElements.filter(function (eventElement) {
	    return eventElement.element === element;
	  })[0];
	  if (typeof ee === 'undefined') {
	    ee = new EventElement(element);
	    this.eventElements.push(ee);
	  }
	  return ee;
	};
	
	EventManager.prototype.bind = function (element, eventName, handler) {
	  this.eventElement(element).bind(eventName, handler);
	};
	
	EventManager.prototype.unbind = function (element, eventName, handler) {
	  this.eventElement(element).unbind(eventName, handler);
	};
	
	EventManager.prototype.unbindAll = function () {
	  for (var i = 0; i < this.eventElements.length; i++) {
	    this.eventElements[i].unbindAll();
	  }
	};
	
	EventManager.prototype.once = function (element, eventName, handler) {
	  var ee = this.eventElement(element);
	  var onceHandler = function onceHandler(e) {
	    ee.unbind(eventName, onceHandler);
	    handler(e);
	  };
	  ee.bind(eventName, onceHandler);
	};
	
	module.exports = EventManager;

/***/ }),
/* 232 */
/*!************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/lib/guid.js ***!
  \************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function () {
	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	  }
	  return function () {
	    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	  };
	}();

/***/ }),
/* 233 */
/*!********************************************!*\
  !*** ./~/perfect-scrollbar/src/js/main.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var destroy = __webpack_require__(/*! ./plugin/destroy */ 235);
	var initialize = __webpack_require__(/*! ./plugin/initialize */ 243);
	var update = __webpack_require__(/*! ./plugin/update */ 244);
	
	module.exports = {
	  initialize: initialize,
	  update: update,
	  destroy: destroy
	};

/***/ }),
/* 234 */
/*!**************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/default-setting.js ***!
  \**************************************************************/
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = {
	  handlers: ['click-rail', 'drag-scrollbar', 'keyboard', 'wheel', 'touch'],
	  maxScrollbarLength: null,
	  minScrollbarLength: null,
	  scrollXMarginOffset: 0,
	  scrollYMarginOffset: 0,
	  suppressScrollX: false,
	  suppressScrollY: false,
	  swipePropagation: true,
	  useBothWheelAxes: false,
	  wheelPropagation: false,
	  wheelSpeed: 1,
	  theme: 'default'
	};

/***/ }),
/* 235 */
/*!******************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/destroy.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../lib/helper */ 17);
	var dom = __webpack_require__(/*! ../lib/dom */ 24);
	var instances = __webpack_require__(/*! ./instances */ 15);
	
	module.exports = function (element) {
	  var i = instances.get(element);
	
	  if (!i) {
	    return;
	  }
	
	  i.event.unbindAll();
	  dom.remove(i.scrollbarX);
	  dom.remove(i.scrollbarY);
	  dom.remove(i.scrollbarXRail);
	  dom.remove(i.scrollbarYRail);
	  _.removePsClasses(element);
	
	  instances.remove(element);
	};

/***/ }),
/* 236 */
/*!*****************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/handler/click-rail.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var instances = __webpack_require__(/*! ../instances */ 15);
	var updateGeometry = __webpack_require__(/*! ../update-geometry */ 18);
	var updateScroll = __webpack_require__(/*! ../update-scroll */ 20);
	
	function bindClickRailHandler(element, i) {
	  function pageOffset(el) {
	    return el.getBoundingClientRect();
	  }
	  var stopPropagation = function stopPropagation(e) {
	    e.stopPropagation();
	  };
	
	  i.event.bind(i.scrollbarY, 'click', stopPropagation);
	  i.event.bind(i.scrollbarYRail, 'click', function (e) {
	    var positionTop = e.pageY - window.pageYOffset - pageOffset(i.scrollbarYRail).top;
	    var direction = positionTop > i.scrollbarYTop ? 1 : -1;
	
	    updateScroll(element, 'top', element.scrollTop + direction * i.containerHeight);
	    updateGeometry(element);
	
	    e.stopPropagation();
	  });
	
	  i.event.bind(i.scrollbarX, 'click', stopPropagation);
	  i.event.bind(i.scrollbarXRail, 'click', function (e) {
	    var positionLeft = e.pageX - window.pageXOffset - pageOffset(i.scrollbarXRail).left;
	    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
	
	    updateScroll(element, 'left', element.scrollLeft + direction * i.containerWidth);
	    updateGeometry(element);
	
	    e.stopPropagation();
	  });
	}
	
	module.exports = function (element) {
	  var i = instances.get(element);
	  bindClickRailHandler(element, i);
	};

/***/ }),
/* 237 */
/*!*********************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/handler/drag-scrollbar.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../../lib/helper */ 17);
	var dom = __webpack_require__(/*! ../../lib/dom */ 24);
	var instances = __webpack_require__(/*! ../instances */ 15);
	var updateGeometry = __webpack_require__(/*! ../update-geometry */ 18);
	var updateScroll = __webpack_require__(/*! ../update-scroll */ 20);
	
	function bindMouseScrollXHandler(element, i) {
	  var currentLeft = null;
	  var currentPageX = null;
	
	  function updateScrollLeft(deltaX) {
	    var newLeft = currentLeft + deltaX * i.railXRatio;
	    var maxLeft = Math.max(0, i.scrollbarXRail.getBoundingClientRect().left) + i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
	
	    if (newLeft < 0) {
	      i.scrollbarXLeft = 0;
	    } else if (newLeft > maxLeft) {
	      i.scrollbarXLeft = maxLeft;
	    } else {
	      i.scrollbarXLeft = newLeft;
	    }
	
	    var scrollLeft = _.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - i.railXRatio * i.scrollbarXWidth)) - i.negativeScrollAdjustment;
	    updateScroll(element, 'left', scrollLeft);
	  }
	
	  var mouseMoveHandler = function mouseMoveHandler(e) {
	    updateScrollLeft(e.pageX - currentPageX);
	    updateGeometry(element);
	    e.stopPropagation();
	    e.preventDefault();
	  };
	
	  var mouseUpHandler = function mouseUpHandler() {
	    _.stopScrolling(element, 'x');
	    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	  };
	
	  i.event.bind(i.scrollbarX, 'mousedown', function (e) {
	    currentPageX = e.pageX;
	    currentLeft = _.toInt(dom.css(i.scrollbarX, 'left')) * i.railXRatio;
	    _.startScrolling(element, 'x');
	
	    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);
	
	    e.stopPropagation();
	    e.preventDefault();
	  });
	}
	
	function bindMouseScrollYHandler(element, i) {
	  var currentTop = null;
	  var currentPageY = null;
	
	  function updateScrollTop(deltaY) {
	    var newTop = currentTop + deltaY * i.railYRatio;
	    var maxTop = Math.max(0, i.scrollbarYRail.getBoundingClientRect().top) + i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
	
	    if (newTop < 0) {
	      i.scrollbarYTop = 0;
	    } else if (newTop > maxTop) {
	      i.scrollbarYTop = maxTop;
	    } else {
	      i.scrollbarYTop = newTop;
	    }
	
	    var scrollTop = _.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - i.railYRatio * i.scrollbarYHeight));
	    updateScroll(element, 'top', scrollTop);
	  }
	
	  var mouseMoveHandler = function mouseMoveHandler(e) {
	    updateScrollTop(e.pageY - currentPageY);
	    updateGeometry(element);
	    e.stopPropagation();
	    e.preventDefault();
	  };
	
	  var mouseUpHandler = function mouseUpHandler() {
	    _.stopScrolling(element, 'y');
	    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	  };
	
	  i.event.bind(i.scrollbarY, 'mousedown', function (e) {
	    currentPageY = e.pageY;
	    currentTop = _.toInt(dom.css(i.scrollbarY, 'top')) * i.railYRatio;
	    _.startScrolling(element, 'y');
	
	    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);
	
	    e.stopPropagation();
	    e.preventDefault();
	  });
	}
	
	module.exports = function (element) {
	  var i = instances.get(element);
	  bindMouseScrollXHandler(element, i);
	  bindMouseScrollYHandler(element, i);
	};

/***/ }),
/* 238 */
/*!***************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/handler/keyboard.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../../lib/helper */ 17);
	var dom = __webpack_require__(/*! ../../lib/dom */ 24);
	var instances = __webpack_require__(/*! ../instances */ 15);
	var updateGeometry = __webpack_require__(/*! ../update-geometry */ 18);
	var updateScroll = __webpack_require__(/*! ../update-scroll */ 20);
	
	function bindKeyboardHandler(element, i) {
	  var hovered = false;
	  i.event.bind(element, 'mouseenter', function () {
	    hovered = true;
	  });
	  i.event.bind(element, 'mouseleave', function () {
	    hovered = false;
	  });
	
	  var shouldPrevent = false;
	  function shouldPreventDefault(deltaX, deltaY) {
	    var scrollTop = element.scrollTop;
	    if (deltaX === 0) {
	      if (!i.scrollbarYActive) {
	        return false;
	      }
	      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
	        return !i.settings.wheelPropagation;
	      }
	    }
	
	    var scrollLeft = element.scrollLeft;
	    if (deltaY === 0) {
	      if (!i.scrollbarXActive) {
	        return false;
	      }
	      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
	        return !i.settings.wheelPropagation;
	      }
	    }
	    return true;
	  }
	
	  i.event.bind(i.ownerDocument, 'keydown', function (e) {
	    if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
	      return;
	    }
	
	    var focused = dom.matches(i.scrollbarX, ':focus') || dom.matches(i.scrollbarY, ':focus');
	
	    if (!hovered && !focused) {
	      return;
	    }
	
	    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
	    if (activeElement) {
	      if (activeElement.tagName === 'IFRAME') {
	        activeElement = activeElement.contentDocument.activeElement;
	      } else {
	        // go deeper if element is a webcomponent
	        while (activeElement.shadowRoot) {
	          activeElement = activeElement.shadowRoot.activeElement;
	        }
	      }
	      if (_.isEditable(activeElement)) {
	        return;
	      }
	    }
	
	    var deltaX = 0;
	    var deltaY = 0;
	
	    switch (e.which) {
	      case 37:
	        // left
	        if (e.metaKey) {
	          deltaX = -i.contentWidth;
	        } else if (e.altKey) {
	          deltaX = -i.containerWidth;
	        } else {
	          deltaX = -30;
	        }
	        break;
	      case 38:
	        // up
	        if (e.metaKey) {
	          deltaY = i.contentHeight;
	        } else if (e.altKey) {
	          deltaY = i.containerHeight;
	        } else {
	          deltaY = 30;
	        }
	        break;
	      case 39:
	        // right
	        if (e.metaKey) {
	          deltaX = i.contentWidth;
	        } else if (e.altKey) {
	          deltaX = i.containerWidth;
	        } else {
	          deltaX = 30;
	        }
	        break;
	      case 40:
	        // down
	        if (e.metaKey) {
	          deltaY = -i.contentHeight;
	        } else if (e.altKey) {
	          deltaY = -i.containerHeight;
	        } else {
	          deltaY = -30;
	        }
	        break;
	      case 33:
	        // page up
	        deltaY = 90;
	        break;
	      case 32:
	        // space bar
	        if (e.shiftKey) {
	          deltaY = 90;
	        } else {
	          deltaY = -90;
	        }
	        break;
	      case 34:
	        // page down
	        deltaY = -90;
	        break;
	      case 35:
	        // end
	        if (e.ctrlKey) {
	          deltaY = -i.contentHeight;
	        } else {
	          deltaY = -i.containerHeight;
	        }
	        break;
	      case 36:
	        // home
	        if (e.ctrlKey) {
	          deltaY = element.scrollTop;
	        } else {
	          deltaY = i.containerHeight;
	        }
	        break;
	      default:
	        return;
	    }
	
	    updateScroll(element, 'top', element.scrollTop - deltaY);
	    updateScroll(element, 'left', element.scrollLeft + deltaX);
	    updateGeometry(element);
	
	    shouldPrevent = shouldPreventDefault(deltaX, deltaY);
	    if (shouldPrevent) {
	      e.preventDefault();
	    }
	  });
	}
	
	module.exports = function (element) {
	  var i = instances.get(element);
	  bindKeyboardHandler(element, i);
	};

/***/ }),
/* 239 */
/*!******************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/handler/mouse-wheel.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var instances = __webpack_require__(/*! ../instances */ 15);
	var updateGeometry = __webpack_require__(/*! ../update-geometry */ 18);
	var updateScroll = __webpack_require__(/*! ../update-scroll */ 20);
	
	function bindMouseWheelHandler(element, i) {
	  var shouldPrevent = false;
	
	  function shouldPreventDefault(deltaX, deltaY) {
	    var scrollTop = element.scrollTop;
	    if (deltaX === 0) {
	      if (!i.scrollbarYActive) {
	        return false;
	      }
	      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
	        return !i.settings.wheelPropagation;
	      }
	    }
	
	    var scrollLeft = element.scrollLeft;
	    if (deltaY === 0) {
	      if (!i.scrollbarXActive) {
	        return false;
	      }
	      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
	        return !i.settings.wheelPropagation;
	      }
	    }
	    return true;
	  }
	
	  function getDeltaFromEvent(e) {
	    var deltaX = e.deltaX;
	    var deltaY = -1 * e.deltaY;
	
	    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
	      // OS X Safari
	      deltaX = -1 * e.wheelDeltaX / 6;
	      deltaY = e.wheelDeltaY / 6;
	    }
	
	    if (e.deltaMode && e.deltaMode === 1) {
	      // Firefox in deltaMode 1: Line scrolling
	      deltaX *= 10;
	      deltaY *= 10;
	    }
	
	    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {
	        // IE in some mouse drivers
	        deltaX = 0;
	        deltaY = e.wheelDelta;
	      }
	
	    if (e.shiftKey) {
	      // reverse axis with shift key
	      return [-deltaY, -deltaX];
	    }
	    return [deltaX, deltaY];
	  }
	
	  function shouldBeConsumedByChild(deltaX, deltaY) {
	    var child = element.querySelector('textarea:hover, select[multiple]:hover, .ps-child:hover');
	    if (child) {
	      if (!window.getComputedStyle(child).overflow.match(/(scroll|auto)/)) {
	        // if not scrollable
	        return false;
	      }
	
	      var maxScrollTop = child.scrollHeight - child.clientHeight;
	      if (maxScrollTop > 0) {
	        if (!(child.scrollTop === 0 && deltaY > 0) && !(child.scrollTop === maxScrollTop && deltaY < 0)) {
	          return true;
	        }
	      }
	      var maxScrollLeft = child.scrollLeft - child.clientWidth;
	      if (maxScrollLeft > 0) {
	        if (!(child.scrollLeft === 0 && deltaX < 0) && !(child.scrollLeft === maxScrollLeft && deltaX > 0)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	
	  function mousewheelHandler(e) {
	    var delta = getDeltaFromEvent(e);
	
	    var deltaX = delta[0];
	    var deltaY = delta[1];
	
	    if (shouldBeConsumedByChild(deltaX, deltaY)) {
	      return;
	    }
	
	    shouldPrevent = false;
	    if (!i.settings.useBothWheelAxes) {
	      // deltaX will only be used for horizontal scrolling and deltaY will
	      // only be used for vertical scrolling - this is the default
	      updateScroll(element, 'top', element.scrollTop - deltaY * i.settings.wheelSpeed);
	      updateScroll(element, 'left', element.scrollLeft + deltaX * i.settings.wheelSpeed);
	    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
	      // only vertical scrollbar is active and useBothWheelAxes option is
	      // active, so let's scroll vertical bar using both mouse wheel axes
	      if (deltaY) {
	        updateScroll(element, 'top', element.scrollTop - deltaY * i.settings.wheelSpeed);
	      } else {
	        updateScroll(element, 'top', element.scrollTop + deltaX * i.settings.wheelSpeed);
	      }
	      shouldPrevent = true;
	    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
	      // useBothWheelAxes and only horizontal bar is active, so use both
	      // wheel axes for horizontal bar
	      if (deltaX) {
	        updateScroll(element, 'left', element.scrollLeft + deltaX * i.settings.wheelSpeed);
	      } else {
	        updateScroll(element, 'left', element.scrollLeft - deltaY * i.settings.wheelSpeed);
	      }
	      shouldPrevent = true;
	    }
	
	    updateGeometry(element);
	
	    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
	    if (shouldPrevent) {
	      e.stopPropagation();
	      e.preventDefault();
	    }
	  }
	
	  if (typeof window.onwheel !== "undefined") {
	    i.event.bind(element, 'wheel', mousewheelHandler);
	  } else if (typeof window.onmousewheel !== "undefined") {
	    i.event.bind(element, 'mousewheel', mousewheelHandler);
	  }
	}
	
	module.exports = function (element) {
	  var i = instances.get(element);
	  bindMouseWheelHandler(element, i);
	};

/***/ }),
/* 240 */
/*!********************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/handler/native-scroll.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var instances = __webpack_require__(/*! ../instances */ 15);
	var updateGeometry = __webpack_require__(/*! ../update-geometry */ 18);
	
	function bindNativeScrollHandler(element, i) {
	  i.event.bind(element, 'scroll', function () {
	    updateGeometry(element);
	  });
	}
	
	module.exports = function (element) {
	  var i = instances.get(element);
	  bindNativeScrollHandler(element, i);
	};

/***/ }),
/* 241 */
/*!****************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/handler/selection.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../../lib/helper */ 17);
	var instances = __webpack_require__(/*! ../instances */ 15);
	var updateGeometry = __webpack_require__(/*! ../update-geometry */ 18);
	var updateScroll = __webpack_require__(/*! ../update-scroll */ 20);
	
	function bindSelectionHandler(element, i) {
	  function getRangeNode() {
	    var selection = window.getSelection ? window.getSelection() : document.getSelection ? document.getSelection() : '';
	    if (selection.toString().length === 0) {
	      return null;
	    } else {
	      return selection.getRangeAt(0).commonAncestorContainer;
	    }
	  }
	
	  var scrollingLoop = null;
	  var scrollDiff = { top: 0, left: 0 };
	  function startScrolling() {
	    if (!scrollingLoop) {
	      scrollingLoop = setInterval(function () {
	        if (!instances.get(element)) {
	          clearInterval(scrollingLoop);
	          return;
	        }
	
	        updateScroll(element, 'top', element.scrollTop + scrollDiff.top);
	        updateScroll(element, 'left', element.scrollLeft + scrollDiff.left);
	        updateGeometry(element);
	      }, 50); // every .1 sec
	    }
	  }
	  function stopScrolling() {
	    if (scrollingLoop) {
	      clearInterval(scrollingLoop);
	      scrollingLoop = null;
	    }
	    _.stopScrolling(element);
	  }
	
	  var isSelected = false;
	  i.event.bind(i.ownerDocument, 'selectionchange', function () {
	    if (element.contains(getRangeNode())) {
	      isSelected = true;
	    } else {
	      isSelected = false;
	      stopScrolling();
	    }
	  });
	  i.event.bind(window, 'mouseup', function () {
	    if (isSelected) {
	      isSelected = false;
	      stopScrolling();
	    }
	  });
	  i.event.bind(window, 'keyup', function () {
	    if (isSelected) {
	      isSelected = false;
	      stopScrolling();
	    }
	  });
	
	  i.event.bind(window, 'mousemove', function (e) {
	    if (isSelected) {
	      var mousePosition = { x: e.pageX, y: e.pageY };
	      var containerGeometry = {
	        left: element.offsetLeft,
	        right: element.offsetLeft + element.offsetWidth,
	        top: element.offsetTop,
	        bottom: element.offsetTop + element.offsetHeight
	      };
	
	      if (mousePosition.x < containerGeometry.left + 3) {
	        scrollDiff.left = -5;
	        _.startScrolling(element, 'x');
	      } else if (mousePosition.x > containerGeometry.right - 3) {
	        scrollDiff.left = 5;
	        _.startScrolling(element, 'x');
	      } else {
	        scrollDiff.left = 0;
	      }
	
	      if (mousePosition.y < containerGeometry.top + 3) {
	        if (containerGeometry.top + 3 - mousePosition.y < 5) {
	          scrollDiff.top = -5;
	        } else {
	          scrollDiff.top = -20;
	        }
	        _.startScrolling(element, 'y');
	      } else if (mousePosition.y > containerGeometry.bottom - 3) {
	        if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
	          scrollDiff.top = 5;
	        } else {
	          scrollDiff.top = 20;
	        }
	        _.startScrolling(element, 'y');
	      } else {
	        scrollDiff.top = 0;
	      }
	
	      if (scrollDiff.top === 0 && scrollDiff.left === 0) {
	        stopScrolling();
	      } else {
	        startScrolling();
	      }
	    }
	  });
	}
	
	module.exports = function (element) {
	  var i = instances.get(element);
	  bindSelectionHandler(element, i);
	};

/***/ }),
/* 242 */
/*!************************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/handler/touch.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../../lib/helper */ 17);
	var instances = __webpack_require__(/*! ../instances */ 15);
	var updateGeometry = __webpack_require__(/*! ../update-geometry */ 18);
	var updateScroll = __webpack_require__(/*! ../update-scroll */ 20);
	
	function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
	  function shouldPreventDefault(deltaX, deltaY) {
	    var scrollTop = element.scrollTop;
	    var scrollLeft = element.scrollLeft;
	    var magnitudeX = Math.abs(deltaX);
	    var magnitudeY = Math.abs(deltaY);
	
	    if (magnitudeY > magnitudeX) {
	      // user is perhaps trying to swipe up/down the page
	
	      if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
	        return !i.settings.swipePropagation;
	      }
	    } else if (magnitudeX > magnitudeY) {
	      // user is perhaps trying to swipe left/right across the page
	
	      if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
	        return !i.settings.swipePropagation;
	      }
	    }
	
	    return true;
	  }
	
	  function applyTouchMove(differenceX, differenceY) {
	    updateScroll(element, 'top', element.scrollTop - differenceY);
	    updateScroll(element, 'left', element.scrollLeft - differenceX);
	
	    updateGeometry(element);
	  }
	
	  var startOffset = {};
	  var startTime = 0;
	  var speed = {};
	  var easingLoop = null;
	  var inGlobalTouch = false;
	  var inLocalTouch = false;
	
	  function globalTouchStart() {
	    inGlobalTouch = true;
	  }
	  function globalTouchEnd() {
	    inGlobalTouch = false;
	  }
	
	  function getTouch(e) {
	    if (e.targetTouches) {
	      return e.targetTouches[0];
	    } else {
	      // Maybe IE pointer
	      return e;
	    }
	  }
	  function shouldHandle(e) {
	    if (e.targetTouches && e.targetTouches.length === 1) {
	      return true;
	    }
	    if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
	      return true;
	    }
	    return false;
	  }
	  function touchStart(e) {
	    if (shouldHandle(e)) {
	      inLocalTouch = true;
	
	      var touch = getTouch(e);
	
	      startOffset.pageX = touch.pageX;
	      startOffset.pageY = touch.pageY;
	
	      startTime = new Date().getTime();
	
	      if (easingLoop !== null) {
	        clearInterval(easingLoop);
	      }
	
	      e.stopPropagation();
	    }
	  }
	  function touchMove(e) {
	    if (!inLocalTouch && i.settings.swipePropagation) {
	      touchStart(e);
	    }
	    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
	      var touch = getTouch(e);
	
	      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };
	
	      var differenceX = currentOffset.pageX - startOffset.pageX;
	      var differenceY = currentOffset.pageY - startOffset.pageY;
	
	      applyTouchMove(differenceX, differenceY);
	      startOffset = currentOffset;
	
	      var currentTime = new Date().getTime();
	
	      var timeGap = currentTime - startTime;
	      if (timeGap > 0) {
	        speed.x = differenceX / timeGap;
	        speed.y = differenceY / timeGap;
	        startTime = currentTime;
	      }
	
	      if (shouldPreventDefault(differenceX, differenceY)) {
	        e.stopPropagation();
	        e.preventDefault();
	      }
	    }
	  }
	  function touchEnd() {
	    if (!inGlobalTouch && inLocalTouch) {
	      inLocalTouch = false;
	
	      clearInterval(easingLoop);
	      easingLoop = setInterval(function () {
	        if (!instances.get(element)) {
	          clearInterval(easingLoop);
	          return;
	        }
	
	        if (!speed.x && !speed.y) {
	          clearInterval(easingLoop);
	          return;
	        }
	
	        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
	          clearInterval(easingLoop);
	          return;
	        }
	
	        applyTouchMove(speed.x * 30, speed.y * 30);
	
	        speed.x *= 0.8;
	        speed.y *= 0.8;
	      }, 10);
	    }
	  }
	
	  if (supportsTouch) {
	    i.event.bind(window, 'touchstart', globalTouchStart);
	    i.event.bind(window, 'touchend', globalTouchEnd);
	    i.event.bind(element, 'touchstart', touchStart);
	    i.event.bind(element, 'touchmove', touchMove);
	    i.event.bind(element, 'touchend', touchEnd);
	  } else if (supportsIePointer) {
	    if (window.PointerEvent) {
	      i.event.bind(window, 'pointerdown', globalTouchStart);
	      i.event.bind(window, 'pointerup', globalTouchEnd);
	      i.event.bind(element, 'pointerdown', touchStart);
	      i.event.bind(element, 'pointermove', touchMove);
	      i.event.bind(element, 'pointerup', touchEnd);
	    } else if (window.MSPointerEvent) {
	      i.event.bind(window, 'MSPointerDown', globalTouchStart);
	      i.event.bind(window, 'MSPointerUp', globalTouchEnd);
	      i.event.bind(element, 'MSPointerDown', touchStart);
	      i.event.bind(element, 'MSPointerMove', touchMove);
	      i.event.bind(element, 'MSPointerUp', touchEnd);
	    }
	  }
	}
	
	module.exports = function (element) {
	  if (!_.env.supportsTouch && !_.env.supportsIePointer) {
	    return;
	  }
	
	  var i = instances.get(element);
	  bindTouchHandler(element, i, _.env.supportsTouch, _.env.supportsIePointer);
	};

/***/ }),
/* 243 */
/*!*********************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/initialize.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _ = __webpack_require__(/*! ../lib/helper */ 17);
	var cls = __webpack_require__(/*! ../lib/class */ 49);
	var instances = __webpack_require__(/*! ./instances */ 15);
	var updateGeometry = __webpack_require__(/*! ./update-geometry */ 18);
	
	// Handlers
	var handlers = {
	  'click-rail': __webpack_require__(/*! ./handler/click-rail */ 236),
	  'drag-scrollbar': __webpack_require__(/*! ./handler/drag-scrollbar */ 237),
	  'keyboard': __webpack_require__(/*! ./handler/keyboard */ 238),
	  'wheel': __webpack_require__(/*! ./handler/mouse-wheel */ 239),
	  'touch': __webpack_require__(/*! ./handler/touch */ 242),
	  'selection': __webpack_require__(/*! ./handler/selection */ 241)
	};
	var nativeScrollHandler = __webpack_require__(/*! ./handler/native-scroll */ 240);
	
	module.exports = function (element, userSettings) {
	  userSettings = (typeof userSettings === 'undefined' ? 'undefined' : _typeof(userSettings)) === 'object' ? userSettings : {};
	
	  cls.add(element, 'ps-container');
	
	  // Create a plugin instance.
	  var i = instances.add(element);
	
	  i.settings = _.extend(i.settings, userSettings);
	  cls.add(element, 'ps-theme-' + i.settings.theme);
	
	  i.settings.handlers.forEach(function (handlerName) {
	    handlers[handlerName](element);
	  });
	
	  nativeScrollHandler(element);
	
	  updateGeometry(element);
	};

/***/ }),
/* 244 */
/*!*****************************************************!*\
  !*** ./~/perfect-scrollbar/src/js/plugin/update.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! ../lib/helper */ 17);
	var dom = __webpack_require__(/*! ../lib/dom */ 24);
	var instances = __webpack_require__(/*! ./instances */ 15);
	var updateGeometry = __webpack_require__(/*! ./update-geometry */ 18);
	var updateScroll = __webpack_require__(/*! ./update-scroll */ 20);
	
	module.exports = function (element) {
	  var i = instances.get(element);
	
	  if (!i) {
	    return;
	  }
	
	  // Recalcuate negative scrollLeft adjustment
	  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
	
	  // Recalculate rail margins
	  dom.css(i.scrollbarXRail, 'display', 'block');
	  dom.css(i.scrollbarYRail, 'display', 'block');
	  i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
	  i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));
	
	  // Hide scrollbars not to affect scrollWidth and scrollHeight
	  dom.css(i.scrollbarXRail, 'display', 'none');
	  dom.css(i.scrollbarYRail, 'display', 'none');
	
	  updateGeometry(element);
	
	  // Update top/left scroll to trigger events
	  updateScroll(element, 'top', element.scrollTop);
	  updateScroll(element, 'left', element.scrollLeft);
	
	  dom.css(i.scrollbarXRail, 'display', '');
	  dom.css(i.scrollbarYRail, 'display', '');
	};

/***/ }),
/* 245 */,
/* 246 */
/*!****************************************!*\
  !*** ./~/prop-types/checkPropTypes.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	if (true) {
	  var invariant = __webpack_require__(/*! fbjs/lib/invariant */ 65);
	  var warning = __webpack_require__(/*! fbjs/lib/warning */ 66);
	  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ 124);
	  var loggedTypeFailures = {};
	}
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (true) {
	    for (var typeSpecName in typeSpecs) {
	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	
	          var stack = getStack ? getStack() : '';
	
	          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	        }
	      }
	    }
	  }
	}
	
	module.exports = checkPropTypes;

/***/ }),
/* 247 */
/*!*************************************************!*\
  !*** ./~/prop-types/factoryWithTypeCheckers.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ 112);
	var invariant = __webpack_require__(/*! fbjs/lib/invariant */ 65);
	var warning = __webpack_require__(/*! fbjs/lib/warning */ 66);
	
	var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ 124);
	var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ 246);
	
	module.exports = function (isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */
	
	  var ANONYMOUS = '<<anonymous>>';
	
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),
	
	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker
	  };
	
	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/
	
	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;
	
	  function createChainableTypeChecker(validate) {
	    if (true) {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;
	
	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
	        } else if (("development") !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (!manualPropTypeCallCache[cacheKey] &&
	          // Avoid spamming the console because they are often not actionable except for lib authors
	          manualPropTypeWarningCount < 3) {
	            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }
	
	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);
	
	    return chainedCheckType;
	  }
	
	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);
	
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	  }
	
	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }
	
	      var valuesString = JSON.stringify(expectedValues);
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (propValue.hasOwnProperty(key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunction.thatReturnsNull;
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }
	
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function isNode(propValue) {
	    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }
	
	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }
	
	        return true;
	      default:
	        return false;
	    }
	  }
	
	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }
	
	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }
	
	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }
	
	    return false;
	  }
	
	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }
	
	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }
	
	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }
	
	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};

/***/ }),
/* 248 */
/*!****************************************!*\
  !*** ./~/react-mdl/lib/Badge/index.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    children: _react.PropTypes.oneOfType([_react.PropTypes.element, _react.PropTypes.string]),
	    className: _react.PropTypes.string,
	    text: _react.PropTypes.oneOfType([_react2.default.PropTypes.string, _react2.default.PropTypes.number]),
	    overlap: _react.PropTypes.bool,
	    noBackground: _react.PropTypes.bool
	};
	
	var Badge = function Badge(props) {
	    var children = props.children,
	        className = props.className,
	        text = props.text,
	        overlap = props.overlap,
	        noBackground = props.noBackground,
	        rest = _objectWithoutProperties(props, ['children', 'className', 'text', 'overlap', 'noBackground']);
	
	    // No badge if no children
	    // TODO: In React 15, we can return null instead
	
	
	    if (!_react2.default.Children.count(children)) return _react2.default.createElement('noscript', null);
	
	    var element = typeof children === 'string' ? _react2.default.createElement('span', null, children) : _react2.default.Children.only(children);
	
	    // No text -> No need of badge
	    if (text === null || typeof text === 'undefined') return element;
	
	    return _react2.default.cloneElement(element, _extends({}, rest, {
	        className: (0, _classnames2.default)(className, element.props.className, 'mdl-badge', {
	            'mdl-badge--overlap': !!overlap,
	            'mdl-badge--no-background': !!noBackground
	        }),
	        'data-badge': text
	    }));
	};
	
	Badge.propTypes = propTypes;
	
	exports.default = Badge;

/***/ }),
/* 249 */
/*!**************************************!*\
  !*** ./~/react-mdl/lib/Card/Card.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _clamp = __webpack_require__(/*! clamp */ 43);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _shadows = __webpack_require__(/*! ../utils/shadows */ 52);
	
	var _shadows2 = _interopRequireDefault(_shadows);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    shadow: _react.PropTypes.number
	};
	
	var Card = function Card(props) {
	    var className = props.className,
	        shadow = props.shadow,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'shadow', 'children']);
	
	    var hasShadow = typeof shadow !== 'undefined';
	    var shadowLevel = (0, _clamp2.default)(shadow || 0, 0, _shadows2.default.length - 1);
	
	    var classes = (0, _classnames2.default)('mdl-card', _defineProperty({}, _shadows2.default[shadowLevel], hasShadow), className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), children);
	};
	
	Card.propTypes = propTypes;
	
	exports.default = Card;

/***/ }),
/* 250 */
/*!*********************************************!*\
  !*** ./~/react-mdl/lib/Card/CardActions.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    border: _react.PropTypes.bool,
	    className: _react.PropTypes.string
	};
	
	var CardActions = function CardActions(props) {
	    var className = props.className,
	        border = props.border,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'border', 'children']);
	
	    var classes = (0, _classnames2.default)('mdl-card__actions', {
	        'mdl-card--border': border
	    }, className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), children);
	};
	
	CardActions.propTypes = propTypes;
	
	exports.default = CardActions;

/***/ }),
/* 251 */
/*!*******************************************!*\
  !*** ./~/react-mdl/lib/Card/CardTitle.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    expand: _react.PropTypes.bool
	};
	
	var CardTitle = function CardTitle(props) {
	    var className = props.className,
	        children = props.children,
	        expand = props.expand,
	        otherProps = _objectWithoutProperties(props, ['className', 'children', 'expand']);
	
	    var classes = (0, _classnames2.default)('mdl-card__title', {
	        'mdl-card--expand': expand
	    }, className);
	
	    var title = typeof children === 'string' ? _react2.default.createElement('h2', { className: 'mdl-card__title-text' }, children) : children;
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), title);
	};
	
	CardTitle.propTypes = propTypes;
	
	exports.default = CardTitle;

/***/ }),
/* 252 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/Card/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CardMedia = exports.CardActions = exports.CardTitle = exports.CardMenu = exports.CardText = exports.Card = undefined;
	
	var _Card = __webpack_require__(/*! ./Card */ 249);
	
	Object.defineProperty(exports, 'Card', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Card).default;
	  }
	});
	
	var _CardTitle = __webpack_require__(/*! ./CardTitle */ 251);
	
	Object.defineProperty(exports, 'CardTitle', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_CardTitle).default;
	  }
	});
	
	var _CardActions = __webpack_require__(/*! ./CardActions */ 250);
	
	Object.defineProperty(exports, 'CardActions', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_CardActions).default;
	  }
	});
	
	var _basicClassCreator = __webpack_require__(/*! ../utils/basicClassCreator */ 28);
	
	var _basicClassCreator2 = _interopRequireDefault(_basicClassCreator);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var CardText = exports.CardText = (0, _basicClassCreator2.default)('CardText', 'mdl-card__supporting-text');
	var CardMenu = exports.CardMenu = (0, _basicClassCreator2.default)('CardMenu', 'mdl-card__menu');
	var CardMedia = exports.CardMedia = (0, _basicClassCreator2.default)('CardMedia', 'mdl-card__media');

/***/ }),
/* 253 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/Chip/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Chip = exports.ChipText = exports.ChipContact = undefined;
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _basicClassCreator = __webpack_require__(/*! ../utils/basicClassCreator */ 28);
	
	var _basicClassCreator2 = _interopRequireDefault(_basicClassCreator);
	
	var _Icon = __webpack_require__(/*! ../Icon */ 37);
	
	var _Icon2 = _interopRequireDefault(_Icon);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    onClick: _react.PropTypes.func,
	    onClose: _react.PropTypes.func
	};
	
	var ChipContact = exports.ChipContact = (0, _basicClassCreator2.default)('ChipContact', 'mdl-chip__contact', 'span');
	var ChipText = exports.ChipText = (0, _basicClassCreator2.default)('ChipText', 'mdl-chip__text', 'span');
	
	var Chip = exports.Chip = function Chip(props) {
	    var className = props.className,
	        onClick = props.onClick,
	        onClose = props.onClose,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'onClick', 'onClose', 'children']);
	
	    var childrenArray = _react2.default.Children.toArray(children);
	    var contactIndex = childrenArray.findIndex(function (c) {
	        return c.type === ChipContact;
	    });
	
	    var chipContent = [];
	
	    if (contactIndex >= 0) {
	        chipContent.push(childrenArray[contactIndex], _react2.default.createElement(ChipText, { key: 'text' }, childrenArray.slice(0, contactIndex).concat(childrenArray.slice(contactIndex + 1))));
	    } else {
	        chipContent.push(_react2.default.createElement(ChipText, { key: 'text' }, children));
	    }
	
	    if (onClose) {
	        chipContent.push(_react2.default.createElement('button', { key: 'btn', type: 'button', className: 'mdl-chip__action', onClick: onClose }, _react2.default.createElement(_Icon2.default, { name: 'cancel' })));
	    }
	
	    var elt = onClick ? 'button' : 'span';
	
	    return _react2.default.createElement(elt, _extends({
	        className: (0, _classnames2.default)('mdl-chip', {
	            'mdl-chip--contact': contactIndex > -1,
	            'mdl-chip--deletable': !!onClose
	        }, className),
	        type: onClick ? 'button' : null,
	        onClick: onClick
	    }, otherProps), chipContent);
	};
	
	Chip.propTypes = propTypes;

/***/ }),
/* 254 */
/*!*************************************************!*\
  !*** ./~/react-mdl/lib/DataTable/Selectable.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _lodash = __webpack_require__(/*! lodash.isequal */ 228);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _TableHeader = __webpack_require__(/*! ./TableHeader */ 50);
	
	var _TableHeader2 = _interopRequireDefault(_TableHeader);
	
	var _Checkbox = __webpack_require__(/*! ../Checkbox */ 125);
	
	var _Checkbox2 = _interopRequireDefault(_Checkbox);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    columns: function columns(props, propName, componentName) {
	        return props[propName] && new Error(componentName + ': `' + propName + '` is deprecated, please use the component `TableHeader` instead.');
	    },
	    data: function data(props, propName, componentName) {
	        return props[propName] && new Error(componentName + ': `' + propName + '` is deprecated, please use `rows` instead. `' + propName + '` will be removed in the next major release.');
	    },
	    onSelectionChanged: _react.PropTypes.func,
	    rowKeyColumn: _react.PropTypes.string,
	    rows: _react.PropTypes.arrayOf(_react.PropTypes.object).isRequired,
	    selectable: _react.PropTypes.bool
	};
	
	var defaultProps = {
	    onSelectionChanged: function onSelectionChanged() {
	        // do nothing
	    }
	};
	
	exports.default = function (Component) {
	    var Selectable = function (_React$Component) {
	        _inherits(Selectable, _React$Component);
	
	        function Selectable(props) {
	            _classCallCheck(this, Selectable);
	
	            var _this = _possibleConstructorReturn(this, (Selectable.__proto__ || Object.getPrototypeOf(Selectable)).call(this, props));
	
	            _this.handleChangeHeaderCheckbox = _this.handleChangeHeaderCheckbox.bind(_this);
	            _this.handleChangeRowCheckbox = _this.handleChangeRowCheckbox.bind(_this);
	            _this.builRowCheckbox = _this.builRowCheckbox.bind(_this);
	
	            if (props.selectable) {
	                _this.state = {
	                    headerSelected: false,
	                    selectedRows: []
	                };
	            }
	            return _this;
	        }
	
	        _createClass(Selectable, [{
	            key: 'componentWillReceiveProps',
	            value: function componentWillReceiveProps(nextProps) {
	                var _this2 = this;
	
	                if (nextProps.selectable) {
	                    (function () {
	                        var rows = nextProps.rows,
	                            data = nextProps.data,
	                            rowKeyColumn = nextProps.rowKeyColumn;
	
	                        var rrows = rows || data;
	
	                        if (!(0, _lodash2.default)(_this2.props.rows || _this2.props.data, rrows)) {
	                            // keep only existing rows
	                            var selectedRows = _this2.state.selectedRows.filter(function (k) {
	                                return rrows.map(function (row, i) {
	                                    return row[rowKeyColumn] || row.key || i;
	                                }).indexOf(k) > -1;
	                            });
	
	                            _this2.setState({
	                                headerSelected: selectedRows.length === rrows.length,
	                                selectedRows: selectedRows
	                            });
	
	                            nextProps.onSelectionChanged(selectedRows);
	                        }
	                    })();
	                }
	            }
	        }, {
	            key: 'handleChangeHeaderCheckbox',
	            value: function handleChangeHeaderCheckbox(e) {
	                var _props = this.props,
	                    rowKeyColumn = _props.rowKeyColumn,
	                    rows = _props.rows,
	                    data = _props.data;
	
	                var selected = e.target.checked;
	                var selectedRows = selected ? (rows || data).map(function (row, idx) {
	                    return row[rowKeyColumn] || row.key || idx;
	                }) : [];
	
	                this.setState({
	                    headerSelected: selected,
	                    selectedRows: selectedRows
	                });
	
	                this.props.onSelectionChanged(selectedRows);
	            }
	        }, {
	            key: 'handleChangeRowCheckbox',
	            value: function handleChangeRowCheckbox(e) {
	                var _props2 = this.props,
	                    rows = _props2.rows,
	                    data = _props2.data;
	
	                var rowId = JSON.parse(e.target.dataset.reactmdl).id;
	                var rowChecked = e.target.checked;
	                var selectedRows = this.state.selectedRows;
	
	                if (rowChecked) {
	                    selectedRows.push(rowId);
	                } else {
	                    var idx = selectedRows.indexOf(rowId);
	                    selectedRows.splice(idx, 1);
	                }
	
	                this.setState({
	                    headerSelected: (rows || data).length === selectedRows.length,
	                    selectedRows: selectedRows
	                });
	
	                this.props.onSelectionChanged(selectedRows);
	            }
	        }, {
	            key: 'builRowCheckbox',
	            value: function builRowCheckbox(content, row, idx) {
	                var rowKey = row[this.props.rowKeyColumn] || row.key || idx;
	                var isSelected = this.state.selectedRows.indexOf(rowKey) > -1;
	                return _react2.default.createElement(_Checkbox2.default, {
	                    className: 'mdl-data-table__select',
	                    'data-reactmdl': JSON.stringify({ id: rowKey }),
	                    checked: isSelected,
	                    onChange: this.handleChangeRowCheckbox
	                });
	            }
	        }, {
	            key: 'render',
	            value: function render() {
	                var _this3 = this;
	
	                var _props3 = this.props,
	                    rows = _props3.rows,
	                    data = _props3.data,
	                    selectable = _props3.selectable,
	                    children = _props3.children,
	                    rowKeyColumn = _props3.rowKeyColumn,
	                    otherProps = _objectWithoutProperties(_props3, ['rows', 'data', 'selectable', 'children', 'rowKeyColumn']);
	
	                // remove unwatned props
	                // see https://github.com/Hacker0x01/react-datepicker/issues/517#issuecomment-230171426
	
	
	                delete otherProps.onSelectionChanged;
	
	                var realRows = selectable ? (rows || data).map(function (row, idx) {
	                    var rowKey = row[rowKeyColumn] || row.key || idx;
	                    return _extends({}, row, {
	                        className: (0, _classnames2.default)({
	                            'is-selected': _this3.state.selectedRows.indexOf(rowKey) > -1
	                        }, row.className)
	                    });
	                }) : rows || data;
	
	                return _react2.default.createElement(Component, _extends({ rows: realRows }, otherProps), selectable && _react2.default.createElement(_TableHeader2.default, { name: 'mdl-header-select', cellFormatter: this.builRowCheckbox }, _react2.default.createElement(_Checkbox2.default, {
	                    className: 'mdl-data-table__select',
	                    checked: this.state.headerSelected,
	                    onChange: this.handleChangeHeaderCheckbox
	                })), children);
	            }
	        }]);
	
	        return Selectable;
	    }(_react2.default.Component);
	
	    Selectable.propTypes = propTypes;
	    Selectable.defaultProps = defaultProps;
	    return Selectable;
	};

/***/ }),
/* 255 */
/*!***********************************************!*\
  !*** ./~/react-mdl/lib/DataTable/Sortable.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _TableHeader = __webpack_require__(/*! ./TableHeader */ 50);
	
	var _TableHeader2 = _interopRequireDefault(_TableHeader);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	function initState(props) {
	    return {
	        rows: (props.rows || props.data).slice(),
	        sortHeader: null,
	        isAsc: true
	    };
	}
	
	var propTypes = {
	    columns: function columns(props, propName, componentName) {
	        return props[propName] && new Error(componentName + ': `' + propName + '` is deprecated, please use the component `TableHeader` instead.');
	    },
	    data: function data(props, propName, componentName) {
	        return props[propName] && new Error(componentName + ': `' + propName + '` is deprecated, please use `rows` instead. `' + propName + '` will be removed in the next major release.');
	    },
	    rows: _react.PropTypes.arrayOf(_react.PropTypes.object).isRequired,
	    sortable: _react.PropTypes.bool
	};
	
	exports.default = function (Component) {
	    var Sortable = function (_React$Component) {
	        _inherits(Sortable, _React$Component);
	
	        function Sortable(props) {
	            _classCallCheck(this, Sortable);
	
	            var _this = _possibleConstructorReturn(this, (Sortable.__proto__ || Object.getPrototypeOf(Sortable)).call(this, props));
	
	            _this.handleClickColumn = _this.handleClickColumn.bind(_this);
	
	            if (props.sortable) {
	                _this.state = initState(props);
	            }
	            return _this;
	        }
	
	        _createClass(Sortable, [{
	            key: 'componentWillReceiveProps',
	            value: function componentWillReceiveProps(nextProps) {
	                if (nextProps.sortable) {
	                    var realRows = nextProps.rows || nextProps.data;
	                    var rows = this.state.sortHeader ? this.getSortedRowsForColumn(this.state.isAsc, this.state.sortHeader, realRows) : realRows;
	
	                    this.setState({
	                        rows: rows
	                    });
	                }
	            }
	        }, {
	            key: 'getColumnClass',
	            value: function getColumnClass(column) {
	                var _state = this.state,
	                    sortHeader = _state.sortHeader,
	                    isAsc = _state.isAsc;
	
	                return (0, _classnames2.default)(column.className, {
	                    'mdl-data-table__header--sorted-ascending': sortHeader === column.name && isAsc,
	                    'mdl-data-table__header--sorted-descending': sortHeader === column.name && !isAsc
	                });
	            }
	        }, {
	            key: 'getDefaultSortFn',
	            value: function getDefaultSortFn(a, b, isAsc) {
	                return isAsc ? a.localeCompare(b) : b.localeCompare(a);
	            }
	        }, {
	            key: 'getSortedRowsForColumn',
	            value: function getSortedRowsForColumn(isAsc, columnName, rows) {
	                var columns = !!this.props.children ? _react2.default.Children.map(this.props.children, function (child) {
	                    return child.props;
	                }) : this.props.columns;
	
	                var sortFn = this.getDefaultSortFn;
	                for (var i = 0; i < columns.length; i++) {
	                    if (columns[i].name === columnName && columns[i].sortFn) {
	                        sortFn = columns[i].sortFn;
	                        break;
	                    }
	                }
	
	                return rows.sort(function (a, b) {
	                    return sortFn(String(a[columnName]), String(b[columnName]), isAsc);
	                });
	            }
	        }, {
	            key: 'handleClickColumn',
	            value: function handleClickColumn(e, columnName) {
	                var isAsc = this.state.sortHeader === columnName ? !this.state.isAsc : true;
	                var rows = this.getSortedRowsForColumn(isAsc, columnName, this.state.rows);
	                this.setState({
	                    sortHeader: columnName,
	                    isAsc: isAsc,
	                    rows: rows
	                });
	            }
	        }, {
	            key: 'renderTableHeaders',
	            value: function renderTableHeaders() {
	                var _this2 = this;
	
	                var _props = this.props,
	                    children = _props.children,
	                    columns = _props.columns,
	                    sortable = _props.sortable;
	
	                if (sortable) {
	                    return children ? _react2.default.Children.map(children, function (child) {
	                        return _react2.default.cloneElement(child, {
	                            className: _this2.getColumnClass(child.props),
	                            onClick: _this2.handleClickColumn
	                        });
	                    }) : columns.map(function (column) {
	                        return _react2.default.createElement(_TableHeader2.default, {
	                            key: column.name,
	                            className: _this2.getColumnClass(column),
	                            name: column.name,
	                            numeric: column.numeric,
	                            tooltip: column.tooltip,
	                            onClick: _this2.handleClickColumn
	                        }, column.label);
	                    });
	                }
	                return children;
	            }
	        }, {
	            key: 'render',
	            value: function render() {
	                var _props2 = this.props,
	                    rows = _props2.rows,
	                    data = _props2.data,
	                    otherProps = _objectWithoutProperties(_props2, ['rows', 'data']);
	
	                var realRows = this.state && this.state.rows || rows || data;
	
	                // remove unwanted props
	                delete otherProps.sortable;
	
	                return _react2.default.createElement(Component, _extends({ rows: realRows }, otherProps), this.renderTableHeaders());
	            }
	        }]);
	
	        return Sortable;
	    }(_react2.default.Component);
	
	    Sortable.propTypes = propTypes;
	    return Sortable;
	};

/***/ }),
/* 256 */
/*!********************************************!*\
  !*** ./~/react-mdl/lib/DataTable/Table.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.UndecoratedTable = undefined;
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _clamp = __webpack_require__(/*! clamp */ 43);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _shadows = __webpack_require__(/*! ../utils/shadows */ 52);
	
	var _shadows2 = _interopRequireDefault(_shadows);
	
	var _TableHeader = __webpack_require__(/*! ./TableHeader */ 50);
	
	var _TableHeader2 = _interopRequireDefault(_TableHeader);
	
	var _Selectable = __webpack_require__(/*! ./Selectable */ 254);
	
	var _Selectable2 = _interopRequireDefault(_Selectable);
	
	var _Sortable = __webpack_require__(/*! ./Sortable */ 255);
	
	var _Sortable2 = _interopRequireDefault(_Sortable);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    columns: function columns(props, propName, componentName) {
	        return props[propName] && new Error(componentName + ': `' + propName + '` is deprecated, please use the component `TableHeader` instead.');
	    },
	    data: function data(props, propName, componentName) {
	        return props[propName] && new Error(componentName + ': `' + propName + '` is deprecated, please use `rows` instead. `' + propName + '` will be removed in the next major release.');
	    },
	    rowKeyColumn: _react.PropTypes.string,
	    rows: _react.PropTypes.arrayOf(_react.PropTypes.object).isRequired,
	    shadow: _react.PropTypes.number
	};
	
	var Table = function (_React$Component) {
	    _inherits(Table, _React$Component);
	
	    function Table() {
	        _classCallCheck(this, Table);
	
	        return _possibleConstructorReturn(this, (Table.__proto__ || Object.getPrototypeOf(Table)).apply(this, arguments));
	    }
	
	    _createClass(Table, [{
	        key: 'renderCell',
	        value: function renderCell(column, row, idx) {
	            var className = !column.numeric ? 'mdl-data-table__cell--non-numeric' : '';
	            return _react2.default.createElement('td', { key: column.name, className: className }, column.cellFormatter ? column.cellFormatter(row[column.name], row, idx) : row[column.name]);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            var _props = this.props,
	                className = _props.className,
	                columns = _props.columns,
	                shadow = _props.shadow,
	                children = _props.children,
	                rowKeyColumn = _props.rowKeyColumn,
	                rows = _props.rows,
	                data = _props.data,
	                otherProps = _objectWithoutProperties(_props, ['className', 'columns', 'shadow', 'children', 'rowKeyColumn', 'rows', 'data']);
	
	            var realRows = rows || data;
	
	            var hasShadow = typeof shadow !== 'undefined';
	            var shadowLevel = (0, _clamp2.default)(shadow || 0, 0, _shadows2.default.length - 1);
	
	            var classes = (0, _classnames2.default)('mdl-data-table', _defineProperty({}, _shadows2.default[shadowLevel], hasShadow), className);
	
	            var columnChildren = !!children ? _react2.default.Children.toArray(children) : columns.map(function (column) {
	                return _react2.default.createElement(_TableHeader2.default, {
	                    key: column.name,
	                    className: column.className,
	                    name: column.name,
	                    numeric: column.numeric,
	                    tooltip: column.tooltip
	                }, column.label);
	            });
	            return _react2.default.createElement('table', _extends({ className: classes }, otherProps), _react2.default.createElement('thead', null, _react2.default.createElement('tr', null, columnChildren)), _react2.default.createElement('tbody', null, realRows.map(function (row, idx) {
	                var _ref = row.mdlRowProps || {},
	                    mdlRowPropsClassName = _ref.className,
	                    remainingMdlRowProps = _objectWithoutProperties(_ref, ['className']);
	
	                return _react2.default.createElement('tr', _extends({
	                    key: row[rowKeyColumn] || row.key || idx,
	                    className: (0, _classnames2.default)(row.className, mdlRowPropsClassName)
	                }, remainingMdlRowProps), columnChildren.map(function (child) {
	                    return _this2.renderCell(child.props, row, idx);
	                }));
	            })));
	        }
	    }]);
	
	    return Table;
	}(_react2.default.Component);
	
	Table.propTypes = propTypes;
	
	exports.default = (0, _Sortable2.default)((0, _Selectable2.default)(Table));
	var UndecoratedTable = exports.UndecoratedTable = Table;

/***/ }),
/* 257 */
/*!********************************************!*\
  !*** ./~/react-mdl/lib/DataTable/index.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _TableHeader = __webpack_require__(/*! ./TableHeader */ 50);
	
	Object.defineProperty(exports, 'TableHeader', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TableHeader).default;
	  }
	});
	
	var _Table = __webpack_require__(/*! ./Table */ 256);
	
	Object.defineProperty(exports, 'Table', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Table).default;
	  }
	});
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Table).default;
	  }
	});
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

/***/ }),
/* 258 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/Dialog/Dialog.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    onCancel: _react.PropTypes.func,
	    open: _react.PropTypes.bool
	};
	
	var defaultProps = {
	    onCancel: function onCancel(e) {
	        return e.preventDefault();
	    }
	};
	
	var Dialog = function (_React$Component) {
	    _inherits(Dialog, _React$Component);
	
	    function Dialog() {
	        _classCallCheck(this, Dialog);
	
	        return _possibleConstructorReturn(this, (Dialog.__proto__ || Object.getPrototypeOf(Dialog)).apply(this, arguments));
	    }
	
	    _createClass(Dialog, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.dialogRef.addEventListener('cancel', this.props.onCancel);
	            if (this.props.open) {
	                (0, _reactDom.findDOMNode)(this).showModal();
	            }
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps) {
	            if (this.props.open !== prevProps.open) {
	                if (this.props.open) {
	                    (0, _reactDom.findDOMNode)(this).showModal();
	
	                    // display the dialog at the right location
	                    // needed for the polyfill, otherwise it's not at the right position
	                    var windowHeight = window.innerHeight;
	                    if (this.dialogRef) {
	                        var dialogHeight = this.dialogRef.clientHeight;
	                        this.dialogRef.style.position = 'fixed';
	                        this.dialogRef.style.top = (windowHeight - dialogHeight) / 2 + 'px';
	                    }
	                } else {
	                    (0, _reactDom.findDOMNode)(this).close();
	                }
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            this.dialogRef.removeEventListener('cancel', this.props.onCancel);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            // We cannot set the `open` prop on the Dialog if we manage its state manually with `showModal`,
	            // this the disabled eslint rule
	            // eslint-disable-next-line no-unused-vars
	            var _props = this.props,
	                className = _props.className,
	                open = _props.open,
	                onCancel = _props.onCancel,
	                children = _props.children,
	                otherProps = _objectWithoutProperties(_props, ['className', 'open', 'onCancel', 'children']);
	
	            var classes = (0, _classnames2.default)('mdl-dialog', className);
	
	            return _react2.default.createElement('dialog', _extends({ ref: function ref(c) {
	                    return _this2.dialogRef = c;
	                }, className: classes }, otherProps), children);
	        }
	    }]);
	
	    return Dialog;
	}(_react2.default.Component);
	
	Dialog.propTypes = propTypes;
	Dialog.defaultProps = defaultProps;
	
	exports.default = Dialog;

/***/ }),
/* 259 */
/*!*************************************************!*\
  !*** ./~/react-mdl/lib/Dialog/DialogActions.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var DialogActions = function DialogActions(props) {
	    var className = props.className,
	        fullWidth = props.fullWidth,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'fullWidth', 'children']);
	
	    var classes = (0, _classnames2.default)('mdl-dialog__actions', {
	        'mdl-dialog__actions--full-width': fullWidth
	    }, className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), children);
	};
	
	DialogActions.propTypes = {
	    className: _react.PropTypes.string,
	    fullWidth: _react.PropTypes.bool
	};
	
	exports.default = DialogActions;

/***/ }),
/* 260 */
/*!***********************************************!*\
  !*** ./~/react-mdl/lib/Dialog/DialogTitle.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var DialogTitle = function DialogTitle(props) {
	    var className = props.className,
	        component = props.component,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'component', 'children']);
	
	    return _react2.default.createElement(component || 'h4', _extends({
	        className: (0, _classnames2.default)('mdl-dialog__title', className)
	    }, otherProps), children);
	};
	
	DialogTitle.propTypes = {
	    className: _react.PropTypes.string,
	    component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element, _react.PropTypes.func])
	};
	
	exports.default = DialogTitle;

/***/ }),
/* 261 */
/*!*****************************************!*\
  !*** ./~/react-mdl/lib/Dialog/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DialogActions = exports.DialogContent = exports.DialogTitle = exports.Dialog = undefined;
	
	var _Dialog = __webpack_require__(/*! ./Dialog */ 258);
	
	Object.defineProperty(exports, 'Dialog', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Dialog).default;
	  }
	});
	
	var _DialogTitle = __webpack_require__(/*! ./DialogTitle */ 260);
	
	Object.defineProperty(exports, 'DialogTitle', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DialogTitle).default;
	  }
	});
	
	var _DialogActions = __webpack_require__(/*! ./DialogActions */ 259);
	
	Object.defineProperty(exports, 'DialogActions', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DialogActions).default;
	  }
	});
	
	var _basicClassCreator = __webpack_require__(/*! ../utils/basicClassCreator */ 28);
	
	var _basicClassCreator2 = _interopRequireDefault(_basicClassCreator);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var DialogContent = exports.DialogContent = (0, _basicClassCreator2.default)('DialogContent', 'mdl-dialog__content');

/***/ }),
/* 262 */
/*!**************************************!*\
  !*** ./~/react-mdl/lib/FABButton.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Button = __webpack_require__(/*! ./Button */ 75);
	
	var _Button2 = _interopRequireDefault(_Button);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var FABButton = function FABButton(props) {
	    var mini = props.mini,
	        className = props.className,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['mini', 'className', 'children']);
	
	    var classes = (0, _classnames2.default)('mdl-button--fab', {
	        'mdl-button--mini-fab': mini
	    }, className);
	
	    return _react2.default.createElement(_Button2.default, _extends({ className: classes }, otherProps), children);
	};
	
	FABButton.propTypes = {
	    className: _react.PropTypes.string,
	    mini: _react.PropTypes.bool
	};
	
	exports.default = FABButton;

/***/ }),
/* 263 */
/*!***************************************************!*\
  !*** ./~/react-mdl/lib/Footer/DropDownSection.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _cloneChildren = __webpack_require__(/*! ../utils/cloneChildren */ 51);
	
	var _cloneChildren2 = _interopRequireDefault(_cloneChildren);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var DropDownSection = function DropDownSection(props) {
	    var className = props.className,
	        size = props.size,
	        title = props.title,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'size', 'title', 'children']);
	
	    var classes = (0, _classnames2.default)(_defineProperty({}, 'mdl-' + size + '-footer__drop-down-section', true), className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), _react2.default.createElement('input', { className: 'mdl-' + size + '-footer__heading-checkbox', type: 'checkbox', defaultChecked: true }), _react2.default.createElement('h1', { className: 'mdl-' + size + '-footer__heading' }, title), (0, _cloneChildren2.default)(children, { size: size }));
	};
	
	DropDownSection.propTypes = {
	    className: _react.PropTypes.string,
	    size: _react.PropTypes.oneOf(['mini', 'mega']),
	    title: _react.PropTypes.node.isRequired
	};
	DropDownSection.defaultProps = {
	    size: 'mega'
	};
	
	exports.default = DropDownSection;

/***/ }),
/* 264 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/Footer/Footer.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _cloneChildren = __webpack_require__(/*! ../utils/cloneChildren */ 51);
	
	var _cloneChildren2 = _interopRequireDefault(_cloneChildren);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var Footer = function Footer(props) {
	    var className = props.className,
	        size = props.size,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'size', 'children']);
	
	    var classes = (0, _classnames2.default)(_defineProperty({}, 'mdl-' + size + '-footer', true), className);
	
	    return _react2.default.createElement('footer', _extends({ className: classes }, otherProps), (0, _cloneChildren2.default)(children, { size: size }));
	};
	
	Footer.propTypes = {
	    className: _react.PropTypes.string,
	    size: _react.PropTypes.oneOf(['mini', 'mega'])
	};
	Footer.defaultProps = {
	    size: 'mega'
	};
	
	exports.default = Footer;

/***/ }),
/* 265 */
/*!********************************************!*\
  !*** ./~/react-mdl/lib/Footer/LinkList.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var LinkList = function LinkList(props) {
	    var className = props.className,
	        size = props.size,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'size', 'children']);
	
	    var classes = (0, _classnames2.default)(_defineProperty({}, 'mdl-' + size + '-footer__link-list', true), className);
	
	    return _react2.default.createElement('ul', _extends({ className: classes }, otherProps), _react2.default.Children.map(children, function (child) {
	        return _react2.default.createElement('li', null, child);
	    }));
	};
	
	LinkList.propTypes = {
	    className: _react.PropTypes.string,
	    size: _react.PropTypes.oneOf(['mini', 'mega'])
	};
	LinkList.defaultProps = {
	    size: 'mega'
	};
	
	exports.default = LinkList;

/***/ }),
/* 266 */
/*!*******************************************!*\
  !*** ./~/react-mdl/lib/Footer/Section.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _cloneChildren = __webpack_require__(/*! ../utils/cloneChildren */ 51);
	
	var _cloneChildren2 = _interopRequireDefault(_cloneChildren);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var Section = function Section(props) {
	    var className = props.className,
	        logo = props.logo,
	        size = props.size,
	        type = props.type,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'logo', 'size', 'type', 'children']);
	
	    var classes = (0, _classnames2.default)(_defineProperty({}, 'mdl-' + size + '-footer__' + type + '-section', true), className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), logo ? _react2.default.createElement('div', { className: 'mdl-logo' }, logo) : null, (0, _cloneChildren2.default)(children, { size: size }));
	};
	
	Section.propTypes = {
	    className: _react.PropTypes.string,
	    logo: _react.PropTypes.node,
	    size: _react.PropTypes.oneOf(['mini', 'mega']),
	    type: _react.PropTypes.oneOf(['top', 'middle', 'bottom', 'left', 'right'])
	};
	Section.defaultProps = {
	    size: 'mega',
	    type: 'left'
	};
	
	exports.default = Section;

/***/ }),
/* 267 */
/*!*****************************************!*\
  !*** ./~/react-mdl/lib/Footer/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Footer = __webpack_require__(/*! ./Footer */ 264);
	
	Object.defineProperty(exports, 'Footer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Footer).default;
	  }
	});
	
	var _Section = __webpack_require__(/*! ./Section */ 266);
	
	Object.defineProperty(exports, 'FooterSection', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Section).default;
	  }
	});
	
	var _DropDownSection = __webpack_require__(/*! ./DropDownSection */ 263);
	
	Object.defineProperty(exports, 'FooterDropDownSection', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DropDownSection).default;
	  }
	});
	
	var _LinkList = __webpack_require__(/*! ./LinkList */ 265);
	
	Object.defineProperty(exports, 'FooterLinkList', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_LinkList).default;
	  }
	});
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

/***/ }),
/* 268 */
/*!**************************************!*\
  !*** ./~/react-mdl/lib/Grid/Cell.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _clamp = __webpack_require__(/*! clamp */ 43);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _shadows = __webpack_require__(/*! ../utils/shadows */ 52);
	
	var _shadows2 = _interopRequireDefault(_shadows);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    align: _react.PropTypes.oneOf(['top', 'middle', 'bottom', 'stretch']),
	    className: _react.PropTypes.string,
	    col: _react.PropTypes.number,
	    component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element, _react.PropTypes.func]),
	    phone: _react.PropTypes.number,
	    tablet: _react.PropTypes.number,
	    offset: _react.PropTypes.number,
	    offsetDesktop: _react.PropTypes.number,
	    offsetTablet: _react.PropTypes.number,
	    offsetPhone: _react.PropTypes.number,
	    hideDesktop: _react.PropTypes.bool,
	    hidePhone: _react.PropTypes.bool,
	    hideTablet: _react.PropTypes.bool,
	    shadow: _react.PropTypes.number
	};
	
	function isDefined(data) {
	    return typeof data !== 'undefined';
	}
	
	var Cell = function Cell(props) {
	    var _classNames;
	
	    var align = props.align,
	        className = props.className,
	        children = props.children,
	        col = props.col,
	        phone = props.phone,
	        tablet = props.tablet,
	        component = props.component,
	        hideDesktop = props.hideDesktop,
	        hidePhone = props.hidePhone,
	        hideTablet = props.hideTablet,
	        shadow = props.shadow,
	        offset = props.offset,
	        offsetDesktop = props.offsetDesktop,
	        offsetTablet = props.offsetTablet,
	        offsetPhone = props.offsetPhone,
	        otherProps = _objectWithoutProperties(props, ['align', 'className', 'children', 'col', 'phone', 'tablet', 'component', 'hideDesktop', 'hidePhone', 'hideTablet', 'shadow', 'offset', 'offsetDesktop', 'offsetTablet', 'offsetPhone']);
	
	    var hasShadow = isDefined(shadow);
	    var shadowLevel = (0, _clamp2.default)(shadow || 0, 0, _shadows2.default.length - 1);
	
	    var classes = (0, _classnames2.default)('mdl-cell', (_classNames = {}, _defineProperty(_classNames, 'mdl-cell--' + col + '-col', isDefined(col)), _defineProperty(_classNames, 'mdl-cell--' + phone + '-col-phone', isDefined(phone)), _defineProperty(_classNames, 'mdl-cell--' + tablet + '-col-tablet', isDefined(tablet)), _defineProperty(_classNames, 'mdl-cell--' + align, isDefined(align)), _defineProperty(_classNames, 'mdl-cell--' + offset + '-offset', isDefined(offset)), _defineProperty(_classNames, 'mdl-cell--' + offsetDesktop + '-offset-desktop', isDefined(offsetDesktop)), _defineProperty(_classNames, 'mdl-cell--' + offsetTablet + '-offset-tablet', isDefined(offsetTablet)), _defineProperty(_classNames, 'mdl-cell--' + offsetPhone + '-offset-phone', isDefined(offsetPhone)), _defineProperty(_classNames, 'mdl-cell--hide-desktop', hideDesktop), _defineProperty(_classNames, 'mdl-cell--hide-phone', hidePhone), _defineProperty(_classNames, 'mdl-cell--hide-tablet', hideTablet), _defineProperty(_classNames, _shadows2.default[shadowLevel], hasShadow), _classNames), className);
	
	    return _react2.default.createElement(component || 'div', _extends({
	        className: classes
	    }, otherProps), children);
	};
	
	Cell.propTypes = propTypes;
	
	exports.default = Cell;

/***/ }),
/* 269 */
/*!**************************************!*\
  !*** ./~/react-mdl/lib/Grid/Grid.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _clamp = __webpack_require__(/*! clamp */ 43);
	
	var _clamp2 = _interopRequireDefault(_clamp);
	
	var _shadows = __webpack_require__(/*! ../utils/shadows */ 52);
	
	var _shadows2 = _interopRequireDefault(_shadows);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element, _react.PropTypes.func]),
	    noSpacing: _react.PropTypes.bool,
	    shadow: _react.PropTypes.number
	};
	
	var Grid = function Grid(props) {
	    var noSpacing = props.noSpacing,
	        className = props.className,
	        children = props.children,
	        component = props.component,
	        shadow = props.shadow,
	        otherProps = _objectWithoutProperties(props, ['noSpacing', 'className', 'children', 'component', 'shadow']);
	
	    var hasShadow = typeof shadow !== 'undefined';
	    var shadowLevel = (0, _clamp2.default)(shadow || 0, 0, _shadows2.default.length - 1);
	
	    var classes = (0, _classnames2.default)('mdl-grid', _defineProperty({
	        'mdl-grid--no-spacing': noSpacing
	    }, _shadows2.default[shadowLevel], hasShadow), className);
	
	    return _react2.default.createElement(component || 'div', _extends({
	        className: classes
	    }, otherProps), children);
	};
	
	Grid.propTypes = propTypes;
	
	exports.default = Grid;

/***/ }),
/* 270 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/Grid/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Grid = __webpack_require__(/*! ./Grid */ 269);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Grid).default;
	  }
	});
	Object.defineProperty(exports, 'Grid', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Grid).default;
	  }
	});
	
	var _Cell = __webpack_require__(/*! ./Cell */ 268);
	
	Object.defineProperty(exports, 'Cell', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Cell).default;
	  }
	});
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

/***/ }),
/* 271 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/IconButton.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Button = __webpack_require__(/*! ./Button */ 75);
	
	var _Button2 = _interopRequireDefault(_Button);
	
	var _Icon = __webpack_require__(/*! ./Icon */ 37);
	
	var _Icon2 = _interopRequireDefault(_Icon);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var IconButton = function IconButton(props) {
	    var className = props.className,
	        name = props.name,
	        otherProps = _objectWithoutProperties(props, ['className', 'name']);
	
	    var classes = (0, _classnames2.default)('mdl-button--icon', className);
	
	    return _react2.default.createElement(_Button2.default, _extends({ className: classes }, otherProps), _react2.default.createElement(_Icon2.default, { name: name }));
	};
	
	IconButton.propTypes = {
	    className: _react.PropTypes.string,
	    name: _react.PropTypes.string.isRequired
	};
	
	exports.default = IconButton;

/***/ }),
/* 272 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/IconToggle.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Icon = __webpack_require__(/*! ./Icon */ 37);
	
	var _Icon2 = _interopRequireDefault(_Icon);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    checked: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    disabled: _react.PropTypes.bool,
	    name: _react.PropTypes.string.isRequired,
	    onChange: _react.PropTypes.func,
	    ripple: _react.PropTypes.bool
	};
	
	var IconToggle = function (_React$Component) {
	    _inherits(IconToggle, _React$Component);
	
	    function IconToggle() {
	        _classCallCheck(this, IconToggle);
	
	        return _possibleConstructorReturn(this, (IconToggle.__proto__ || Object.getPrototypeOf(IconToggle)).apply(this, arguments));
	    }
	
	    _createClass(IconToggle, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps) {
	            if (this.props.disabled !== prevProps.disabled) {
	                var fnName = this.props.disabled ? 'disable' : 'enable';
	                (0, _reactDom.findDOMNode)(this).MaterialIconToggle[fnName]();
	            }
	            if (this.props.checked !== prevProps.checked) {
	                var _fnName = this.props.checked ? 'check' : 'uncheck';
	                (0, _reactDom.findDOMNode)(this).MaterialIconToggle[_fnName]();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                className = _props.className,
	                name = _props.name,
	                ripple = _props.ripple,
	                inputProps = _objectWithoutProperties(_props, ['className', 'name', 'ripple']);
	
	            var classes = (0, _classnames2.default)('mdl-icon-toggle mdl-js-icon-toggle', {
	                'mdl-js-ripple-effect': ripple
	            }, className);
	
	            return _react2.default.createElement('label', { className: classes }, _react2.default.createElement('input', _extends({
	                type: 'checkbox',
	                className: 'mdl-icon-toggle__input'
	            }, inputProps)), _react2.default.createElement(_Icon2.default, { className: 'mdl-icon-toggle__label', name: name }));
	        }
	    }]);
	
	    return IconToggle;
	}(_react2.default.Component);
	
	IconToggle.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(IconToggle, true);

/***/ }),
/* 273 */
/*!*******************************************!*\
  !*** ./~/react-mdl/lib/Layout/Content.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var Content = function Content(props) {
	    var children = props.children,
	        className = props.className,
	        component = props.component,
	        otherProps = _objectWithoutProperties(props, ['children', 'className', 'component']);
	
	    var classes = (0, _classnames2.default)('mdl-layout__content', className);
	
	    return _react2.default.createElement(component || 'div', _extends({
	        className: classes
	    }, otherProps), children);
	};
	
	Content.propTypes = {
	    className: _react.PropTypes.string,
	    component: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element, _react.PropTypes.func])
	};
	
	exports.default = Content;

/***/ }),
/* 274 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/Layout/Drawer.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var Drawer = function Drawer(props) {
	    var className = props.className,
	        title = props.title,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'title', 'children']);
	
	    var classes = (0, _classnames2.default)('mdl-layout__drawer', className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), title ? _react2.default.createElement('span', { className: 'mdl-layout-title' }, title) : null, children);
	};
	Drawer.propTypes = {
	    className: _react.PropTypes.string,
	    title: _react.PropTypes.node
	};
	
	exports.default = Drawer;

/***/ }),
/* 275 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/Layout/Header.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _HeaderRow = __webpack_require__(/*! ./HeaderRow */ 126);
	
	var _HeaderRow2 = _interopRequireDefault(_HeaderRow);
	
	var _HeaderTabs = __webpack_require__(/*! ./HeaderTabs */ 127);
	
	var _HeaderTabs2 = _interopRequireDefault(_HeaderTabs);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var Header = function Header(props) {
	    var className = props.className,
	        scroll = props.scroll,
	        seamed = props.seamed,
	        title = props.title,
	        transparent = props.transparent,
	        waterfall = props.waterfall,
	        hideTop = props.hideTop,
	        hideSpacer = props.hideSpacer,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'scroll', 'seamed', 'title', 'transparent', 'waterfall', 'hideTop', 'hideSpacer', 'children']);
	
	    var classes = (0, _classnames2.default)('mdl-layout__header', {
	        'mdl-layout__header--scroll': scroll,
	        'mdl-layout__header--seamed': seamed,
	        'mdl-layout__header--transparent': transparent,
	        'mdl-layout__header--waterfall': waterfall,
	        'mdl-layout__header--waterfall-hide-top': waterfall && hideTop
	    }, className);
	
	    var isRowOrTab = false;
	    _react2.default.Children.forEach(children, function (child) {
	        if (child && (child.type === _HeaderRow2.default || child.type === _HeaderTabs2.default)) {
	            isRowOrTab = true;
	        }
	    });
	
	    return _react2.default.createElement('header', _extends({ className: classes }, otherProps), isRowOrTab ? children : _react2.default.createElement(_HeaderRow2.default, { title: title, hideSpacer: hideSpacer }, children));
	};
	Header.propTypes = {
	    className: _react.PropTypes.string,
	    scroll: _react.PropTypes.bool,
	    seamed: _react.PropTypes.bool,
	    title: _react.PropTypes.node,
	    transparent: _react.PropTypes.bool,
	    waterfall: _react.PropTypes.bool,
	    hideTop: _react.PropTypes.bool,
	    hideSpacer: _react.PropTypes.bool
	};
	
	exports.default = Header;

/***/ }),
/* 276 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/Layout/Layout.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ../utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    fixedDrawer: _react.PropTypes.bool,
	    fixedHeader: _react.PropTypes.bool,
	    fixedTabs: _react.PropTypes.bool
	};
	
	// eslint-disable-next-line react/prefer-stateless-function
	
	var Layout = function (_React$Component) {
	    _inherits(Layout, _React$Component);
	
	    function Layout() {
	        _classCallCheck(this, Layout);
	
	        return _possibleConstructorReturn(this, (Layout.__proto__ || Object.getPrototypeOf(Layout)).apply(this, arguments));
	    }
	
	    _createClass(Layout, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                className = _props.className,
	                fixedDrawer = _props.fixedDrawer,
	                fixedHeader = _props.fixedHeader,
	                fixedTabs = _props.fixedTabs,
	                otherProps = _objectWithoutProperties(_props, ['className', 'fixedDrawer', 'fixedHeader', 'fixedTabs']);
	
	            var classes = (0, _classnames2.default)('mdl-layout mdl-js-layout', {
	                'mdl-layout--fixed-drawer': fixedDrawer,
	                'mdl-layout--fixed-header': fixedHeader,
	                'mdl-layout--fixed-tabs': fixedTabs
	            }, className);
	
	            return _react2.default.createElement('div', _extends({ className: classes }, otherProps), _react2.default.createElement('div', { className: 'mdl-layout__inner-container' }, this.props.children));
	        }
	    }]);
	
	    return Layout;
	}(_react2.default.Component);
	
	Layout.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Layout, true);

/***/ }),
/* 277 */
/*!**********************************************!*\
  !*** ./~/react-mdl/lib/Layout/Navigation.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _cloneChildren = __webpack_require__(/*! ../utils/cloneChildren */ 51);
	
	var _cloneChildren2 = _interopRequireDefault(_cloneChildren);
	
	var _Spacer = __webpack_require__(/*! ./Spacer */ 76);
	
	var _Spacer2 = _interopRequireDefault(_Spacer);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var Navigation = function Navigation(props) {
	    var className = props.className,
	        children = props.children,
	        otherProps = _objectWithoutProperties(props, ['className', 'children']);
	
	    var classes = (0, _classnames2.default)('mdl-navigation', className);
	
	    return _react2.default.createElement('nav', _extends({ className: classes }, otherProps), (0, _cloneChildren2.default)(children, function (child) {
	        return {
	            className: (0, _classnames2.default)({ 'mdl-navigation__link': child.type !== _Spacer2.default }, child.props.className)
	        };
	    }));
	};
	Navigation.propTypes = {
	    className: _react.PropTypes.string
	};
	
	exports.default = Navigation;

/***/ }),
/* 278 */
/*!*****************************************!*\
  !*** ./~/react-mdl/lib/Layout/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Layout = __webpack_require__(/*! ./Layout */ 276);
	
	Object.defineProperty(exports, 'Layout', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Layout).default;
	  }
	});
	
	var _Content = __webpack_require__(/*! ./Content */ 273);
	
	Object.defineProperty(exports, 'Content', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Content).default;
	  }
	});
	
	var _Drawer = __webpack_require__(/*! ./Drawer */ 274);
	
	Object.defineProperty(exports, 'Drawer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Drawer).default;
	  }
	});
	
	var _Header = __webpack_require__(/*! ./Header */ 275);
	
	Object.defineProperty(exports, 'Header', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Header).default;
	  }
	});
	
	var _HeaderRow = __webpack_require__(/*! ./HeaderRow */ 126);
	
	Object.defineProperty(exports, 'HeaderRow', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_HeaderRow).default;
	  }
	});
	
	var _HeaderTabs = __webpack_require__(/*! ./HeaderTabs */ 127);
	
	Object.defineProperty(exports, 'HeaderTabs', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_HeaderTabs).default;
	  }
	});
	
	var _Navigation = __webpack_require__(/*! ./Navigation */ 277);
	
	Object.defineProperty(exports, 'Navigation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Navigation).default;
	  }
	});
	
	var _Spacer = __webpack_require__(/*! ./Spacer */ 76);
	
	Object.defineProperty(exports, 'Spacer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Spacer).default;
	  }
	});
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

/***/ }),
/* 279 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/List/ListItem.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _ListItemContent = __webpack_require__(/*! ./ListItemContent */ 128);
	
	var _ListItemContent2 = _interopRequireDefault(_ListItemContent);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    children: _react.PropTypes.node,
	    className: _react.PropTypes.string,
	    twoLine: _react.PropTypes.bool,
	    threeLine: _react.PropTypes.bool
	};
	
	var ListItem = function ListItem(props) {
	    var className = props.className,
	        twoLine = props.twoLine,
	        threeLine = props.threeLine,
	        otherProps = _objectWithoutProperties(props, ['className', 'twoLine', 'threeLine']);
	
	    var classes = (0, _classnames2.default)('mdl-list__item', {
	        'mdl-list__item--two-line': twoLine && !threeLine,
	        'mdl-list__item--three-line': !twoLine && threeLine
	    }, className);
	
	    var children = _react.Children.map(otherProps.children, function (child) {
	        if (typeof child === 'string') {
	            return _react2.default.createElement(_ListItemContent2.default, null, child);
	        }
	        if (child.type === _ListItemContent2.default) {
	            return (0, _react.cloneElement)(child, {
	                useBodyClass: !!threeLine
	            });
	        }
	        return child;
	    });
	
	    return _react2.default.createElement('li', _extends({ className: classes }, otherProps), children);
	};
	
	ListItem.propTypes = propTypes;
	
	exports.default = ListItem;

/***/ }),
/* 280 */
/*!************************************************!*\
  !*** ./~/react-mdl/lib/List/ListItemAction.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var propTypes = {
	    children: _react.PropTypes.node,
	    className: _react.PropTypes.string,
	    info: _react.PropTypes.string
	};
	
	var ListItemAction = function ListItemAction(props) {
	    var children = props.children,
	        className = props.className,
	        info = props.info,
	        otherProps = _objectWithoutProperties(props, ['children', 'className', 'info']);
	
	    var classes = (0, _classnames2.default)('mdl-list__item-secondary-content', className);
	
	    return _react2.default.createElement('span', _extends({ className: classes }, otherProps), info && _react2.default.createElement('span', { className: 'mdl-list__item-secondary-info' }, info), _react2.default.createElement('span', { className: 'mdl-list__item-secondary-action' }, children));
	};
	
	ListItemAction.propTypes = propTypes;
	
	exports.default = ListItemAction;

/***/ }),
/* 281 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/List/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ListItemContent = exports.ListItemAction = exports.ListItem = exports.List = undefined;
	
	var _ListItem = __webpack_require__(/*! ./ListItem */ 279);
	
	Object.defineProperty(exports, 'ListItem', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ListItem).default;
	  }
	});
	
	var _ListItemAction = __webpack_require__(/*! ./ListItemAction */ 280);
	
	Object.defineProperty(exports, 'ListItemAction', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ListItemAction).default;
	  }
	});
	
	var _ListItemContent = __webpack_require__(/*! ./ListItemContent */ 128);
	
	Object.defineProperty(exports, 'ListItemContent', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ListItemContent).default;
	  }
	});
	
	var _basicClassCreator = __webpack_require__(/*! ../utils/basicClassCreator */ 28);
	
	var _basicClassCreator2 = _interopRequireDefault(_basicClassCreator);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var List = exports.List = (0, _basicClassCreator2.default)('List', 'mdl-list', 'ul');

/***/ }),
/* 282 */
/*!*********************************!*\
  !*** ./~/react-mdl/lib/Menu.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MenuItem = undefined;
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _basicClassCreator = __webpack_require__(/*! ./utils/basicClassCreator */ 28);
	
	var _basicClassCreator2 = _interopRequireDefault(_basicClassCreator);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    align: _react.PropTypes.oneOf(['left', 'right']),
	    className: _react.PropTypes.string,
	    ripple: _react.PropTypes.bool,
	    target: _react.PropTypes.string.isRequired,
	    valign: _react.PropTypes.oneOf(['bottom', 'top'])
	};
	
	var defaultProps = {
	    align: 'left',
	    valign: 'bottom'
	};
	
	// eslint-disable-next-line react/prefer-stateless-function
	
	var Menu = function (_React$Component) {
	    _inherits(Menu, _React$Component);
	
	    function Menu() {
	        _classCallCheck(this, Menu);
	
	        return _possibleConstructorReturn(this, (Menu.__proto__ || Object.getPrototypeOf(Menu)).apply(this, arguments));
	    }
	
	    _createClass(Menu, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            window.componentHandler.upgradeElements((0, _reactDom.findDOMNode)(this));
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            var elt = (0, _reactDom.findDOMNode)(this);
	
	            window.componentHandler.downgradeElements(elt);
	
	            var parent = elt.parentElement;
	            var grandparent = parent && parent.parentElement;
	
	            if (parent && grandparent && parent.classList.contains('mdl-menu__container')) {
	                grandparent.replaceChild(elt, parent);
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _classNames;
	
	            var _props = this.props,
	                align = _props.align,
	                children = _props.children,
	                className = _props.className,
	                ripple = _props.ripple,
	                target = _props.target,
	                valign = _props.valign,
	                otherProps = _objectWithoutProperties(_props, ['align', 'children', 'className', 'ripple', 'target', 'valign']);
	
	            var classes = (0, _classnames2.default)('mdl-menu mdl-js-menu', (_classNames = {}, _defineProperty(_classNames, 'mdl-menu--' + valign + '-' + align, true), _defineProperty(_classNames, 'mdl-js-ripple-effect', ripple), _classNames), className);
	
	            return _react2.default.createElement('ul', _extends({ className: classes, 'data-mdl-for': target }, otherProps), children);
	        }
	    }]);
	
	    return Menu;
	}(_react2.default.Component);
	
	Menu.propTypes = propTypes;
	Menu.defaultProps = defaultProps;
	
	exports.default = Menu;
	var MenuItem = exports.MenuItem = (0, _basicClassCreator2.default)('MenuItem', 'mdl-menu__item', 'li');

/***/ }),
/* 283 */
/*!****************************************!*\
  !*** ./~/react-mdl/lib/ProgressBar.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    buffer: _react.PropTypes.number,
	    className: _react.PropTypes.string,
	    indeterminate: _react.PropTypes.bool,
	    progress: _react.PropTypes.number
	};
	
	var ProgressBar = function (_React$Component) {
	    _inherits(ProgressBar, _React$Component);
	
	    function ProgressBar() {
	        _classCallCheck(this, ProgressBar);
	
	        return _possibleConstructorReturn(this, (ProgressBar.__proto__ || Object.getPrototypeOf(ProgressBar)).apply(this, arguments));
	    }
	
	    _createClass(ProgressBar, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.setProgress(this.props.progress);
	            this.setBuffer(this.props.buffer);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            this.setProgress(this.props.progress);
	            this.setBuffer(this.props.buffer);
	        }
	    }, {
	        key: 'setProgress',
	        value: function setProgress(progress) {
	            if (!this.props.indeterminate && progress !== undefined) {
	                (0, _reactDom.findDOMNode)(this).MaterialProgress.setProgress(progress);
	            }
	        }
	    }, {
	        key: 'setBuffer',
	        value: function setBuffer(buffer) {
	            if (buffer !== undefined) {
	                (0, _reactDom.findDOMNode)(this).MaterialProgress.setBuffer(buffer);
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                className = _props.className,
	                indeterminate = _props.indeterminate,
	                buffer = _props.buffer,
	                progress = _props.progress,
	                otherProps = _objectWithoutProperties(_props, ['className', 'indeterminate', 'buffer', 'progress']);
	
	            var classes = (0, _classnames2.default)('mdl-progress mdl-js-progress', {
	                'mdl-progress__indeterminate': indeterminate
	            }, className);
	
	            return _react2.default.createElement('div', _extends({ className: classes }, otherProps));
	        }
	    }]);
	
	    return ProgressBar;
	}(_react2.default.Component);
	
	ProgressBar.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(ProgressBar);

/***/ }),
/* 284 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/RadioGroup.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Radio = __webpack_require__(/*! ./Radio */ 129);
	
	var _Radio2 = _interopRequireDefault(_Radio);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _defineProperty(obj, key, value) {
	    if (key in obj) {
	        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
	    } else {
	        obj[key] = value;
	    }return obj;
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var RadioGroup = function RadioGroup(props) {
	    var name = props.name,
	        value = props.value,
	        children = props.children,
	        container = props.container,
	        childContainer = props.childContainer,
	        onChange = props.onChange,
	        otherProps = _objectWithoutProperties(props, ['name', 'value', 'children', 'container', 'childContainer', 'onChange']);
	
	    var hasOnChange = typeof onChange === 'function';
	    var checked = hasOnChange ? 'checked' : 'defaultChecked';
	
	    return _react2.default.createElement(container, otherProps, _react2.default.Children.map(children, function (child) {
	        var _extends2;
	
	        var clonedChild = _react2.default.cloneElement(child, _extends((_extends2 = {}, _defineProperty(_extends2, checked, child.props.value === value), _defineProperty(_extends2, 'name', name), _defineProperty(_extends2, 'onChange', onChange), _extends2), otherProps));
	
	        return childContainer ? _react2.default.createElement(childContainer, {}, clonedChild) : clonedChild;
	    }));
	};
	
	RadioGroup.propTypes = {
	    childContainer: _react.PropTypes.string,
	    children: _react.PropTypes.arrayOf(function (props, propName, componentName) {
	        var prop = props[propName];
	        return prop.type !== _Radio2.default && new Error('\'' + componentName + '\' only accepts \'Radio\' as children.');
	    }),
	    container: _react.PropTypes.string,
	    name: _react.PropTypes.string.isRequired,
	    onChange: _react.PropTypes.func,
	    value: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]).isRequired
	};
	
	RadioGroup.defaultProps = {
	    container: 'div'
	};
	
	exports.default = RadioGroup;

/***/ }),
/* 285 */
/*!***********************************!*\
  !*** ./~/react-mdl/lib/Slider.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    max: _react.PropTypes.number.isRequired,
	    min: _react.PropTypes.number.isRequired,
	    onChange: _react.PropTypes.func,
	    value: _react.PropTypes.number
	};
	
	var Slider = function (_React$Component) {
	    _inherits(Slider, _React$Component);
	
	    function Slider() {
	        _classCallCheck(this, Slider);
	
	        return _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).apply(this, arguments));
	    }
	
	    _createClass(Slider, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (typeof this.props.value !== 'undefined') {
	                (0, _reactDom.findDOMNode)(this).MaterialSlider.change(this.props.value);
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                className = _props.className,
	                otherProps = _objectWithoutProperties(_props, ['className']);
	
	            var classes = (0, _classnames2.default)('mdl-slider mdl-js-slider', className);
	
	            return _react2.default.createElement('input', _extends({
	                className: classes,
	                type: 'range'
	            }, otherProps));
	        }
	    }]);
	
	    return Slider;
	}(_react2.default.Component);
	
	Slider.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Slider);

/***/ }),
/* 286 */
/*!*******************************************!*\
  !*** ./~/react-mdl/lib/Snackbar/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	// This component doesn't use the javascript from MDL.
	// This is the expected behavior and the reason is because it's not written in
	// a way to make it easy to use with React.
	var ANIMATION_LENGTH = 250;
	
	var propTypes = {
	    action: _react.PropTypes.string,
	    active: _react.PropTypes.bool.isRequired,
	    className: _react.PropTypes.string,
	    onActionClick: _react.PropTypes.func,
	    onTimeout: _react.PropTypes.func.isRequired,
	    timeout: _react.PropTypes.number
	};
	
	var defaultProps = {
	    timeout: 2750
	};
	
	var Snackbar = function (_React$Component) {
	    _inherits(Snackbar, _React$Component);
	
	    function Snackbar(props) {
	        _classCallCheck(this, Snackbar);
	
	        var _this = _possibleConstructorReturn(this, (Snackbar.__proto__ || Object.getPrototypeOf(Snackbar)).call(this, props));
	
	        _this.clearTimer = _this.clearTimer.bind(_this);
	        _this.timeoutId = null;
	        _this.clearTimeoutId = null;
	        _this.state = {
	            open: false
	        };
	        return _this;
	    }
	
	    _createClass(Snackbar, [{
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps) {
	            this.setState({
	                open: nextProps.active
	            });
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            if (this.timeoutId) {
	                clearTimeout(this.timeoutId);
	            }
	
	            if (this.props.active) {
	                this.timeoutId = setTimeout(this.clearTimer, this.props.timeout);
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            if (this.timeoutId) {
	                clearTimeout(this.timeoutId);
	                this.timeoutId = null;
	            }
	            if (this.clearTimeoutId) {
	                clearTimeout(this.clearTimeoutId);
	                this.clearTimeoutId = null;
	            }
	        }
	    }, {
	        key: 'clearTimer',
	        value: function clearTimer() {
	            var _this2 = this;
	
	            this.timeoutId = null;
	            this.setState({ open: false });
	
	            this.clearTimeoutId = setTimeout(function () {
	                _this2.clearTimeoutId = null;
	                _this2.props.onTimeout();
	            }, ANIMATION_LENGTH);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                action = _props.action,
	                active = _props.active,
	                className = _props.className,
	                children = _props.children,
	                onActionClick = _props.onActionClick,
	                otherProps = _objectWithoutProperties(_props, ['action', 'active', 'className', 'children', 'onActionClick']);
	
	            var open = this.state.open;
	
	            var classes = (0, _classnames2.default)('mdl-snackbar', {
	                'mdl-snackbar--active': open
	            }, className);
	
	            delete otherProps.onTimeout;
	            delete otherProps.timeout;
	
	            return _react2.default.createElement('div', _extends({ className: classes, 'aria-hidden': !open }, otherProps), _react2.default.createElement('div', { className: 'mdl-snackbar__text' }, active && children), active && action && _react2.default.createElement('button', { className: 'mdl-snackbar__action', type: 'button', onClick: onActionClick }, action));
	        }
	    }]);
	
	    return Snackbar;
	}(_react2.default.Component);
	
	Snackbar.propTypes = propTypes;
	Snackbar.defaultProps = defaultProps;
	
	exports.default = Snackbar;

/***/ }),
/* 287 */
/*!************************************!*\
  !*** ./~/react-mdl/lib/Spinner.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    singleColor: _react.PropTypes.bool
	};
	
	// eslint-disable-next-line react/prefer-stateless-function
	
	var Spinner = function (_React$Component) {
	    _inherits(Spinner, _React$Component);
	
	    function Spinner() {
	        _classCallCheck(this, Spinner);
	
	        return _possibleConstructorReturn(this, (Spinner.__proto__ || Object.getPrototypeOf(Spinner)).apply(this, arguments));
	    }
	
	    _createClass(Spinner, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                className = _props.className,
	                singleColor = _props.singleColor,
	                otherProps = _objectWithoutProperties(_props, ['className', 'singleColor']);
	
	            var classes = (0, _classnames2.default)('mdl-spinner mdl-js-spinner is-active', {
	                'mdl-spinner--single-color': singleColor
	            }, className);
	
	            return _react2.default.createElement('div', _extends({ className: classes }, otherProps));
	        }
	    }]);
	
	    return Spinner;
	}(_react2.default.Component);
	
	Spinner.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Spinner);

/***/ }),
/* 288 */
/*!***********************************!*\
  !*** ./~/react-mdl/lib/Switch.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    checked: _react.PropTypes.bool,
	    className: _react.PropTypes.string,
	    disabled: _react.PropTypes.bool,
	    onChange: _react.PropTypes.func,
	    ripple: _react.PropTypes.bool
	};
	
	var Switch = function (_React$Component) {
	    _inherits(Switch, _React$Component);
	
	    function Switch() {
	        _classCallCheck(this, Switch);
	
	        return _possibleConstructorReturn(this, (Switch.__proto__ || Object.getPrototypeOf(Switch)).apply(this, arguments));
	    }
	
	    _createClass(Switch, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps) {
	            if (this.props.disabled !== prevProps.disabled) {
	                var fnName = this.props.disabled ? 'disable' : 'enable';
	                (0, _reactDom.findDOMNode)(this).MaterialSwitch[fnName]();
	            }
	            if (this.props.checked !== prevProps.checked) {
	                var _fnName = this.props.checked ? 'on' : 'off';
	                (0, _reactDom.findDOMNode)(this).MaterialSwitch[_fnName]();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                className = _props.className,
	                ripple = _props.ripple,
	                children = _props.children,
	                inputProps = _objectWithoutProperties(_props, ['className', 'ripple', 'children']);
	
	            var classes = (0, _classnames2.default)('mdl-switch mdl-js-switch', {
	                'mdl-js-ripple-effect': ripple
	            }, className);
	
	            return _react2.default.createElement('label', { className: classes }, _react2.default.createElement('input', _extends({
	                type: 'checkbox',
	                className: 'mdl-switch__input'
	            }, inputProps)), _react2.default.createElement('span', { className: 'mdl-switch__label' }, children));
	        }
	    }]);
	
	    return Switch;
	}(_react2.default.Component);
	
	Switch.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Switch, true);

/***/ }),
/* 289 */
/*!**************************************!*\
  !*** ./~/react-mdl/lib/Tabs/Tabs.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _Tab = __webpack_require__(/*! ./Tab */ 130);
	
	var _Tab2 = _interopRequireDefault(_Tab);
	
	var _TabBar = __webpack_require__(/*! ./TabBar */ 77);
	
	var _TabBar2 = _interopRequireDefault(_TabBar);
	
	var _mdlUpgrade = __webpack_require__(/*! ../utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	var TabPropType = function TabPropType(props, propName, componentName) {
	    var prop = props[propName];
	    return prop.type !== _Tab2.default && new Error('\'' + componentName + '\' only accepts \'Tab\' as children.');
	};
	
	var propTypes = {
	    activeTab: _react.PropTypes.number,
	    children: _react.PropTypes.oneOfType([TabPropType, _react.PropTypes.arrayOf(TabPropType)]),
	    className: _react.PropTypes.string,
	    onChange: _react.PropTypes.func,
	    tabBarProps: _react.PropTypes.object,
	    ripple: _react.PropTypes.bool
	};
	
	var Tabs = function Tabs(props) {
	    var activeTab = props.activeTab,
	        className = props.className,
	        onChange = props.onChange,
	        children = props.children,
	        tabBarProps = props.tabBarProps,
	        ripple = props.ripple,
	        otherProps = _objectWithoutProperties(props, ['activeTab', 'className', 'onChange', 'children', 'tabBarProps', 'ripple']);
	
	    var classes = (0, _classnames2.default)('mdl-tabs mdl-js-tabs', {
	        'mdl-js-ripple-effect': ripple
	    }, className);
	
	    return _react2.default.createElement('div', _extends({ className: classes }, otherProps), _react2.default.createElement(_TabBar2.default, _extends({ cssPrefix: 'mdl-tabs', activeTab: activeTab, onChange: onChange }, tabBarProps), children));
	};
	
	Tabs.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Tabs, true);

/***/ }),
/* 290 */
/*!***************************************!*\
  !*** ./~/react-mdl/lib/Tabs/index.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Tabs = __webpack_require__(/*! ./Tabs */ 289);
	
	Object.defineProperty(exports, 'Tabs', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Tabs).default;
	  }
	});
	
	var _TabBar = __webpack_require__(/*! ./TabBar */ 77);
	
	Object.defineProperty(exports, 'TabBar', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_TabBar).default;
	  }
	});
	
	var _Tab = __webpack_require__(/*! ./Tab */ 130);
	
	Object.defineProperty(exports, 'Tab', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Tab).default;
	  }
	});
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

/***/ }),
/* 291 */
/*!**************************************!*\
  !*** ./~/react-mdl/lib/Textfield.js ***!
  \**************************************/
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];for (var key in source) {
	            if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	            }
	        }
	    }return target;
	};
	
	var _createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	    };
	}();
	
	var _react = __webpack_require__(/*! react */ 1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(/*! react-dom */ 11);
	
	var _classnames = __webpack_require__(/*! classnames */ 2);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _mdlUpgrade = __webpack_require__(/*! ./utils/mdlUpgrade */ 14);
	
	var _mdlUpgrade2 = _interopRequireDefault(_mdlUpgrade);
	
	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	    var target = {};for (var i in obj) {
	        if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	    }return target;
	}
	
	function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	}
	
	function _possibleConstructorReturn(self, call) {
	    if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}
	
	function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
	    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	
	var propTypes = {
	    className: _react.PropTypes.string,
	    disabled: _react.PropTypes.bool,
	    error: _react.PropTypes.node,
	    expandable: _react.PropTypes.bool,
	    expandableIcon: _react.PropTypes.string,
	    floatingLabel: _react.PropTypes.bool,
	    id: _react.PropTypes.string,
	    inputClassName: _react.PropTypes.string,
	    label: _react.PropTypes.string.isRequired,
	    maxRows: _react.PropTypes.number,
	    onChange: _react.PropTypes.func,
	    pattern: _react.PropTypes.string,
	    required: _react.PropTypes.bool,
	    rows: _react.PropTypes.number,
	    style: _react.PropTypes.object,
	    value: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number])
	};
	
	var Textfield = function (_React$Component) {
	    _inherits(Textfield, _React$Component);
	
	    function Textfield() {
	        _classCallCheck(this, Textfield);
	
	        return _possibleConstructorReturn(this, (Textfield.__proto__ || Object.getPrototypeOf(Textfield)).apply(this, arguments));
	    }
	
	    _createClass(Textfield, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (this.props.error && !this.props.pattern) {
	                this.setAsInvalid();
	            }
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps) {
	            if (this.props.required !== prevProps.required || this.props.pattern !== prevProps.pattern || this.props.error !== prevProps.error) {
	                (0, _reactDom.findDOMNode)(this).MaterialTextfield.checkValidity();
	            }
	            if (this.props.disabled !== prevProps.disabled) {
	                (0, _reactDom.findDOMNode)(this).MaterialTextfield.checkDisabled();
	            }
	            if (this.props.value !== prevProps.value && this.inputRef !== document.activeElement) {
	                (0, _reactDom.findDOMNode)(this).MaterialTextfield.change(this.props.value);
	            }
	            if (this.props.error && !this.props.pattern) {
	                // Every time the input gets updated by MDL (checkValidity() or change())
	                // its invalid class gets reset. We have to put it again if the input is specifically set as "invalid"
	                this.setAsInvalid();
	            }
	        }
	    }, {
	        key: 'setAsInvalid',
	        value: function setAsInvalid() {
	            var elt = (0, _reactDom.findDOMNode)(this);
	            if (elt.className.indexOf('is-invalid') < 0) {
	                elt.className = (0, _classnames2.default)(elt.className, 'is-invalid');
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this2 = this;
	
	            var _props = this.props,
	                className = _props.className,
	                inputClassName = _props.inputClassName,
	                id = _props.id,
	                error = _props.error,
	                expandable = _props.expandable,
	                expandableIcon = _props.expandableIcon,
	                floatingLabel = _props.floatingLabel,
	                label = _props.label,
	                maxRows = _props.maxRows,
	                rows = _props.rows,
	                style = _props.style,
	                children = _props.children,
	                otherProps = _objectWithoutProperties(_props, ['className', 'inputClassName', 'id', 'error', 'expandable', 'expandableIcon', 'floatingLabel', 'label', 'maxRows', 'rows', 'style', 'children']);
	
	            var hasRows = !!rows;
	            var customId = id || 'textfield-' + label.replace(/[^a-z0-9]/gi, '');
	            var inputTag = hasRows || maxRows > 1 ? 'textarea' : 'input';
	
	            var inputProps = _extends({
	                className: (0, _classnames2.default)('mdl-textfield__input', inputClassName),
	                id: customId,
	                rows: rows,
	                ref: function ref(c) {
	                    return _this2.inputRef = c;
	                }
	            }, otherProps);
	
	            var input = _react2.default.createElement(inputTag, inputProps);
	            var labelContainer = _react2.default.createElement('label', { className: 'mdl-textfield__label', htmlFor: customId }, label);
	            var errorContainer = !!error && _react2.default.createElement('span', { className: 'mdl-textfield__error' }, error);
	
	            var containerClasses = (0, _classnames2.default)('mdl-textfield mdl-js-textfield', {
	                'mdl-textfield--floating-label': floatingLabel,
	                'mdl-textfield--expandable': expandable
	            }, className);
	
	            return expandable ? _react2.default.createElement('div', { className: containerClasses, style: style }, _react2.default.createElement('label', { className: 'mdl-button mdl-js-button mdl-button--icon', htmlFor: customId }, _react2.default.createElement('i', { className: 'material-icons' }, expandableIcon)), _react2.default.createElement('div', { className: 'mdl-textfield__expandable-holder' }, input, labelContainer, errorContainer), children) : _react2.default.createElement('div', { className: containerClasses, style: style }, input, labelContainer, errorContainer, children);
	        }
	    }]);
	
	    return Textfield;
	}(_react2.default.Component);
	
	Textfield.propTypes = propTypes;
	
	exports.default = (0, _mdlUpgrade2.default)(Textfield);

/***/ }),
/* 292 */
/*!******************************************!*\
  !*** ./~/react-mdl/lib/utils/palette.js ***!
  \******************************************/
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getColorClass = getColorClass;
	exports.getTextColorClass = getTextColorClass;
	// see https://github.com/google/material-design-lite/blob/master/src/palette/_palette.scss
	// for the color and level possibilities
	
	function getColorClass(color, level) {
	    var lvlClass = level ? '-' + level : '';
	    return 'mdl-color--' + color + lvlClass;
	}
	
	function getTextColorClass(color, level) {
	    var lvlClass = level ? '-' + level : '';
	    return 'mdl-color-text--' + color + lvlClass;
	}

/***/ }),
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */
/*!**************************************************************!*\
  !*** ./~/css-loader!./~/dialog-polyfill/dialog-polyfill.css ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(/*! ../css-loader/lib/css-base.js */ 4)();
	// imports
	
	
	// module
	exports.push([module.id, "dialog {\n  position: absolute;\n  left: 0; right: 0;\n  width: -moz-fit-content;\n  width: -webkit-fit-content;\n  width: fit-content;\n  height: -moz-fit-content;\n  height: -webkit-fit-content;\n  height: fit-content;\n  margin: auto;\n  border: solid;\n  padding: 1em;\n  background: white;\n  color: black;\n  display: block;\n}\n\ndialog:not([open]) {\n  display: none;\n}\n\ndialog + .backdrop {\n  position: fixed;\n  top: 0; right: 0; bottom: 0; left: 0;\n  background: rgba(0,0,0,0.1);\n}\n\n._dialog_overlay {\n  position: fixed;\n  top: 0; right: 0; bottom: 0; left: 0;\n}\n\ndialog.fixed {\n  position: fixed;\n  top: 50%;\n  transform: translate(0, -50%);\n}", ""]);
	
	// exports


/***/ }),
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */
/*!***********************************************!*\
  !*** ./~/dialog-polyfill/dialog-polyfill.css ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(/*! !../css-loader!./dialog-polyfill.css */ 353);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(/*! ../style-loader/addStyles.js */ 6)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../css-loader/index.js!./dialog-polyfill.css", function() {
				var newContent = require("!!../css-loader/index.js!./dialog-polyfill.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/***/ (function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ })
/******/ ])))
});
;
//# sourceMappingURL=jnpr-vendors.js.map