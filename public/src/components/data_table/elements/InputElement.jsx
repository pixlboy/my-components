/*jshint esversion: 6*/
import React from 'react';
import LabelElement from './LabelElement';
import _ from 'underscore';
import classNames from 'classnames';
let DataTableStore = require('../flux/stores/DataTableStore');
let jnprDataTableObj = require("../data_object/DataTableObjectFactory").getDataTableObject();

//let jQuery = require('jquery');

var InputElement = React.createClass({

    getInitialState() {
        var value = "";
        var checked = false;
		    var regExp = false;
        //using filter here to pre-populate the default value
        if ("filter" in this.props.data && this.props.data.filter) {
            if (this.props.data.type == 'date') {
                //initial value is set inside componentWillReceiveProps() method
            } else if (this.props.data.type == 'checkbox' && this.props.data.filter && this.props.data.filter.value1 && this.props.data.filter.value1.includes(this.props.data.value)) {
                checked = true;
            } else if (this.props.data.type == 'text') {
                value = this.props.data.filter['value1']?this.props.data.filter['value1']:"";
            }
        }
        return {
            // by default input types are text, when no type is specified
            type: 'text',
            checked: checked,
            value: value,
            regExp: regExp
        };
    },

    /**
     * Used to set pre-saved date, this is ONLY for date, for other component, already set in getInitialState method
     * Reason is: for resetting, only change state to null doesn't help for datePicker,there are two places to reset the date,
     * one inside filterView, one here. If we only change state, date won't change in UI, as it is generated by datePicker
     * so having to do like this way
     */
    componentWillReceiveProps(nextprops) {
        //only for date type, we need this, otherwise, it is break the pre-population
        if (nextprops.data.type == 'date') {
            var value="";
            if ('filter' in nextprops.data && nextprops.data.filter) {
                if (/start-date/.test(nextprops.data.id)) {
                    value = nextprops.data.filter.value1?nextprops.data.filter.value1:"";
                } else {
                    value = nextprops.data.filter.value2?nextprops.data.filter.value2:"";
                }
            }
            this.setState({
                value: value
            });
        }

    },

    componentWillMount() {
        this.handleInput = _.debounce(data => {
            this.props.inputChanged(data);
        }, 400);
    },

    // registered to Flux dataStore, for resetFilters events being dispatched by
    // clearAll button
    // now we only did this for checkbox, as the props solution is NOT working
    // for binding purpose
    componentDidMount: function() {
        DataTableStore.addFiltersReset(this.props.appId, this._filtersResetHandler);
        //adding customer configuration changing listener
        DataTableStore.addCustomConfigurationChangedCallBackHandler(this.props.appId, this._customConfigChanged);
    },

    // Unregister the filersReset events to prevent the memory leak
    componentWillUnmount: function() {
        DataTableStore.removeFiltersReset(this.props.appId, this._filtersResetHandler);
        DataTableStore.removeCustomConfigurationChangedCallBackHandler(this.props.appId, this._customConfigChanged);
    },

    _customConfigChanged: function() {
        //if user has filerModel set, then we need to do like these
        if (jnprDataTableObj.customConfiguration.filterModel && Object.keys(jnprDataTableObj.customConfiguration.filterModel).length > 0) {
            //type is text, data, checkbox
            var type = this.props.data.type;
            //id is fieldKey, or start-date-startDate, end-date-endDate, or just checkbox group value
            var id = this.props.data.id;
            Object.keys(jnprDataTableObj.customConfiguration.filterModel).forEach(key => {
                //if type if checkbx
                if (type == 'checkbox') {
                    //now clumnKey is keyfieldName
                    if (this.props.data.columnKey === key && jnprDataTableObj.customConfiguration.filterModel[key] && jnprDataTableObj.customConfiguration.filterModel[key].value1) {
                        //for checkbox, the value is Active,Expired, so we need to split them first
                        jnprDataTableObj.customConfiguration.filterModel[key].value1.split(",").forEach(option => {
                            if (option === id)
                                this.setState({
                                    checked: true
                                });
                        })
                    }
                } else {
                    //if it is keyField
                    if (key === id) {
                        //and it is textType
                        if (type === 'text') {
                            this.setState({
                                value: jnprDataTableObj.customConfiguration.filterModel[key].value1
                            });
                        }
                    }
                }
            });
        }
    },

    _filtersResetHandler: function() {
        this.setState({
            checked: false,
            value: ""
        });
    },
    onClick(ev){
       let target = ev.target;
       let data = null;
       data = {
                id: this.props.data.id,
                dataType: 'string',
                value: '',
            };
        this.setState({
            value:'',
			      regExp: false
    });
    if (this.props.hasOwnProperty('inputChanged')) {
            this.handleInput(data);
     }
    },

    onChange(ev) {
        let target = ev.target;
        let data = null;
        if (target.type === 'checkbox') {
            data = {
                id: this.props.data.id,
                dataType: 'string',
                checked: !this.state.checked
            };
            this.setState({
                checked: !this.state.checked
            });
        } else if (target.type === 'text') {
            data = {
                id: this.props.data.id,
                dataType: 'string',
                value: target.value
            };
            this.setState({
                value: target.value
            });
        } else if (target.type === 'date') {
            data = {
                id: this.props.data.id,
                dataType: 'date',
                value: target.value
            };
        }

        if (this.props.hasOwnProperty('inputChanged') && (this.state.regExp !== true) ) {
            this.handleInput(data);
        }
    },

    triggerChange(ev){
        let target = ev.target;
        let data = null;
        data = {
            id: this.props.data.id,
            dataType: 'string',
            value: target.value
        };
        /* if regExp property is present then only process this */
        if(this.props.data.enableRegExp === true){
            data.regExp = this.state.regExp;
        }
        if (this.props.hasOwnProperty('inputChanged')) {
            this.handleInput(data);
        }
    },

    onSubmit(){
        /* trigger the change method when submit is clicked */
        let createdEvent = {target:this.refs.input};
        this.triggerChange(createdEvent);
    },

    handleRegExpChange(ev){
        /* Handle regular Expression checkbox clicking. creating an event by finding the element and passing it to the onChange to trigger the change callbacks */
        this.setState({
        	   regExp: ev.target.checked
        }, function(){
        	  let createdEvent = {target:this.refs.input};
        	  this.onChange(createdEvent);
        })
    },

    render() {
        let label = null;
        let props = this.props.data;
		    let regExpSelector = null;
        let inputSectionClass = classNames({
            'rc-input-section': true,
            'filtered': !!this.state.value
        });
        let inputClass = classNames({
            'rc-input-element': true,
            'filtered': !!this.state.value
        });
         let clearClass = classNames({
            'rc-input-span': true,
            'cleared': !!this.state.value
        });
        if (props.title) {
            label = <LabelElement {...this.props}/>;
        }
        if (props.enableRegExp) {
            regExpSelector = <div className="regexp-group">
              <label><input type="checkbox" name={"reg-exp-"+ props.id} onChange={this.handleRegExpChange} checked={this.state.regExp} /> Regular Expression</label>
              { this.state.regExp && <button onClick={this.onSubmit}>Submit</button> }
            </div>;
        }
        //datepicker is not working with date type, so we change it to text
        return (
            <div className={ inputSectionClass }>
                <input
                    type={ (props.type == 'date' || props.type == 'html') ? 'text' : props.type }
                    className={ inputClass }
                    onChange={ this.onChange }
                    value={ this.state.value }
                    id={ 'rc-input-' + props.id }
                    checked={this.state.checked}
                    placeholder={ props.type == 'date' ? 'yyyy-mm-dd' : "" }
                    ref="input"
                />
                <span title="Clear" onClick={this.onClick } className={clearClass}>&times;</span>
                { regExpSelector }
                { label }
            </div>
        );
    }

});
module.exports = InputElement;
